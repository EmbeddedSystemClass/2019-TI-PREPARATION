; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\main.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\MiddleWareDrv -I..\..\User\RTT -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 --omf_browse=.\flash\obj\main.crf ..\..\User\main.c]
                          THUMB

                          AREA ||i.BitSync||, CODE, READONLY, ALIGN=2

                  BitSync PROC
;;;431    #define		BIT_LEVEL_THRESHHOLD		3
;;;432    void	BitSync(uint16_t u16InputData[], uint32_t u32Level, uint32_t u32FlagHalforFull,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;433    					 tsBitSyncStruct *psBitSyncStruct
;;;434    					)
;;;435    {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
;;;436    	uint32_t i,j;
;;;437    	uint32_t u32ScanStart, u32ScanEnd;
;;;438    	uint32_t u32LevelZeroCounter = 0,u32LevelOneCounter = 0,u32LevelState = 1;
00000c  2100              MOVS     r1,#0
00000e  2200              MOVS     r2,#0
000010  2001              MOVS     r0,#1
000012  9004              STR      r0,[sp,#0x10]
;;;439    	uint32_t u32BitOneCounter = 0,u32BitZeroCounter = 0;
000014  2000              MOVS     r0,#0
000016  9003              STR      r0,[sp,#0xc]
000018  4681              MOV      r9,r0
;;;440    	uint32_t SyncState = 0;
00001a  9002              STR      r0,[sp,#8]
;;;441    	uint32_t u32Code = 0;
00001c  9001              STR      r0,[sp,#4]
;;;442    	
;;;443    	u32LevelZeroCounter += psBitSyncStruct->u16LevelZeroCounter;
00001e  8858              LDRH     r0,[r3,#2]
000020  4401              ADD      r1,r1,r0
;;;444    	u32LevelOneCounter += psBitSyncStruct->u16LevelOneCounter;
000022  8898              LDRH     r0,[r3,#4]
000024  4402              ADD      r2,r2,r0
;;;445    	
;;;446    	// 半满
;;;447    	if(u32FlagHalforFull == 1)
000026  2f01              CMP      r7,#1
000028  d104              BNE      |L1.52|
;;;448    	{
;;;449    		u32ScanStart = 0;
00002a  f04f0c00          MOV      r12,#0
;;;450    		u32ScanEnd = 4000;
00002e  f44f687a          MOV      r8,#0xfa0
000032  e009              B        |L1.72|
                  |L1.52|
;;;451    	}
;;;452    	else if(u32FlagHalforFull == 2)
000034  2f02              CMP      r7,#2
000036  d104              BNE      |L1.66|
;;;453    	{
;;;454    		u32ScanStart = 4000;
000038  f44f6c7a          MOV      r12,#0xfa0
;;;455    		u32ScanEnd = 8000;
00003c  f44f58fa          MOV      r8,#0x1f40
000040  e002              B        |L1.72|
                  |L1.66|
;;;456    	}
;;;457    	else
;;;458    	{
;;;459    		return;
;;;460    	}
;;;461    	
;;;462    	{
;;;463    
;;;464    			// 搜索同步上升沿，即使之前已经同步也可以继续搜索
;;;465    			for( i = u32ScanStart; i < u32ScanEnd; i++)
;;;466    			{
;;;467    					switch(u32LevelState)
;;;468    					{
;;;469    						case 1:
;;;470    							if(u16InputData[i] < u32Level)
;;;471    							{
;;;472    								u32LevelZeroCounter++;
;;;473    								if(u32LevelZeroCounter > BIT_LEVEL_THRESHHOLD)
;;;474    								{
;;;475    									// 下降沿
;;;476    									u32LevelState = 0;
;;;477    									u32BitOneCounter = (u32LevelOneCounter+80)/160;
;;;478    									
;;;479    									if( psBitSyncStruct->u8FlagSync == 1)
;;;480    									{
;;;481    										// 如果已经同步
;;;482    										// 可进行位判决
;;;483    										// 根据目前的链路协议，正常情况下u32BitOneCounter不大于8
;;;484    										uint32_t k;
;;;485    										for( k = 0; k < u32BitOneCounter; k++ )
;;;486    										{
;;;487    											if((psBitSyncStruct->u32BitNumGot + k) > 100)
;;;488    											{
;;;489    													psBitSyncStruct->u32BitNumGot = 0;
;;;490    											}
;;;491    											u8BitPool[psBitSyncStruct->u32BitNumGot + k] = 1;
;;;492    										}
;;;493    										psBitSyncStruct->u32BitNumGot += u32BitOneCounter;
;;;494    										
;;;495    										if(psBitSyncStruct->u32BitNumGot >= (16+1))
;;;496    										{
;;;497    											uint32_t m = 0, u32Data = 0;
;;;498    											// 转移比特池到Code
;;;499    											for( k = 0; k < psBitSyncStruct->u32BitNumGot -1; k++ )
;;;500    											{
;;;501    													u32Data = u32Data << 1;
;;;502    													if(u8BitPool[k] == 0)
;;;503    													{
;;;504    														u32Data |= 0x01;
;;;505    													}
;;;506    													m++;
;;;507    													if( m >= 8)
;;;508    													{
;;;509    														m = 0;
;;;510    														psBitSyncStruct->u8Code[k/8] = u32Data;
;;;511    														u32Data = 0;
;;;512    													}
;;;513    											}// End for
;;;514    											psBitSyncStruct->u32BitNumGot = 0;
;;;515    										}
;;;516    									}
;;;517    									
;;;518    									u32LevelOneCounter = 0;
;;;519    									
;;;520    								}
;;;521    							}
;;;522    							else
;;;523    							{
;;;524    								u32LevelZeroCounter = 0;
;;;525    								u32LevelOneCounter++;
;;;526    								
;;;527    							}
;;;528    						break;
;;;529    						case 0:
;;;530    							if(u16InputData[i] >= u32Level)
;;;531    							{
;;;532    								u32LevelOneCounter++;
;;;533    								if(u32LevelOneCounter > BIT_LEVEL_THRESHHOLD)
;;;534    								{
;;;535    									// 上升沿，需要进行回溯
;;;536    									u32LevelState = 1;
;;;537    									u32BitZeroCounter = (u32LevelZeroCounter+80)/160;
;;;538    									u32LevelZeroCounter = 0;
;;;539    									if(u32BitZeroCounter == 8)
;;;540    									{
;;;541    										u32BitZeroCounter = 0;
;;;542    										
;;;543    										// 同步
;;;544    										SyncState = 1;
;;;545    										psBitSyncStruct->u8FlagSync = 1;
;;;546    										psBitSyncStruct->u16PosOfRiseEdge = i;
;;;547    //										for(j = 0; j < 8; j++ )
;;;548    //										{
;;;549    //											u32Code = u32Code << 1;
;;;550    //											if(u16InputData[i + j*160 + 80] > u32Level)
;;;551    //											{
;;;552    //												u32Code = u32Code | 0x01;
;;;553    //											}
;;;554    //											else
;;;555    //											{
;;;556    //											}
;;;557    //										}
;;;558    //										u32Code = ~u32Code;
;;;559    										
;;;560    										// 取走接收数据后，相关变量清0
;;;561    										psBitSyncStruct->u32BitNumGot = 0;
;;;562    //										memset((int8_t *)psBitSyncStruct->u8Code,0,sizeof(psBitSyncStruct->u8Code));
;;;563    									}
;;;564    									else
;;;565    									{
;;;566    										uint32_t k;
;;;567    										// 当前非同步上升沿
;;;568    										SyncState = 0;
;;;569    										// 如果已经同步，可进行位判决
;;;570    										if( psBitSyncStruct->u8FlagSync == 1)
;;;571    										{
;;;572    												for( k = 0; k < u32BitZeroCounter; k++ )
;;;573    												{
;;;574    														if((psBitSyncStruct->u32BitNumGot + k) > 100)
;;;575    														{
;;;576    																psBitSyncStruct->u32BitNumGot = 0;
;;;577    														}
;;;578    														u8BitPool[psBitSyncStruct->u32BitNumGot + k] = 0;
;;;579    												}
;;;580    												psBitSyncStruct->u32BitNumGot += u32BitZeroCounter;
;;;581    												
;;;582    												if(psBitSyncStruct->u32BitNumGot >= (16+1))
;;;583    												{
;;;584    													uint32_t m = 0, u32Data = 0;
;;;585    													// 转移比特池到Code
;;;586    													for( k = 0; k < psBitSyncStruct->u32BitNumGot -1; k++ )
;;;587    													{
;;;588    															u32Data = u32Data << 1;
;;;589    															if(u8BitPool[k] == 0)
;;;590    															{
;;;591    																u32Data |= 0x01;
;;;592    															}
;;;593    															m++;
;;;594    															if( m >= 8)
;;;595    															{
;;;596    																m = 0;
;;;597    																psBitSyncStruct->u8Code[k/8] = u32Data;
;;;598    																u32Data = 0;
;;;599    															}
;;;600    													}// End for
;;;601    													psBitSyncStruct->u32BitNumGot = 0;
;;;602    												}// End if(psBitSyncStruct->u32BitNumGot >= (16+1))
;;;603    										}// End if( psBitSyncStruct->u16FlagSync == 1)
;;;604    									}// End else
;;;605    								}// End if(u32LevelOneCounter > BIT_LEVEL_THRESHHOLD)
;;;606    							}// End if(u16InputData[i] >= u32Level)
;;;607    							else
;;;608    							{
;;;609    								u32LevelOneCounter = 0;
;;;610    								u32LevelZeroCounter++;
;;;611    								
;;;612    							}
;;;613    						break;	
;;;614    						default:
;;;615    						break;
;;;616    					}
;;;617    			}// End for( i = 0; i < 4000; i++)
;;;618    	}//
;;;619    	
;;;620    	if(u32LevelZeroCounter > 4000)
;;;621    	{
;;;622    		u32LevelZeroCounter = 4000;
;;;623    		psBitSyncStruct->u32BitNumGot = 0;
;;;624    		memset((int8_t *)psBitSyncStruct->u8Code,0,sizeof(psBitSyncStruct->u8Code));
;;;625    	}
;;;626    	if(u32LevelOneCounter > 4000)
;;;627    	{
;;;628    		u32LevelOneCounter = 4000;
;;;629    		psBitSyncStruct->u32BitNumGot = 0;
;;;630    		memset((int8_t *)psBitSyncStruct->u8Code,0,sizeof(psBitSyncStruct->u8Code));
;;;631    	}
;;;632    	psBitSyncStruct->u16LevelZeroCounter = u32LevelZeroCounter;
;;;633    	psBitSyncStruct->u16LevelOneCounter = u32LevelOneCounter;
;;;634    	
;;;635    	return;
;;;636    }
000042  b005              ADD      sp,sp,#0x14
000044  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.72|
000048  4664              MOV      r4,r12                ;465
00004a  e0fd              B        |L1.584|
                  |L1.76|
00004c  9804              LDR      r0,[sp,#0x10]         ;467
00004e  2800              CMP      r0,#0                 ;467
000050  d077              BEQ      |L1.322|
000052  2801              CMP      r0,#1                 ;467
000054  d170              BNE      |L1.312|
000056  f8350014          LDRH     r0,[r5,r4,LSL #1]     ;470
00005a  42b0              CMP      r0,r6                 ;470
00005c  d26e              BCS      |L1.316|
00005e  1c49              ADDS     r1,r1,#1              ;472
000060  2903              CMP      r1,#3                 ;473
000062  d96d              BLS      |L1.320|
000064  2000              MOVS     r0,#0                 ;476
000066  9004              STR      r0,[sp,#0x10]         ;476
000068  f1020050          ADD      r0,r2,#0x50           ;477
00006c  f04f0aa0          MOV      r10,#0xa0             ;477
000070  fbb0f0fa          UDIV     r0,r0,r10             ;477
000074  9003              STR      r0,[sp,#0xc]          ;477
000076  7858              LDRB     r0,[r3,#1]            ;479
000078  2801              CMP      r0,#1                 ;479
00007a  d15a              BNE      |L1.306|
00007c  2000              MOVS     r0,#0                 ;485
00007e  e013              B        |L1.168|
                  |L1.128|
000080  f8d3a008          LDR      r10,[r3,#8]           ;487
000084  4482              ADD      r10,r10,r0            ;487
000086  f1ba0f64          CMP      r10,#0x64             ;487
00008a  d903              BLS      |L1.148|
00008c  f04f0a00          MOV      r10,#0                ;489
000090  f8c3a008          STR      r10,[r3,#8]           ;489
                  |L1.148|
000094  f04f0a01          MOV      r10,#1                ;491
000098  f8d3b008          LDR      r11,[r3,#8]           ;491
00009c  4483              ADD      r11,r11,r0            ;491
00009e  f8dfe1dc          LDR      lr,|L1.636|
0000a2  f80ea00b          STRB     r10,[lr,r11]          ;491
0000a6  1c40              ADDS     r0,r0,#1              ;485
                  |L1.168|
0000a8  f8dda00c          LDR      r10,[sp,#0xc]         ;485
0000ac  4550              CMP      r0,r10                ;485
0000ae  d3e7              BCC      |L1.128|
0000b0  f8d3b008          LDR      r11,[r3,#8]           ;493
0000b4  f8dda00c          LDR      r10,[sp,#0xc]         ;493
0000b8  44da              ADD      r10,r10,r11           ;493
0000ba  f8c3a008          STR      r10,[r3,#8]           ;493
0000be  f8d3a008          LDR      r10,[r3,#8]           ;495
0000c2  f1ba0f11          CMP      r10,#0x11             ;495
0000c6  d333              BCC      |L1.304|
0000c8  f04f0b00          MOV      r11,#0                ;497
0000cc  f8cdb000          STR      r11,[sp,#0]           ;497
0000d0  46da              MOV      r10,r11               ;497
0000d2  2000              MOVS     r0,#0                 ;499
0000d4  e021              B        |L1.282|
                  |L1.214|
0000d6  ea4f0a4a          LSL      r10,r10,#1            ;501
0000da  f8dfb1a0          LDR      r11,|L1.636|
0000de  f81bb000          LDRB     r11,[r11,r0]          ;502
0000e2  f1bb0f00          CMP      r11,#0                ;502
0000e6  d101              BNE      |L1.236|
0000e8  f04a0a01          ORR      r10,r10,#1            ;504
                  |L1.236|
0000ec  f8ddb000          LDR      r11,[sp,#0]           ;506
0000f0  f10b0b01          ADD      r11,r11,#1            ;506
0000f4  f8cdb000          STR      r11,[sp,#0]           ;506
0000f8  f8ddb000          LDR      r11,[sp,#0]           ;507
0000fc  f1bb0f08          CMP      r11,#8                ;507
000100  d30a              BCC      |L1.280|
000102  f04f0b00          MOV      r11,#0                ;509
000106  f8cdb000          STR      r11,[sp,#0]           ;509
00010a  f1030e0c          ADD      lr,r3,#0xc            ;510
00010e  eb0e0ed0          ADD      lr,lr,r0,LSR #3       ;510
000112  f88ea000          STRB     r10,[lr,#0]           ;510
000116  46da              MOV      r10,r11               ;511
                  |L1.280|
000118  1c40              ADDS     r0,r0,#1              ;499
                  |L1.282|
00011a  f8d3b008          LDR      r11,[r3,#8]           ;499
00011e  f1ab0b01          SUB      r11,r11,#1            ;499
000122  4583              CMP      r11,r0                ;499
000124  d8d7              BHI      |L1.214|
000126  f04f0b00          MOV      r11,#0                ;514
00012a  f8c3b008          STR      r11,[r3,#8]           ;514
00012e  bf00              NOP                            ;515
                  |L1.304|
000130  bf00              NOP                            ;516
                  |L1.306|
000132  2200              MOVS     r2,#0                 ;518
000134  e004              B        |L1.320|
000136  e004              B        |L1.322|
                  |L1.312|
000138  e083              B        |L1.578|
00013a  e7ff              B        |L1.316|
                  |L1.316|
00013c  2100              MOVS     r1,#0                 ;524
00013e  1c52              ADDS     r2,r2,#1              ;525
                  |L1.320|
000140  e080              B        |L1.580|
                  |L1.322|
000142  f8350014          LDRH     r0,[r5,r4,LSL #1]     ;530
000146  42b0              CMP      r0,r6                 ;530
000148  d378              BCC      |L1.572|
00014a  1c52              ADDS     r2,r2,#1              ;532
00014c  2a03              CMP      r2,#3                 ;533
00014e  d977              BLS      |L1.576|
000150  2001              MOVS     r0,#1                 ;536
000152  9004              STR      r0,[sp,#0x10]         ;536
000154  f1010050          ADD      r0,r1,#0x50           ;537
000158  f04f0aa0          MOV      r10,#0xa0             ;537
00015c  fbb0f9fa          UDIV     r9,r0,r10             ;537
000160  2000              MOVS     r0,#0                 ;538
000162  4601              MOV      r1,r0                 ;538
000164  f1b90f08          CMP      r9,#8                 ;539
000168  d107              BNE      |L1.378|
00016a  4681              MOV      r9,r0                 ;541
00016c  2001              MOVS     r0,#1                 ;544
00016e  9002              STR      r0,[sp,#8]            ;544
000170  7058              STRB     r0,[r3,#1]            ;545
000172  80dc              STRH     r4,[r3,#6]            ;546
000174  2000              MOVS     r0,#0                 ;561
000176  6098              STR      r0,[r3,#8]            ;561
000178  e062              B        |L1.576|
                  |L1.378|
00017a  f04f0a00          MOV      r10,#0                ;568
00017e  f8cda008          STR      r10,[sp,#8]           ;568
000182  f893a001          LDRB     r10,[r3,#1]           ;570
000186  f1ba0f01          CMP      r10,#1                ;570
00018a  d155              BNE      |L1.568|
00018c  2000              MOVS     r0,#0                 ;572
00018e  e013              B        |L1.440|
                  |L1.400|
000190  f8d3a008          LDR      r10,[r3,#8]           ;574
000194  4482              ADD      r10,r10,r0            ;574
000196  f1ba0f64          CMP      r10,#0x64             ;574
00019a  d903              BLS      |L1.420|
00019c  f04f0a00          MOV      r10,#0                ;576
0001a0  f8c3a008          STR      r10,[r3,#8]           ;576
                  |L1.420|
0001a4  f04f0a00          MOV      r10,#0                ;578
0001a8  f8d3b008          LDR      r11,[r3,#8]           ;578
0001ac  4483              ADD      r11,r11,r0            ;578
0001ae  f8dfe0cc          LDR      lr,|L1.636|
0001b2  f80ea00b          STRB     r10,[lr,r11]          ;578
0001b6  1c40              ADDS     r0,r0,#1              ;572
                  |L1.440|
0001b8  4548              CMP      r0,r9                 ;572
0001ba  d3e9              BCC      |L1.400|
0001bc  f8d3a008          LDR      r10,[r3,#8]           ;580
0001c0  44ca              ADD      r10,r10,r9            ;580
0001c2  f8c3a008          STR      r10,[r3,#8]           ;580
0001c6  f8d3a008          LDR      r10,[r3,#8]           ;582
0001ca  f1ba0f11          CMP      r10,#0x11             ;582
0001ce  d333              BCC      |L1.568|
0001d0  f04f0b00          MOV      r11,#0                ;584
0001d4  f8cdb000          STR      r11,[sp,#0]           ;584
0001d8  46da              MOV      r10,r11               ;584
0001da  2000              MOVS     r0,#0                 ;586
0001dc  e021              B        |L1.546|
                  |L1.478|
0001de  ea4f0a4a          LSL      r10,r10,#1            ;588
0001e2  f8dfb098          LDR      r11,|L1.636|
0001e6  f81bb000          LDRB     r11,[r11,r0]          ;589
0001ea  f1bb0f00          CMP      r11,#0                ;589
0001ee  d101              BNE      |L1.500|
0001f0  f04a0a01          ORR      r10,r10,#1            ;591
                  |L1.500|
0001f4  f8ddb000          LDR      r11,[sp,#0]           ;593
0001f8  f10b0b01          ADD      r11,r11,#1            ;593
0001fc  f8cdb000          STR      r11,[sp,#0]           ;593
000200  f8ddb000          LDR      r11,[sp,#0]           ;594
000204  f1bb0f08          CMP      r11,#8                ;594
000208  d30a              BCC      |L1.544|
00020a  f04f0b00          MOV      r11,#0                ;596
00020e  f8cdb000          STR      r11,[sp,#0]           ;596
000212  f1030e0c          ADD      lr,r3,#0xc            ;597
000216  eb0e0ed0          ADD      lr,lr,r0,LSR #3       ;597
00021a  f88ea000          STRB     r10,[lr,#0]           ;597
00021e  46da              MOV      r10,r11               ;598
                  |L1.544|
000220  1c40              ADDS     r0,r0,#1              ;586
                  |L1.546|
000222  f8d3b008          LDR      r11,[r3,#8]           ;586
000226  f1ab0b01          SUB      r11,r11,#1            ;586
00022a  4583              CMP      r11,r0                ;586
00022c  d8d7              BHI      |L1.478|
00022e  f04f0b00          MOV      r11,#0                ;601
000232  f8c3b008          STR      r11,[r3,#8]           ;601
000236  bf00              NOP                            ;602
                  |L1.568|
000238  e002              B        |L1.576|
00023a  e7ff              B        |L1.572|
                  |L1.572|
00023c  2200              MOVS     r2,#0                 ;609
00023e  1c49              ADDS     r1,r1,#1              ;610
                  |L1.576|
000240  e000              B        |L1.580|
                  |L1.578|
000242  bf00              NOP                            ;615
                  |L1.580|
000244  bf00              NOP                            ;528
000246  1c64              ADDS     r4,r4,#1              ;465
                  |L1.584|
000248  4544              CMP      r4,r8                 ;465
00024a  f4ffaeff          BCC      |L1.76|
00024e  f5b16f7a          CMP      r1,#0xfa0             ;620
000252  d905              BLS      |L1.608|
000254  f44f617a          MOV      r1,#0xfa0             ;622
000258  2000              MOVS     r0,#0                 ;623
00025a  6098              STR      r0,[r3,#8]            ;623
00025c  60d8              STR      r0,[r3,#0xc]          ;624
00025e  6118              STR      r0,[r3,#0x10]         ;624
                  |L1.608|
000260  f5b26f7a          CMP      r2,#0xfa0             ;626
000264  d905              BLS      |L1.626|
000266  f44f627a          MOV      r2,#0xfa0             ;628
00026a  2000              MOVS     r0,#0                 ;629
00026c  6098              STR      r0,[r3,#8]            ;629
00026e  60d8              STR      r0,[r3,#0xc]          ;630
000270  6118              STR      r0,[r3,#0x10]         ;630
                  |L1.626|
000272  8059              STRH     r1,[r3,#2]            ;632
000274  809a              STRH     r2,[r3,#4]            ;633
000276  bf00              NOP                            ;635
000278  e6e3              B        |L1.66|
;;;637    
                          ENDP

00027a  0000              DCW      0x0000
                  |L1.636|
                          DCD      u8BitPool

                          AREA ||i.SendOneFrameDPSK||, CODE, READONLY, ALIGN=2

                  SendOneFrameDPSK PROC
;;;315    
;;;316    void SendOneFrameDPSK(uint32_t u32DataIn)
000000  b5f0              PUSH     {r4-r7,lr}
;;;317    {
000002  4602              MOV      r2,r0
;;;318    		int i,j,index = (1 << 24),u32ForePhse = 0;
000004  f04f7380          MOV      r3,#0x1000000
000008  2400              MOVS     r4,#0
;;;319    	
;;;320    	for( j = 0; j < 160; j++)
00000a  2000              MOVS     r0,#0
00000c  e006              B        |L2.28|
                  |L2.14|
;;;321    	{
;;;322    		aSRC_Buffer[j] = aSRC_0[j]; 
00000e  4d2b              LDR      r5,|L2.188|
000010  f8355010          LDRH     r5,[r5,r0,LSL #1]
000014  4e2a              LDR      r6,|L2.192|
000016  f8265010          STRH     r5,[r6,r0,LSL #1]
00001a  1c40              ADDS     r0,r0,#1              ;320
                  |L2.28|
00001c  28a0              CMP      r0,#0xa0              ;320
00001e  dbf6              BLT      |L2.14|
;;;323    	}
;;;324    	
;;;325    //	// 全0
;;;326    //	for( i = 160; i < (160 * 8); i++)
;;;327    //	{
;;;328    //		aSRC_Buffer[i] = aSRC_0[i%160]; 
;;;329    //	}
;;;330    	
;;;331    	u32ForePhse= 0;
000020  2400              MOVS     r4,#0
;;;332    
;;;333    //	// First 8 bit
;;;334    //	for( i = 160; i < (160 * 8); i++)
;;;335    //	{
;;;336    //		if(u32ForePhse == 0)
;;;337    //		{
;;;338    //				if( u32DataIn & index)
;;;339    //				{
;;;340    //						aSRC_Buffer[160 + i] = aSRC_Pi[i%160];
;;;341    //						u32ForePhse = 180;
;;;342    //				}
;;;343    //				else
;;;344    //				{
;;;345    //						aSRC_Buffer[160 + i] = aSRC_0[i%160];
;;;346    //						u32ForePhse = 0;
;;;347    //				}
;;;348    //		}
;;;349    //		else		// u32ForePhse = 180
;;;350    //		{
;;;351    //				if( u32DataIn & index)
;;;352    //				{
;;;353    //						aSRC_Buffer[160 + i] = aSRC_0[i%160];
;;;354    //						u32ForePhse = 0;
;;;355    //				}
;;;356    //				else
;;;357    //				{
;;;358    //						aSRC_Buffer[160 + i] = aSRC_0[i%160];
;;;359    //						u32ForePhse = 180;
;;;360    //				}
;;;361    //		}
;;;362    //	}
;;;363    
;;;364    	// 
;;;365    	for( i = 1; i < 25; i++)
000022  2101              MOVS     r1,#1
000024  e047              B        |L2.182|
                  |L2.38|
;;;366    	{
;;;367    		
;;;368    			index = index >> 1;
000026  105b              ASRS     r3,r3,#1
;;;369    		
;;;370    			if(u32ForePhse == 0)
000028  bb14              CBNZ     r4,|L2.112|
;;;371    			{
;;;372    					if( u32DataIn & index)
00002a  ea020503          AND      r5,r2,r3
00002e  b17d              CBZ      r5,|L2.80|
;;;373    					{
;;;374    							for(j = 0; j < 160; j++)
000030  2000              MOVS     r0,#0
000032  e009              B        |L2.72|
                  |L2.52|
;;;375    							{
;;;376    									aSRC_Buffer[160*i + j] = aSRC_Pi[j];
000034  4d23              LDR      r5,|L2.196|
000036  f8355010          LDRH     r5,[r5,r0,LSL #1]
00003a  26a0              MOVS     r6,#0xa0
00003c  fb060601          MLA      r6,r6,r1,r0
000040  4f1f              LDR      r7,|L2.192|
000042  f8275016          STRH     r5,[r7,r6,LSL #1]
000046  1c40              ADDS     r0,r0,#1              ;374
                  |L2.72|
000048  28a0              CMP      r0,#0xa0              ;374
00004a  dbf3              BLT      |L2.52|
;;;377    							}
;;;378    							u32ForePhse = 180;
00004c  24b4              MOVS     r4,#0xb4
00004e  e031              B        |L2.180|
                  |L2.80|
;;;379    					}
;;;380    					else
;;;381    					{
;;;382    							for(j = 0; j < 160; j++)
000050  2000              MOVS     r0,#0
000052  e009              B        |L2.104|
                  |L2.84|
;;;383    							{
;;;384    									aSRC_Buffer[160*i + j] = aSRC_0[j];
000054  4d19              LDR      r5,|L2.188|
000056  f8355010          LDRH     r5,[r5,r0,LSL #1]
00005a  26a0              MOVS     r6,#0xa0
00005c  fb060601          MLA      r6,r6,r1,r0
000060  4f17              LDR      r7,|L2.192|
000062  f8275016          STRH     r5,[r7,r6,LSL #1]
000066  1c40              ADDS     r0,r0,#1              ;382
                  |L2.104|
000068  28a0              CMP      r0,#0xa0              ;382
00006a  dbf3              BLT      |L2.84|
;;;385    							}
;;;386    							u32ForePhse = 0;
00006c  2400              MOVS     r4,#0
00006e  e021              B        |L2.180|
                  |L2.112|
;;;387    					}
;;;388    			}
;;;389    			else		// u32ForePhse = 180
;;;390    			{
;;;391    					if( u32DataIn & index)
000070  ea020503          AND      r5,r2,r3
000074  b17d              CBZ      r5,|L2.150|
;;;392    					{
;;;393    							for(j = 0; j < 160; j++)
000076  2000              MOVS     r0,#0
000078  e009              B        |L2.142|
                  |L2.122|
;;;394    							{
;;;395    									aSRC_Buffer[160*i + j] = aSRC_0[j];
00007a  4d10              LDR      r5,|L2.188|
00007c  f8355010          LDRH     r5,[r5,r0,LSL #1]
000080  26a0              MOVS     r6,#0xa0
000082  fb060601          MLA      r6,r6,r1,r0
000086  4f0e              LDR      r7,|L2.192|
000088  f8275016          STRH     r5,[r7,r6,LSL #1]
00008c  1c40              ADDS     r0,r0,#1              ;393
                  |L2.142|
00008e  28a0              CMP      r0,#0xa0              ;393
000090  dbf3              BLT      |L2.122|
;;;396    							}
;;;397    							u32ForePhse = 0;
000092  2400              MOVS     r4,#0
000094  e00e              B        |L2.180|
                  |L2.150|
;;;398    					}
;;;399    					else
;;;400    					{
;;;401    							for(j = 0; j < 160; j++)
000096  2000              MOVS     r0,#0
000098  e009              B        |L2.174|
                  |L2.154|
;;;402    							{
;;;403    									aSRC_Buffer[160*i + j] = aSRC_Pi[j];
00009a  4d0a              LDR      r5,|L2.196|
00009c  f8355010          LDRH     r5,[r5,r0,LSL #1]
0000a0  26a0              MOVS     r6,#0xa0
0000a2  fb060601          MLA      r6,r6,r1,r0
0000a6  4f06              LDR      r7,|L2.192|
0000a8  f8275016          STRH     r5,[r7,r6,LSL #1]
0000ac  1c40              ADDS     r0,r0,#1              ;401
                  |L2.174|
0000ae  28a0              CMP      r0,#0xa0              ;401
0000b0  dbf3              BLT      |L2.154|
;;;404    							}
;;;405    							u32ForePhse = 180;
0000b2  24b4              MOVS     r4,#0xb4
                  |L2.180|
0000b4  1c49              ADDS     r1,r1,#1              ;365
                  |L2.182|
0000b6  2919              CMP      r1,#0x19              ;365
0000b8  dbb5              BLT      |L2.38|
;;;406    					}
;;;407    			}
;;;408    		
;;;409    	}
;;;410    
;;;411    //	// Last 8bit
;;;412    //	for( i = (160 * 16); i < (160 * 24); i++)
;;;413    //	{
;;;414    //		aSRC_Buffer[160 + i] = aSRC_Pi[i%160]; 
;;;415    //	}
;;;416    	
;;;417    }
0000ba  bdf0              POP      {r4-r7,pc}
;;;418    
                          ENDP

                  |L2.188|
                          DCD      aSRC_0
                  |L2.192|
                          DCD      aSRC_Buffer
                  |L2.196|
                          DCD      aSRC_Pi

                          AREA ||i.Timer2_ADC_T2CC__Init||, CODE, READONLY, ALIGN=1

                  Timer2_ADC_T2CC__Init PROC
;;;250    
;;;251    void Timer2_ADC_T2CC__Init(void)
000000  b500              PUSH     {lr}
;;;252    {
000002  b089              SUB      sp,sp,#0x24
;;;253      NVIC_InitTypeDef NVIC_InitStructure;
;;;254      TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
;;;255    	TIM_OCInitTypeDef         TIM_OCInitStructure;	
;;;256      GPIO_InitTypeDef GPIO_InitStructure;
;;;257    	
;;;258    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;259    	
;;;260    	// 如果是Stm32f103
;;;261    	// 定时器2 PWM频率为72000000/72/10=100Khz
;;;262    	// 定时器1 PWM频率为72000000/72/(10*ADCNUM*2)
;;;263    	// 如果是Stm32f407，APB1最高频率168Mhz/4=42Mhz
;;;264    	// CMSIS默认配置
;;;265    	/* PCLK2 = HCLK / 2*/
;;;266      /* PCLK1 = HCLK / 4*/
;;;267    	// 因此APB1的频率是42M，由于分频系数是4不等于1，则
;;;268    	// 定时器2 使用APB1，因此PWM频率为HCLK/4 * 2 /TIM_Prescaler/10 = 100Khz
;;;269    	// 定时器1 使用APB2，TIMCLK = 2 * HCLK / 2 = 168000000
;;;270    	// PWM频率为168000000/TIM_Prescaler/(10*ADCNUM*2) = 100Khz/(ADCNUM*2)
;;;271    	
;;;272    	//初始化定时器 TIM2
;;;273    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;274    
;;;275    	
;;;276      /* TIM2 configuration ------------------------------------------------------*/ 
;;;277      /* Time Base configuration */
;;;278      TIM_TimeBaseStructInit(&TIM_TimeBaseStructure); 
000014  a806              ADD      r0,sp,#0x18
000016  f7fffffe          BL       TIM_TimeBaseStructInit
;;;279      TIM_TimeBaseStructure.TIM_Period = 10 - 1;          // 200khz 
00001a  2009              MOVS     r0,#9
00001c  9007              STR      r0,[sp,#0x1c]
;;;280      TIM_TimeBaseStructure.TIM_Prescaler = 84/2 - 1;     // 2000khz  
00001e  2029              MOVS     r0,#0x29
000020  f8ad0018          STRH     r0,[sp,#0x18]
;;;281      TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;    
000024  2000              MOVS     r0,#0
000026  f8ad0020          STRH     r0,[sp,#0x20]
;;;282      TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  
00002a  f8ad001a          STRH     r0,[sp,#0x1a]
;;;283      TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
00002e  a906              ADD      r1,sp,#0x18
000030  f04f4080          MOV      r0,#0x40000000
000034  f7fffffe          BL       TIM_TimeBaseInit
;;;284      /* TIM2 channel2 configuration in PWM mode */
;;;285      TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; 
000038  2060              MOVS     r0,#0x60
00003a  f8ad0004          STRH     r0,[sp,#4]
;;;286      TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;                
00003e  2001              MOVS     r0,#1
000040  f8ad0006          STRH     r0,[sp,#6]
;;;287      TIM_OCInitStructure.TIM_Pulse = 10/2 ;
000044  2005              MOVS     r0,#5
000046  9003              STR      r0,[sp,#0xc]
;;;288      TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;         
000048  2002              MOVS     r0,#2
00004a  f8ad0010          STRH     r0,[sp,#0x10]
;;;289      TIM_OC2Init(TIM2, &TIM_OCInitStructure);
00004e  a901              ADD      r1,sp,#4
000050  0740              LSLS     r0,r0,#29
000052  f7fffffe          BL       TIM_OC2Init
;;;290    
;;;291    
;;;292    //	/* TIM2 counter enable */
;;;293      TIM_CtrlPWMOutputs(TIM2, ENABLE);  
000056  2101              MOVS     r1,#1
000058  0788              LSLS     r0,r1,#30
00005a  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;294    
;;;295    	// 使能从定时器Timer2
;;;296      TIM_Cmd(TIM2, ENABLE);
00005e  2101              MOVS     r1,#1
000060  0788              LSLS     r0,r1,#30
000062  f7fffffe          BL       TIM_Cmd
;;;297    	
;;;298    }
000066  b009              ADD      sp,sp,#0x24
000068  bd00              POP      {pc}
;;;299    
                          ENDP


                          AREA ||i.arm_iir_f32_Lp||, CODE, READONLY, ALIGN=2

                  arm_iir_f32_Lp PROC
;;;231    */
;;;232    static void arm_iir_f32_Lp(float32_t fInputData[], float32_t fOutputData[], uint32_t u32Len)
000000  b570              PUSH     {r4-r6,lr}
;;;233    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;234    	static uint8_t u8Flag = 0;
;;;235    	uint32_t i;
;;;236    	static arm_biquad_casd_df1_inst_f32 S;
;;;237    	volatile float32_t f32Tmp;
;;;238    
;;;239    	if( u8Flag == 0 )
000008  4809              LDR      r0,|L4.48|
00000a  7800              LDRB     r0,[r0,#0]  ; u8Flag
00000c  b940              CBNZ     r0,|L4.32|
;;;240    	{
;;;241    			u8Flag = 1;
00000e  2001              MOVS     r0,#1
000010  4907              LDR      r1,|L4.48|
000012  7008              STRB     r0,[r1,#0]
;;;242    			/* 初始化 */
;;;243    			arm_biquad_cascade_df1_init_f32(&S, numStages, (float32_t *)&IIRCoeffs32BP[0], (float32_t *)&IIRStateF32[0]);
000014  4b07              LDR      r3,|L4.52|
000016  4a08              LDR      r2,|L4.56|
000018  2106              MOVS     r1,#6
00001a  4808              LDR      r0,|L4.60|
00001c  f7fffffe          BL       arm_biquad_cascade_df1_init_f32
                  |L4.32|
;;;244    	}
;;;245    	
;;;246    	/* IIR滤波 */
;;;247     	arm_biquad_cascade_df1_f32(&S, fInputData, fOutputData, u32Len);
000020  4633              MOV      r3,r6
000022  462a              MOV      r2,r5
000024  4621              MOV      r1,r4
000026  4805              LDR      r0,|L4.60|
000028  f7fffffe          BL       arm_biquad_cascade_df1_f32
;;;248    	    
;;;249    }
00002c  bd70              POP      {r4-r6,pc}
;;;250    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      |symbol_number.29|
                  |L4.52|
                          DCD      IIRStateF32
                  |L4.56|
                          DCD      IIRCoeffs32BP
                  |L4.60|
                          DCD      |symbol_number.27|

                          AREA ||i.arm_iir_f32_bp||, CODE, READONLY, ALIGN=2

                  arm_iir_f32_bp PROC
;;;173    */
;;;174    static void arm_iir_f32_bp(void)
000000  b510              PUSH     {r4,lr}
;;;175    {
;;;176    	static uint8_t u8Flag = 0;
;;;177    	uint32_t i;
;;;178    	static arm_biquad_casd_df1_inst_f32 S;
;;;179    	volatile float32_t f32Tmp;
;;;180    
;;;181    	if( u8Flag == 0 )
000002  4809              LDR      r0,|L5.40|
000004  7800              LDRB     r0,[r0,#0]  ; u8Flag
000006  b940              CBNZ     r0,|L5.26|
;;;182    	{
;;;183    			u8Flag = 1;
000008  2001              MOVS     r0,#1
00000a  4907              LDR      r1,|L5.40|
00000c  7008              STRB     r0,[r1,#0]
;;;184    			/* 初始化 */
;;;185    			arm_biquad_cascade_df1_init_f32(&S, numStages, (float32_t *)&IIRCoeffs32BP[0], (float32_t *)&IIRStateF32[0]);
00000e  4b07              LDR      r3,|L5.44|
000010  4a07              LDR      r2,|L5.48|
000012  2106              MOVS     r1,#6
000014  4807              LDR      r0,|L5.52|
000016  f7fffffe          BL       arm_biquad_cascade_df1_init_f32
                  |L5.26|
;;;186    	}
;;;187    	
;;;188    	/* IIR滤波 */
;;;189     	arm_biquad_cascade_df1_f32(&S, testInput_f32_50Hz_200Hz, testOutput, TEST_LENGTH_SAMPLES);
00001a  2320              MOVS     r3,#0x20
00001c  4a06              LDR      r2,|L5.56|
00001e  4907              LDR      r1,|L5.60|
000020  4804              LDR      r0,|L5.52|
000022  f7fffffe          BL       arm_biquad_cascade_df1_f32
;;;190    	    
;;;191    	/*放缩系数 */    
;;;192    //	ScaleValue = 	0.034907330466672125*
;;;193    //								0.034907330466672125*                                        
;;;194    //								0.034479329045770668*                                        
;;;195    //								0.034479329045770668*                                        
;;;196    //								0.034162181085070645*                                        
;;;197    //								0.034162181085070645*                                        
;;;198    //								0.03399415063903985*                                         
;;;199    //								0.03399415063903985;  
;;;200    	
;;;201    //	ScaleValue = 	0.31282462151819557f*                                         
;;;202    //								0.31282462151819557f*                                         
;;;203    //								0.28546239546776436f*                                         
;;;204    //								0.28546239546776436f*                                         
;;;205    //								0.2687742215913746f*                                          
;;;206    //								0.2687742215913746f*                                          
;;;207    //								0.26088103084165865f*                                         
;;;208    //								0.26088103084165865;
;;;209    //	__disable_irq();
;;;210    	/* 打印滤波后结果 */
;;;211    //	for(i=0; i<TEST_LENGTH_SAMPLES; i++)
;;;212    //	{
;;;213    ////		printf("%f\r\n", testOutput[i]*ScaleValue);
;;;214    //			f32Tmp = testOutput[i]*ScaleValue + 0.0f;
;;;215    //			u16Probe1 = f32Tmp;
;;;216    ////			printf("%d\r\n", u16Probe1);
;;;217    ////			bsp_DelayUS(10);
;;;218    //	}
;;;219    //	__enable_irq();
;;;220    }
000026  bd10              POP      {r4,pc}
;;;221    
                          ENDP

                  |L5.40|
                          DCD      u8Flag
                  |L5.44|
                          DCD      IIRStateF32
                  |L5.48|
                          DCD      IIRCoeffs32BP
                  |L5.52|
                          DCD      S
                  |L5.56|
                          DCD      testOutput
                  |L5.60|
                          DCD      testInput_f32_50Hz_200Hz

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;647    */
;;;648    int main(void)
000000  ed2d8b02          VPUSH    {d8}
;;;649    {
;;;650    	uint8_t ucKeyCode;		/* 按键代码 */
;;;651    	static uint32_t si = 0,su32Pointer = 0;
;;;652    	uint32_t u32Sum = 0, i,  u32Index = 0, u32Len = 0;
000004  bf00              NOP      
000006  bf00              NOP      
000008  bf00              NOP      
;;;653    	
;;;654    //	u16DecodeOutBuf[8000] = 4000;
;;;655    //	u16DecodeOutBuf[8001] = 4000;
;;;656    //	u16DecodeOutBuf[8002] = (u16DecodeOutBuf[8000] * u16DecodeOutBuf[8001]) >> 12;
;;;657    	
;;;658    	bsp_Init();		/* 硬件初始化 */
00000a  f7fffffe          BL       bsp_Init
;;;659    //	PrintfLogo();	/* 打印例程信息到串口1 */
;;;660    
;;;661    	bsp_StartAutoTimer(0, 500);	/* 启动1个500ms的自动重装的定时器 */
00000e  f44f71fa          MOV      r1,#0x1f4
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       bsp_StartAutoTimer
;;;662    
;;;663    //	DualTimer_Init();
;;;664    	Timer2_ADC_T2CC__Init();
000018  f7fffffe          BL       Timer2_ADC_T2CC__Init
;;;665    	
;;;666    	ADC_Config(8000);
00001c  f44f50fa          MOV      r0,#0x1f40
000020  f7fffffe          BL       ADC_Config
;;;667    //	ADC_Config(256);
;;;668    	
;;;669    //	SEGGER_RTT_Init();
;;;670    //	SEGGER_RTT_printf(0,"Hello!\r\n",8);
;;;671    	
;;;672    	printf("Hello!\r\n");
000024  a0ac              ADR      r0,|L6.728|
000026  f7fffffe          BL       __2printf
;;;673    	
;;;674    //	SPI1_Init();
;;;675    //  DMA2_Config();
;;;676    //  TIM1_Init(240);
;;;677    	
;;;678    //	SPI2_Init();
;;;679    //  DMA1_Config();
;;;680    //  TIM2_Init(240);
;;;681    
;;;682    	// Phase 0
;;;683    	for( i = 0; i < 160; i++)
00002a  2400              MOVS     r4,#0
00002c  e022              B        |L6.116|
                  |L6.46|
;;;684    	{
;;;685    //		aSRC_0[i] = 2000*(arm_sin_f32(i*2*(float)3.1415926545/(float)40.) + (float)1.); 
;;;686    		aSRC_0[i] = 2000*(arm_sin_f32(i*2*(float)3.1415926545/(float)10.) + (float)1.); 
00002e  0060              LSLS     r0,r4,#1
000030  ee000a10          VMOV     s0,r0
000034  eeb80a40          VCVT.F32.U32 s0,s0
000038  eddf0aaa          VLDR     s1,|L6.740|
00003c  ee200a20          VMUL.F32 s0,s0,s1
000040  eef20a04          VMOV.F32 s1,#10.00000000
000044  ee801a20          VDIV.F32 s2,s0,s1
000048  eeb08a41          VMOV.F32 s16,s2
00004c  eeb00a48          VMOV.F32 s0,s16
000050  f7fffffe          BL       arm_sin_f32
000054  eef70a00          VMOV.F32 s1,#1.00000000
000058  ee300a20          VADD.F32 s0,s0,s1
00005c  eddf0aa2          VLDR     s1,|L6.744|
000060  ee200a20          VMUL.F32 s0,s0,s1
000064  eebc0ac0          VCVT.U32.F32 s0,s0
000068  ee100a10          VMOV     r0,s0
00006c  499f              LDR      r1,|L6.748|
00006e  f8210014          STRH     r0,[r1,r4,LSL #1]
000072  1c64              ADDS     r4,r4,#1              ;683
                  |L6.116|
000074  2ca0              CMP      r4,#0xa0              ;683
000076  d3da              BCC      |L6.46|
;;;687    	}
;;;688    	// Phase Pi
;;;689    	for( i = 0; i < 160; i++)
000078  2400              MOVS     r4,#0
00007a  e024              B        |L6.198|
                  |L6.124|
;;;690    	{
;;;691    //		aSRC_Pi[i] = 2000*(-arm_sin_f32(i*2*(float)3.1415926545/(float)40.) + (float)1.); 
;;;692    		aSRC_Pi[i] = 2000*(-arm_sin_f32(i*2*(float)3.1415926545/(float)10.) + (float)1.); 
00007c  0060              LSLS     r0,r4,#1
00007e  ee000a10          VMOV     s0,r0
000082  eeb80a40          VCVT.F32.U32 s0,s0
000086  eddf0a97          VLDR     s1,|L6.740|
00008a  ee200a20          VMUL.F32 s0,s0,s1
00008e  eef20a04          VMOV.F32 s1,#10.00000000
000092  ee801a20          VDIV.F32 s2,s0,s1
000096  eeb08a41          VMOV.F32 s16,s2
00009a  eeb00a48          VMOV.F32 s0,s16
00009e  f7fffffe          BL       arm_sin_f32
0000a2  eeb10a40          VNEG.F32 s0,s0
0000a6  eef70a00          VMOV.F32 s1,#1.00000000
0000aa  ee300a20          VADD.F32 s0,s0,s1
0000ae  eddf0a8e          VLDR     s1,|L6.744|
0000b2  ee200a20          VMUL.F32 s0,s0,s1
0000b6  eebc0ac0          VCVT.U32.F32 s0,s0
0000ba  ee100a10          VMOV     r0,s0
0000be  498c              LDR      r1,|L6.752|
0000c0  f8210014          STRH     r0,[r1,r4,LSL #1]
0000c4  1c64              ADDS     r4,r4,#1              ;689
                  |L6.198|
0000c6  2ca0              CMP      r4,#0xa0              ;689
0000c8  d3d8              BCC      |L6.124|
;;;693    	}
;;;694    
;;;695    //	for( i = 0; i < 160; i++)
;;;696    //	{
;;;697    //		aSRC_Buffer[i] = aSRC_0[i]; 
;;;698    //	}
;;;699    //	for( i = 0; i < 160; i++)
;;;700    //	{
;;;701    //		aSRC_Buffer[160 + i] = aSRC_Pi[i]; 
;;;702    //	}
;;;703    	
;;;704    	SendOneFrameDPSK(0x00ff7456);
0000ca  488a              LDR      r0,|L6.756|
0000cc  f7fffffe          BL       SendOneFrameDPSK
;;;705    	
;;;706    	DAC_Ch1_SineWaveConfig(aSRC_Buffer, 4000);
0000d0  f44f617a          MOV      r1,#0xfa0
0000d4  4888              LDR      r0,|L6.760|
0000d6  f7fffffe          BL       DAC_Ch1_SineWaveConfig
;;;707    //	DAC_Ch1_SineWaveConfig(aSRC_Buffer, 320);
;;;708    	DAC_Ch2_SineWaveConfig((uint16_t *)u16DecodeOutBuf, 8000);
0000da  f44f51fa          MOV      r1,#0x1f40
0000de  4887              LDR      r0,|L6.764|
0000e0  f7fffffe          BL       DAC_Ch2_SineWaveConfig
;;;709    	
;;;710    	fSpecN4_real = 0;
0000e4  ed9f0a86          VLDR     s0,|L6.768|
0000e8  4886              LDR      r0,|L6.772|
0000ea  ed800a00          VSTR     s0,[r0,#0]
;;;711    	fSpecN4_imaginal = 0;
0000ee  ed9f0a84          VLDR     s0,|L6.768|
0000f2  4885              LDR      r0,|L6.776|
0000f4  ed800a00          VSTR     s0,[r0,#0]
;;;712    	/* 进入主程序循环体 */
;;;713    	while (1)
0000f8  e0ec              B        |L6.724|
                  |L6.250|
;;;714    	{
;;;715    		if(u8ADC_Halffull == 1)
0000fa  4884              LDR      r0,|L6.780|
0000fc  7800              LDRB     r0,[r0,#0]  ; u8ADC_Halffull
0000fe  2801              CMP      r0,#1
000100  d152              BNE      |L6.424|
;;;716    		{
;;;717    				// 半满
;;;718    				u32Tmp = 4000 - 160;
000102  f44f6070          MOV      r0,#0xf00
000106  4982              LDR      r1,|L6.784|
000108  6008              STR      r0,[r1,#0]  ; u32Tmp
;;;719    				
;;;720    				// For test
;;;721    //				for( i = 0; i < 4000; i++ )
;;;722    //				{
;;;723    //						 u16WorkingBuf[i] = uhADCxConvertedValue[i];
;;;724    //				}			
;;;725    				//
;;;726    			
;;;727    				// 从ADC获取4000个，即可能25bit的数据
;;;728    				for( i = 0; i < 160; i++ )
00010a  2400              MOVS     r4,#0
00010c  e025              B        |L6.346|
                  |L6.270|
;;;729    				{
;;;730    						 u16WorkingBuf[i] = ((int32_t)(uhADCxConvertedValue[i] - 2047) * (int32_t)(u16WorkingBuf[8000 + i] - 2047)) / 4096 + 2047;
00010e  4981              LDR      r1,|L6.788|
000110  f8311014          LDRH     r1,[r1,r4,LSL #1]
000114  f2a171ff          SUB      r1,r1,#0x7ff
000118  f50452fa          ADD      r2,r4,#0x1f40
00011c  4b7e              LDR      r3,|L6.792|
00011e  eb030282          ADD      r2,r3,r2,LSL #2
000122  ed920a00          VLDR     s0,[r2,#0]
000126  eddf0a7d          VLDR     s1,|L6.796|
00012a  ee300a60          VSUB.F32 s0,s0,s1
00012e  eebd0ac0          VCVT.S32.F32 s0,s0
000132  ee102a10          VMOV     r2,s0
000136  fb01f002          MUL      r0,r1,r2
00013a  17c1              ASRS     r1,r0,#31
00013c  eb005111          ADD      r1,r0,r1,LSR #20
000140  1309              ASRS     r1,r1,#12
000142  f20171ff          ADD      r1,r1,#0x7ff
000146  ee001a10          VMOV     s0,r1
00014a  eeb80ac0          VCVT.F32.S32 s0,s0
00014e  4619              MOV      r1,r3
000150  eb010184          ADD      r1,r1,r4,LSL #2
000154  ed810a00          VSTR     s0,[r1,#0]
000158  1c64              ADDS     r4,r4,#1              ;728
                  |L6.346|
00015a  2ca0              CMP      r4,#0xa0              ;728
00015c  d3d7              BCC      |L6.270|
;;;731    				}
;;;732    				for( i = 0; i < 4000 - 160; i++ )
00015e  2400              MOVS     r4,#0
000160  e01e              B        |L6.416|
                  |L6.354|
;;;733    				{
;;;734    						 u16WorkingBuf[160 + i] = ((int32_t)(uhADCxConvertedValue[160 + i] - 2047) * (int32_t)(uhADCxConvertedValue[i] - 2047)) / 4096 + 2047;
000162  f10401a0          ADD      r1,r4,#0xa0
000166  4a6b              LDR      r2,|L6.788|
000168  f8321011          LDRH     r1,[r2,r1,LSL #1]
00016c  f2a171ff          SUB      r1,r1,#0x7ff
000170  f8322014          LDRH     r2,[r2,r4,LSL #1]
000174  f2a272ff          SUB      r2,r2,#0x7ff
000178  fb01f002          MUL      r0,r1,r2
00017c  17c1              ASRS     r1,r0,#31
00017e  eb005111          ADD      r1,r0,r1,LSR #20
000182  1309              ASRS     r1,r1,#12
000184  f20171ff          ADD      r1,r1,#0x7ff
000188  ee001a10          VMOV     s0,r1
00018c  eeb80ac0          VCVT.F32.S32 s0,s0
000190  f10401a0          ADD      r1,r4,#0xa0
000194  4a60              LDR      r2,|L6.792|
000196  eb020181          ADD      r1,r2,r1,LSL #2
00019a  ed810a00          VSTR     s0,[r1,#0]
00019e  1c64              ADDS     r4,r4,#1              ;732
                  |L6.416|
0001a0  f5b46f70          CMP      r4,#0xf00             ;732
0001a4  d3dd              BCC      |L6.354|
0001a6  e041              B        |L6.556|
                  |L6.424|
;;;735    				}
;;;736    				
;;;737    		}
;;;738    		else if(u8ADC_Halffull == 2)
0001a8  4858              LDR      r0,|L6.780|
0001aa  7800              LDRB     r0,[r0,#0]  ; u8ADC_Halffull
0001ac  2802              CMP      r0,#2
0001ae  d13d              BNE      |L6.556|
;;;739    		{
;;;740    				// 全满
;;;741    				u32Tmp = 8000;
0001b0  f44f50fa          MOV      r0,#0x1f40
0001b4  4956              LDR      r1,|L6.784|
0001b6  6008              STR      r0,[r1,#0]  ; u32Tmp
;;;742    				
;;;743    				// For test
;;;744    //				for( i = 4000; i < 8000; i++ )
;;;745    //				{
;;;746    //						 u16WorkingBuf[i] = uhADCxConvertedValue[i];
;;;747    //				}			
;;;748    				//
;;;749    				
;;;750    				for( i = 4000 - 160; i < 8000 - 160; i++ )
0001b8  f44f6470          MOV      r4,#0xf00
0001bc  e01e              B        |L6.508|
                  |L6.446|
;;;751    				{
;;;752    						 u16WorkingBuf[160 + i] = ((int32_t)(uhADCxConvertedValue[160 + i] - 2047 ) * (int32_t)(uhADCxConvertedValue[i] - 2047)) / 4096 + 2047;
0001be  f10401a0          ADD      r1,r4,#0xa0
0001c2  4a54              LDR      r2,|L6.788|
0001c4  f8321011          LDRH     r1,[r2,r1,LSL #1]
0001c8  f2a171ff          SUB      r1,r1,#0x7ff
0001cc  f8322014          LDRH     r2,[r2,r4,LSL #1]
0001d0  f2a272ff          SUB      r2,r2,#0x7ff
0001d4  fb01f002          MUL      r0,r1,r2
0001d8  17c1              ASRS     r1,r0,#31
0001da  eb005111          ADD      r1,r0,r1,LSR #20
0001de  1309              ASRS     r1,r1,#12
0001e0  f20171ff          ADD      r1,r1,#0x7ff
0001e4  ee001a10          VMOV     s0,r1
0001e8  eeb80ac0          VCVT.F32.S32 s0,s0
0001ec  f10401a0          ADD      r1,r4,#0xa0
0001f0  4a49              LDR      r2,|L6.792|
0001f2  eb020181          ADD      r1,r2,r1,LSL #2
0001f6  ed810a00          VSTR     s0,[r1,#0]
0001fa  1c64              ADDS     r4,r4,#1              ;750
                  |L6.508|
0001fc  f5b45ff5          CMP      r4,#0x1ea0            ;750
000200  d3dd              BCC      |L6.446|
;;;753    				}
;;;754    				for( i = 0; i < 160; i++ )
000202  2400              MOVS     r4,#0
000204  e010              B        |L6.552|
                  |L6.518|
;;;755    				{
;;;756    						 u16WorkingBuf[8000 + i] = uhADCxConvertedValue[8000 - 160 + i];
000206  f50450f5          ADD      r0,r4,#0x1ea0
00020a  4942              LDR      r1,|L6.788|
00020c  f8310010          LDRH     r0,[r1,r0,LSL #1]
000210  ee000a10          VMOV     s0,r0
000214  eeb80a40          VCVT.F32.U32 s0,s0
000218  f50450fa          ADD      r0,r4,#0x1f40
00021c  493e              LDR      r1,|L6.792|
00021e  eb010080          ADD      r0,r1,r0,LSL #2
000222  ed800a00          VSTR     s0,[r0,#0]
000226  1c64              ADDS     r4,r4,#1              ;754
                  |L6.552|
000228  2ca0              CMP      r4,#0xa0              ;754
00022a  d3ec              BCC      |L6.518|
                  |L6.556|
;;;757    				}
;;;758    		}
;;;759    
;;;760    		
;;;761    		if(u8DAC2_Halffull == 1)
00022c  483c              LDR      r0,|L6.800|
00022e  7800              LDRB     r0,[r0,#0]  ; u8DAC2_Halffull
000230  2801              CMP      r0,#1
000232  d124              BNE      |L6.638|
;;;762    		{
;;;763    				// 半满
;;;764    				
;;;765    				arm_iir_f32_Lp((float_t *)u16WorkingBuf, (float_t *)fLpFilterBuf, 4000); 
000234  f44f627a          MOV      r2,#0xfa0
000238  493a              LDR      r1,|L6.804|
00023a  4837              LDR      r0,|L6.792|
00023c  f7fffffe          BL       arm_iir_f32_Lp
;;;766    				
;;;767    				for( i = 0; i < 4000; i++ )
000240  2400              MOVS     r4,#0
000242  e011              B        |L6.616|
                  |L6.580|
;;;768    				{
;;;769    						
;;;770    //						u16DecodeOutBuf[i] = u16WorkingBuf[i];
;;;771    						u16DecodeOutBuf[i] = (uint16_t)(fLpFilterBuf[i]*ScaleValue);
000244  4837              LDR      r0,|L6.804|
000246  eb000084          ADD      r0,r0,r4,LSL #2
00024a  ed900a00          VLDR     s0,[r0,#0]
00024e  4836              LDR      r0,|L6.808|
000250  edd00a00          VLDR     s1,[r0,#0]
000254  ee200a20          VMUL.F32 s0,s0,s1
000258  eebc0ac0          VCVT.U32.F32 s0,s0
00025c  ee100a10          VMOV     r0,s0
000260  4926              LDR      r1,|L6.764|
000262  f8210014          STRH     r0,[r1,r4,LSL #1]
000266  1c64              ADDS     r4,r4,#1              ;767
                  |L6.616|
000268  f5b46f7a          CMP      r4,#0xfa0             ;767
00026c  d3ea              BCC      |L6.580|
;;;772    				}
;;;773    
;;;774    				BitSync((uint16_t *)u16DecodeOutBuf, 2000, 1, &sBitSyncStruct);
00026e  4b2f              LDR      r3,|L6.812|
000270  2201              MOVS     r2,#1
000272  f44f61fa          MOV      r1,#0x7d0
000276  4821              LDR      r0,|L6.764|
000278  f7fffffe          BL       BitSync
00027c  e02a              B        |L6.724|
                  |L6.638|
;;;775    				
;;;776    //				for( i = 0; i < 160; i++ )
;;;777    //				{
;;;778    //						 u16DecodeOutBuf[i] = (u16WorkingBuf[i] * u16DecodeOutBuf[8000 + i]) >> 12;
;;;779    //				}
;;;780    //				for( i = 0; i < 4000 - 160; i++ )
;;;781    //				{
;;;782    //						 u16DecodeOutBuf[160 + i] = ((uint32_t)u16WorkingBuf[i + 160] * (uint32_t)u16WorkingBuf[i]) >> 12;
;;;783    //				}
;;;784    				
;;;785    //				// 可能需暂存前半区的160个数据
;;;786    //				for( i = 0; i < 160; i++ )
;;;787    //				{
;;;788    //				}
;;;789    		}
;;;790    		else if(u8DAC2_Halffull == 2)
00027e  4828              LDR      r0,|L6.800|
000280  7800              LDRB     r0,[r0,#0]  ; u8DAC2_Halffull
000282  2802              CMP      r0,#2
000284  d126              BNE      |L6.724|
;;;791    		{
;;;792    				// 全满
;;;793    				
;;;794    				arm_iir_f32_Lp((float_t *)(&u16WorkingBuf[4000]), (float_t *)fLpFilterBuf, 4000); 
000286  f44f627a          MOV      r2,#0xfa0
00028a  4926              LDR      r1,|L6.804|
00028c  4828              LDR      r0,|L6.816|
00028e  f7fffffe          BL       arm_iir_f32_Lp
;;;795    				for( i = 4000; i < 8000; i++ )
000292  f44f647a          MOV      r4,#0xfa0
000296  e013              B        |L6.704|
                  |L6.664|
;;;796    				{
;;;797    //						 u16DecodeOutBuf[i] = u16WorkingBuf[i];
;;;798    						 u16DecodeOutBuf[i] = (uint16_t)(fLpFilterBuf[i - 4000]*ScaleValue);
000298  f5a4607a          SUB      r0,r4,#0xfa0
00029c  4921              LDR      r1,|L6.804|
00029e  eb010080          ADD      r0,r1,r0,LSL #2
0002a2  ed900a00          VLDR     s0,[r0,#0]
0002a6  4820              LDR      r0,|L6.808|
0002a8  edd00a00          VLDR     s1,[r0,#0]
0002ac  ee200a20          VMUL.F32 s0,s0,s1
0002b0  eebc0ac0          VCVT.U32.F32 s0,s0
0002b4  ee100a10          VMOV     r0,s0
0002b8  4910              LDR      r1,|L6.764|
0002ba  f8210014          STRH     r0,[r1,r4,LSL #1]
0002be  1c64              ADDS     r4,r4,#1              ;795
                  |L6.704|
0002c0  f5b45ffa          CMP      r4,#0x1f40            ;795
0002c4  d3e8              BCC      |L6.664|
;;;799    				}
;;;800    				
;;;801    				BitSync((uint16_t *)u16DecodeOutBuf, 2000, 2, &sBitSyncStruct);
0002c6  4b19              LDR      r3,|L6.812|
0002c8  2202              MOVS     r2,#2
0002ca  f44f61fa          MOV      r1,#0x7d0
0002ce  480b              LDR      r0,|L6.764|
0002d0  f7fffffe          BL       BitSync
                  |L6.724|
0002d4  e711              B        |L6.250|
;;;802    				
;;;803    //				for( i = 4000 - 160; i < 8000 - 160; i++ )
;;;804    //				{
;;;805    //						 u16DecodeOutBuf[i] = ((uint32_t)u16WorkingBuf[i + 160] * (uint32_t)u16WorkingBuf[i]) >> 12;
;;;806    //				}
;;;807    //				for( i = 0; i < 160; i++ )
;;;808    //				{
;;;809    //						 u16DecodeOutBuf[8000 + i] = u16WorkingBuf[8000 - 160 + i];
;;;810    //				}
;;;811    		}
;;;812    		
;;;813    //		if(RingBufUsed((tRingBufObject *)&sADC_RingBuf))
;;;814    		if(0)
;;;815    		{
;;;816    				u16Probe = RingBufU16ReadOne(&sADC_RingBuf);
;;;817    			  fWorkingBuf[su32Pointer] = (float)u16Probe;
;;;818    
;;;819    				fSpecN4_real = 0;
;;;820    				fSpecN4_imaginal = 0;
;;;821    			
;;;822    				u32Len = (su32Pointer + 1) % 160;
;;;823    				for( i = 0; i < u32Len; i++)
;;;824    				{
;;;825    						fSpecN4_real += (arm_cos_f32(4*(160 - u32Len + i)*2*(float)3.1415926545/(float)160.)*fWorkingBuf[(i)]); 
;;;826    				}
;;;827    			
;;;828    				for( i = 0; i < (160 - u32Len); i++)
;;;829    				{
;;;830    						fSpecN4_real += (arm_cos_f32(4*(i)*2*(float)3.1415926545/(float)160.)*fWorkingBuf[(i)]); 
;;;831    				}
;;;832    				
;;;833    				u32Len = (su32Pointer + 1) % 160;
;;;834    				for( i = 0; i < u32Len; i++)
;;;835    				{
;;;836    						fSpecN4_imaginal += (-arm_sin_f32(4*(160 - u32Len + i)*2*(float)3.1415926545/(float)160.)*fWorkingBuf[(i)]); 
;;;837    				}
;;;838    			
;;;839    				for( i = u32Len; i < (160 - u32Len); i++)
;;;840    				{
;;;841    						fSpecN4_imaginal += (-arm_sin_f32(4*(i)*2*(float)3.1415926545/(float)160.)*fWorkingBuf[(i)]); 
;;;842    				}
;;;843    
;;;844    				fPower = fSpecN4_imaginal*fSpecN4_imaginal + fSpecN4_real*fSpecN4_real;
;;;845    				su32Pointer++;
;;;846    				if(su32Pointer > 159)
;;;847    				{
;;;848    					 su32Pointer = 0;
;;;849    				}
;;;850    
;;;851    		}
;;;852    		
;;;853    		if(0)
;;;854    //		if (DMA2->LISR & DMA_IT_TCIF0)	
;;;855    		{
;;;856    				DMA2->LIFCR = (DMA_IT_TCIF0 & 0x0ffffff0);						// 清除通道5传输完成标志			
;;;857    				u32Sum = 0;
;;;858    				for( i = 0; i < 256; i++)
;;;859    				{
;;;860    					u32Sum += uhADCxConvertedValue[i];
;;;861    				}
;;;862    				u16Probe2 = u32Sum / 16;
;;;863    
;;;864    				testInput_f32_50Hz_200Hz[si] = u16Probe2+0.0f;
;;;865    				u16Probe = testInput_f32_50Hz_200Hz[si] + 0.0f;
;;;866    
;;;867    				u16Probe1 = testOutput[si]*ScaleValue + 0.0f;
;;;868    				si++;
;;;869    
;;;870    				if(si >= TEST_LENGTH_SAMPLES )
;;;871    				{
;;;872    						si = 0;
;;;873    						arm_iir_f32_bp();
;;;874    				}
;;;875    
;;;876    //				printf("%d\r\n", u16Probe2);
;;;877    		}
;;;878    		
;;;879    		
;;;880    		//	for(i=0; i<TEST_LENGTH_SAMPLES; i++)
;;;881    //		{
;;;882    //			/* 50Hz正弦波+200Hz正弦波，采样率1KHz */
;;;883    //			testInput_f32_50Hz_200Hz[si] = 10000.0f*arm_sin_f32(2*3.1415926f*1*su32Pointer++/200) + 1000.0f*arm_sin_f32(2*3.1415926f*50*su32Pointer++/200)+0.0f;
;;;884    //			u16Probe = testInput_f32_50Hz_200Hz[si] * 1.0f + 20000.0f;
;;;885    //			bsp_DelayMS(5);
;;;886    //		}
;;;887    		
;;;888    //		continue;
;;;889    		
;;;890    		{
;;;891    			/* 50Hz正弦波+200Hz正弦波，采样率1KHz */
;;;892    	//		delay_ms(5);
;;;893    		}
;;;894    		
;;;895    
;;;896    
;;;897    	}
;;;898    }
;;;899    
                          ENDP

0002d6  0000              DCW      0x0000
                  |L6.728|
0002d8  48656c6c          DCB      "Hello!\r\n",0
0002dc  6f210d0a
0002e0  00      
0002e1  00                DCB      0
0002e2  00                DCB      0
0002e3  00                DCB      0
                  |L6.740|
0002e4  40490fdb          DCFS     0x40490fdb ; 3.1415927410125732
                  |L6.744|
0002e8  44fa0000          DCFS     0x44fa0000 ; 2000
                  |L6.748|
                          DCD      aSRC_0
                  |L6.752|
                          DCD      aSRC_Pi
                  |L6.756|
                          DCD      0x00ff7456
                  |L6.760|
                          DCD      aSRC_Buffer
                  |L6.764|
                          DCD      u16DecodeOutBuf
                  |L6.768|
000300  00000000          DCFS     0x00000000 ; 0
                  |L6.772|
                          DCD      fSpecN4_real
                  |L6.776|
                          DCD      fSpecN4_imaginal
                  |L6.780|
                          DCD      u8ADC_Halffull
                  |L6.784|
                          DCD      u32Tmp
                  |L6.788|
                          DCD      uhADCxConvertedValue
                  |L6.792|
                          DCD      u16WorkingBuf
                  |L6.796|
00031c  44ffe000          DCFS     0x44ffe000 ; 2047
                  |L6.800|
                          DCD      u8DAC2_Halffull
                  |L6.804|
                          DCD      fLpFilterBuf
                  |L6.808|
                          DCD      ScaleValue
                  |L6.812|
                          DCD      sBitSyncStruct
                  |L6.816|
                          DCD      u16WorkingBuf+0x3e80

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  testInput_f32_50Hz_200Hz
                          %        128
                  testOutput
                          %        128
                  IIRStateF32
                          %        96
                  fWorkingBuf
                          %        640
                  fCosineKtable
                          %        640
                  u16WorkingBuf
                          %        32768
                  u16DecodeOutBuf
                          %        16384
                  fLpFilterBuf
                          %        16000
                  sBitSyncStruct
                          %        20
                  u8BitPool
                          %        256
                  S
                          %        12
                  |symbol_number.27|
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  IIRCoeffs32BP
000000  3f800000          DCFS     0x3f800000 ; 1
000004  40000000          DCFS     0x40000000 ; 2
000008  3f800000          DCFS     0x3f800000 ; 1
00000c  3ffa95b2          DCFS     0x3ffa95b2 ; 1.957693338394165
000010  bf782d09          DCFS     0xbf782d09 ; -0.96943718194961548
000014  3f800000          DCFS     0x3f800000 ; 1
000018  40000000          DCFS     0x40000000 ; 2
00001c  3f800000          DCFS     0x3f800000 ; 1
000020  3ff3721c          DCFS     0x3ff3721c ; 1.9019198417663574
000024  bf69cff0          DCFS     0xbf69cff0 ; -0.91332912445068359
000028  3f800000          DCFS     0x3f800000 ; 1
00002c  40000000          DCFS     0x40000000 ; 2
000030  3f800000          DCFS     0x3f800000 ; 1
000034  3fed8354          DCFS     0x3fed8354 ; 1.8555703163146973
000038  bf5de027          DCFS     0xbf5de027 ; -0.86670154333114624
00003c  3f800000          DCFS     0x3f800000 ; 1
000040  40000000          DCFS     0x40000000 ; 2
000044  3f800000          DCFS     0x3f800000 ; 1
000048  3fe91758          DCFS     0x3fe91758 ; 1.8210248947143555
00004c  bf54fa9a          DCFS     0xbf54fa9a ; -0.83194887638092041
000050  3f800000          DCFS     0x3f800000 ; 1
000054  40000000          DCFS     0x40000000 ; 2
000058  3f800000          DCFS     0x3f800000 ; 1
00005c  3fe65edb          DCFS     0x3fe65edb ; 1.7997697591781616
000060  bf4f8145          DCFS     0xbf4f8145 ; -0.810566246509552
000064  3f800000          DCFS     0x3f800000 ; 1
000068  3f800000          DCFS     0x3f800000 ; 1
00006c  00000000          DCFS     0x00000000 ; 0
000070  3f6573f9          DCFS     0x3f6573f9 ; 0.89630085229873657
000074  80000000          DCFS     0x80000000 ; -0
                  u8OneRun
000078  00010307          DCB      0x00,0x01,0x03,0x07
00007c  0f1f3f7f          DCB      0x0f,0x1f,0x3f,0x7f

                          AREA ||.data||, DATA, ALIGN=2

                  u16Probe
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  u16Probe1
                          DCD      0x00000000
                  u16Probe2
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  ScaleValue
00000c  282073bf          DCFS     0x282073bf ; 8.9068826302613445e-15
                  fSpecN4_real
                          DCD      0x00000000
                  fSpecN4_imaginal
                          DCD      0x00000000
                  fPower
                          DCD      0x00000000
                  u32Tmp
                          DCD      0x00000000
                  u8Flag
000020  00                DCB      0x00
                  |symbol_number.29|
000021  000000            DCB      0x00,0x00,0x00
                  ||si||
                          DCD      0x00000000
                  su32Pointer
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_32c47d09____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_32c47d09____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_32c47d09____REVSH|
#line 144
|__asm___6_main_c_32c47d09____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_32c47d09____RRX|
#line 300
|__asm___6_main_c_32c47d09____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
