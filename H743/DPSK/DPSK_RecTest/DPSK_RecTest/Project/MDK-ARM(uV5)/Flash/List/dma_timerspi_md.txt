; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\dma_timerspi_md.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\dma_timerspi_md.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\MiddleWareDrv -I..\..\User\RTT -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 --omf_browse=.\flash\obj\dma_timerspi_md.crf ..\..\User\MiddleWareDrv\DMA_TimerSPI_MD.c]
                          THUMB

                          AREA ||i.DMA1_Config||, CODE, READONLY, ALIGN=2

                  DMA1_Config PROC
;;;84     
;;;85     void DMA1_Config(void)
000000  b500              PUSH     {lr}
;;;86     {
000002  b08f              SUB      sp,sp,#0x3c
;;;87          DMA_InitTypeDef DMA_InitStructure;
;;;88          
;;;89          RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
000004  2101              MOVS     r1,#1
000006  0548              LSLS     r0,r1,#21
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;90     
;;;91          /* DMA disable*/
;;;92          DMA_Cmd(DMA1_Stream5, DISABLE);
00000c  2100              MOVS     r1,#0
00000e  482f              LDR      r0,|L1.204|
000010  f7fffffe          BL       DMA_Cmd
;;;93          DMA_Cmd(DMA1_Stream6, DISABLE);
000014  2100              MOVS     r1,#0
000016  482d              LDR      r0,|L1.204|
000018  3018              ADDS     r0,r0,#0x18
00001a  f7fffffe          BL       DMA_Cmd
;;;94          
;;;95          DMA_DeInit(DMA1_Stream5);
00001e  482b              LDR      r0,|L1.204|
000020  f7fffffe          BL       DMA_DeInit
;;;96          DMA_DeInit(DMA1_Stream6);
000024  4829              LDR      r0,|L1.204|
000026  3018              ADDS     r0,r0,#0x18
000028  f7fffffe          BL       DMA_DeInit
;;;97           
;;;98          //   SPI1 RX DMA 配置  Stream2 
;;;99          DMA_InitStructure.DMA_Channel = DMA_Channel_3;
00002c  f04f60c0          MOV      r0,#0x6000000
000030  9000              STR      r0,[sp,#0]
;;;100         DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&SPI2->DR;         //指定DMA的外设基地址为SPI1的数据地址
000032  4827              LDR      r0,|L1.208|
000034  9001              STR      r0,[sp,#4]
;;;101         DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)SPI1_Rx_Buff;         //指定DMA的内存基地址
000036  4827              LDR      r0,|L1.212|
000038  9002              STR      r0,[sp,#8]
;;;102         DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;                 //DMA传输方向为读外设 写到内存
00003a  2000              MOVS     r0,#0
00003c  9003              STR      r0,[sp,#0xc]
;;;103         DMA_InitStructure.DMA_BufferSize = 4;//DataSize;                            //传输数量(0-65535，不能为0)
00003e  2004              MOVS     r0,#4
000040  9004              STR      r0,[sp,#0x10]
;;;104         DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;        //失能外设地址增长
000042  2000              MOVS     r0,#0
000044  9005              STR      r0,[sp,#0x14]
;;;105         DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                 //使能内存地址增长 免去FOR循环
000046  f44f6080          MOV      r0,#0x400
00004a  9006              STR      r0,[sp,#0x18]
;;;106         DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;        //PSIZE=16bit
00004c  0040              LSLS     r0,r0,#1
00004e  9007              STR      r0,[sp,#0x1c]
;;;107         DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_HalfWord;        //MSIZE=16bit
000050  9008              STR      r0,[sp,#0x20]
;;;108         DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;//DMA_Mode_Normal;//       //DMA模式为非循环模式,非循环模式只进行单次传输。
000052  10c0              ASRS     r0,r0,#3
000054  9009              STR      r0,[sp,#0x24]
;;;109         DMA_InitStructure.DMA_Priority = DMA_Priority_High;                     //优先权为高
000056  0240              LSLS     r0,r0,#9
000058  900a              STR      r0,[sp,#0x28]
;;;110         DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;                  //失能FIFO模式
00005a  2000              MOVS     r0,#0
00005c  900b              STR      r0,[sp,#0x2c]
;;;111         DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;       //FIFO的阀值为半满
00005e  2001              MOVS     r0,#1
000060  900c              STR      r0,[sp,#0x30]
;;;112         DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;                    //内存突发传输为单一
000062  2000              MOVS     r0,#0
000064  900d              STR      r0,[sp,#0x34]
;;;113         DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;     //外设突发传输为单一
000066  900e              STR      r0,[sp,#0x38]
;;;114         DMA_Init(DMA1_Stream5, &DMA_InitStructure);                             //初始化DMA2_Stream2
000068  4669              MOV      r1,sp
00006a  4818              LDR      r0,|L1.204|
00006c  f7fffffe          BL       DMA_Init
;;;115         //DMA_ITConfig(DMA2_Stream2, DMA_IT_TC, ENABLE);//使能传输完成中断 
;;;116         
;;;117         //   SPI1 TX DMA 配置   Stream3
;;;118         DMA_InitStructure.DMA_Channel = DMA_Channel_3;        
000070  f04f60c0          MOV      r0,#0x6000000
000074  9000              STR      r0,[sp,#0]
;;;119         DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&SPI2->DR;         //指定DMA的外设基地址为SPI1的数据地址
000076  4816              LDR      r0,|L1.208|
000078  9001              STR      r0,[sp,#4]
;;;120         DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)SPI1_Tx_Buff;         //指定DMA的内存基地址
00007a  4817              LDR      r0,|L1.216|
00007c  9002              STR      r0,[sp,#8]
;;;121         DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;                 //DMA传输方向为读内存，写外设
00007e  2040              MOVS     r0,#0x40
000080  9003              STR      r0,[sp,#0xc]
;;;122         DMA_InitStructure.DMA_BufferSize = 4;//DataSize;                            //传输数量(0-65535，不能为0)
000082  2004              MOVS     r0,#4
000084  9004              STR      r0,[sp,#0x10]
;;;123         DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;        //失能外设地址增长
000086  2000              MOVS     r0,#0
000088  9005              STR      r0,[sp,#0x14]
;;;124         DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                 //失能内存地址增长
00008a  f44f6080          MOV      r0,#0x400
00008e  9006              STR      r0,[sp,#0x18]
;;;125         DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;        //PSIZE=16bit
000090  0040              LSLS     r0,r0,#1
000092  9007              STR      r0,[sp,#0x1c]
;;;126         DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_HalfWord;        //MSIZE=16bit           
000094  9008              STR      r0,[sp,#0x20]
;;;127         DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;//DMA_Mode_Normal;//       //DMA模式为非循环模式,非循环模式只进行单次传输。
000096  10c0              ASRS     r0,r0,#3
000098  9009              STR      r0,[sp,#0x24]
;;;128         DMA_InitStructure.DMA_Priority = DMA_Priority_Medium ;                  //优先权为中等
00009a  0200              LSLS     r0,r0,#8
00009c  900a              STR      r0,[sp,#0x28]
;;;129         DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;                  //失能FIFO模式
00009e  2000              MOVS     r0,#0
0000a0  900b              STR      r0,[sp,#0x2c]
;;;130         DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;       //FIFO的阀值为半满
0000a2  2001              MOVS     r0,#1
0000a4  900c              STR      r0,[sp,#0x30]
;;;131         DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;                    //内存突发传输为单一
0000a6  2000              MOVS     r0,#0
0000a8  900d              STR      r0,[sp,#0x34]
;;;132         DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;     //外设突发传输为单一
0000aa  900e              STR      r0,[sp,#0x38]
;;;133         DMA_Init(DMA1_Stream6, &DMA_InitStructure);                             //初始化DMA2_Stream3
0000ac  4669              MOV      r1,sp
0000ae  4807              LDR      r0,|L1.204|
0000b0  3018              ADDS     r0,r0,#0x18
0000b2  f7fffffe          BL       DMA_Init
;;;134         //DMA_ITConfig(DMA2_Stream3, DMA_IT_TC, ENABLE);                        //因为是发送虚拟数据。不需要中断
;;;135         
;;;136         /* DMA enable*/
;;;137         DMA_Cmd(DMA1_Stream5, ENABLE);
0000b6  2101              MOVS     r1,#1
0000b8  4804              LDR      r0,|L1.204|
0000ba  f7fffffe          BL       DMA_Cmd
;;;138         DMA_Cmd(DMA1_Stream6, ENABLE);
0000be  2101              MOVS     r1,#1
0000c0  4802              LDR      r0,|L1.204|
0000c2  3018              ADDS     r0,r0,#0x18
0000c4  f7fffffe          BL       DMA_Cmd
;;;139    }
0000c8  b00f              ADD      sp,sp,#0x3c
0000ca  bd00              POP      {pc}
;;;140    
                          ENDP

                  |L1.204|
                          DCD      0x40026088
                  |L1.208|
                          DCD      0x4000380c
                  |L1.212|
                          DCD      SPI1_Rx_Buff
                  |L1.216|
                          DCD      SPI1_Tx_Buff

                          AREA ||i.DMA2_Config||, CODE, READONLY, ALIGN=2

                  DMA2_Config PROC
;;;141    
;;;142    void DMA2_Config(void)
000000  b500              PUSH     {lr}
;;;143    {
000002  b08f              SUB      sp,sp,#0x3c
;;;144         DMA_InitTypeDef DMA_InitStructure;
;;;145         
;;;146         RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
000004  2101              MOVS     r1,#1
000006  0588              LSLS     r0,r1,#22
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;147    
;;;148         /* DMA disable*/
;;;149         DMA_Cmd(DMA2_Stream2, DISABLE);
00000c  2100              MOVS     r1,#0
00000e  482f              LDR      r0,|L2.204|
000010  f7fffffe          BL       DMA_Cmd
;;;150         DMA_Cmd(DMA2_Stream3, DISABLE);
000014  2100              MOVS     r1,#0
000016  482d              LDR      r0,|L2.204|
000018  3018              ADDS     r0,r0,#0x18
00001a  f7fffffe          BL       DMA_Cmd
;;;151         
;;;152         DMA_DeInit(DMA2_Stream2);
00001e  482b              LDR      r0,|L2.204|
000020  f7fffffe          BL       DMA_DeInit
;;;153         DMA_DeInit(DMA2_Stream3);
000024  4829              LDR      r0,|L2.204|
000026  3018              ADDS     r0,r0,#0x18
000028  f7fffffe          BL       DMA_DeInit
;;;154          
;;;155         //   SPI1 RX DMA 配置  Stream2 
;;;156         DMA_InitStructure.DMA_Channel = DMA_Channel_6;
00002c  f04f6040          MOV      r0,#0xc000000
000030  9000              STR      r0,[sp,#0]
;;;157         DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&SPI1->DR;         //指定DMA的外设基地址为SPI1的数据地址
000032  4827              LDR      r0,|L2.208|
000034  9001              STR      r0,[sp,#4]
;;;158         DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)SPI1_Rx_Buff;         //指定DMA的内存基地址
000036  4827              LDR      r0,|L2.212|
000038  9002              STR      r0,[sp,#8]
;;;159         DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;                 //DMA传输方向为读外设 写到内存
00003a  2000              MOVS     r0,#0
00003c  9003              STR      r0,[sp,#0xc]
;;;160         DMA_InitStructure.DMA_BufferSize = 4;//DataSize;                            //传输数量(0-65535，不能为0)
00003e  2004              MOVS     r0,#4
000040  9004              STR      r0,[sp,#0x10]
;;;161         DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;        //失能外设地址增长
000042  2000              MOVS     r0,#0
000044  9005              STR      r0,[sp,#0x14]
;;;162         DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                 //使能内存地址增长 免去FOR循环
000046  f44f6080          MOV      r0,#0x400
00004a  9006              STR      r0,[sp,#0x18]
;;;163         DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;        //PSIZE=16bit
00004c  0040              LSLS     r0,r0,#1
00004e  9007              STR      r0,[sp,#0x1c]
;;;164         DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_HalfWord;        //MSIZE=16bit
000050  9008              STR      r0,[sp,#0x20]
;;;165         DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;//DMA_Mode_Normal;//       //DMA模式为非循环模式,非循环模式只进行单次传输。
000052  10c0              ASRS     r0,r0,#3
000054  9009              STR      r0,[sp,#0x24]
;;;166         DMA_InitStructure.DMA_Priority = DMA_Priority_High;                     //优先权为高
000056  0240              LSLS     r0,r0,#9
000058  900a              STR      r0,[sp,#0x28]
;;;167         DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;                  //失能FIFO模式
00005a  2000              MOVS     r0,#0
00005c  900b              STR      r0,[sp,#0x2c]
;;;168         DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;       //FIFO的阀值为半满
00005e  2001              MOVS     r0,#1
000060  900c              STR      r0,[sp,#0x30]
;;;169         DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;                    //内存突发传输为单一
000062  2000              MOVS     r0,#0
000064  900d              STR      r0,[sp,#0x34]
;;;170         DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;     //外设突发传输为单一
000066  900e              STR      r0,[sp,#0x38]
;;;171         DMA_Init(DMA2_Stream2, &DMA_InitStructure);                             //初始化DMA2_Stream2
000068  4669              MOV      r1,sp
00006a  4818              LDR      r0,|L2.204|
00006c  f7fffffe          BL       DMA_Init
;;;172         //DMA_ITConfig(DMA2_Stream2, DMA_IT_TC, ENABLE);//使能传输完成中断 
;;;173         
;;;174         //   SPI1 TX DMA 配置   Stream3
;;;175         DMA_InitStructure.DMA_Channel = DMA_Channel_6;        
000070  f04f6040          MOV      r0,#0xc000000
000074  9000              STR      r0,[sp,#0]
;;;176         DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&SPI1->DR;         //指定DMA的外设基地址为SPI1的数据地址
000076  4816              LDR      r0,|L2.208|
000078  9001              STR      r0,[sp,#4]
;;;177         DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)SPI1_Tx_Buff;         //指定DMA的内存基地址
00007a  4817              LDR      r0,|L2.216|
00007c  9002              STR      r0,[sp,#8]
;;;178         DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;                 //DMA传输方向为读内存，写外设
00007e  2040              MOVS     r0,#0x40
000080  9003              STR      r0,[sp,#0xc]
;;;179         DMA_InitStructure.DMA_BufferSize = 4;//DataSize;                            //传输数量(0-65535，不能为0)
000082  2004              MOVS     r0,#4
000084  9004              STR      r0,[sp,#0x10]
;;;180         DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;        //失能外设地址增长
000086  2000              MOVS     r0,#0
000088  9005              STR      r0,[sp,#0x14]
;;;181         DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                 //失能内存地址增长
00008a  f44f6080          MOV      r0,#0x400
00008e  9006              STR      r0,[sp,#0x18]
;;;182         DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;        //PSIZE=16bit
000090  0040              LSLS     r0,r0,#1
000092  9007              STR      r0,[sp,#0x1c]
;;;183         DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_HalfWord;        //MSIZE=16bit           
000094  9008              STR      r0,[sp,#0x20]
;;;184         DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;//DMA_Mode_Normal;//       //DMA模式为非循环模式,非循环模式只进行单次传输。
000096  10c0              ASRS     r0,r0,#3
000098  9009              STR      r0,[sp,#0x24]
;;;185         DMA_InitStructure.DMA_Priority = DMA_Priority_Medium ;                  //优先权为中等
00009a  0200              LSLS     r0,r0,#8
00009c  900a              STR      r0,[sp,#0x28]
;;;186         DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;                  //失能FIFO模式
00009e  2000              MOVS     r0,#0
0000a0  900b              STR      r0,[sp,#0x2c]
;;;187         DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;       //FIFO的阀值为半满
0000a2  2001              MOVS     r0,#1
0000a4  900c              STR      r0,[sp,#0x30]
;;;188         DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;                    //内存突发传输为单一
0000a6  2000              MOVS     r0,#0
0000a8  900d              STR      r0,[sp,#0x34]
;;;189         DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;     //外设突发传输为单一
0000aa  900e              STR      r0,[sp,#0x38]
;;;190         DMA_Init(DMA2_Stream3, &DMA_InitStructure);                             //初始化DMA2_Stream3
0000ac  4669              MOV      r1,sp
0000ae  4807              LDR      r0,|L2.204|
0000b0  3018              ADDS     r0,r0,#0x18
0000b2  f7fffffe          BL       DMA_Init
;;;191         //DMA_ITConfig(DMA2_Stream3, DMA_IT_TC, ENABLE);                        //因为是发送虚拟数据。不需要中断
;;;192         
;;;193         /* DMA enable*/
;;;194         DMA_Cmd(DMA2_Stream2, ENABLE);
0000b6  2101              MOVS     r1,#1
0000b8  4804              LDR      r0,|L2.204|
0000ba  f7fffffe          BL       DMA_Cmd
;;;195         DMA_Cmd(DMA2_Stream3, ENABLE);
0000be  2101              MOVS     r1,#1
0000c0  4802              LDR      r0,|L2.204|
0000c2  3018              ADDS     r0,r0,#0x18
0000c4  f7fffffe          BL       DMA_Cmd
;;;196    }
0000c8  b00f              ADD      sp,sp,#0x3c
0000ca  bd00              POP      {pc}
;;;197    
                          ENDP

                  |L2.204|
                          DCD      0x40026440
                  |L2.208|
                          DCD      0x4001300c
                  |L2.212|
                          DCD      SPI1_Rx_Buff
                  |L2.216|
                          DCD      SPI1_Tx_Buff

                          AREA ||i.SPI1_Init||, CODE, READONLY, ALIGN=2

                  SPI1_Init PROC
;;;46     
;;;47     void SPI1_Init(void)
000000  b500              PUSH     {lr}
;;;48     {         
000002  b087              SUB      sp,sp,#0x1c
;;;49          GPIO_InitTypeDef  GPIO_InitStructure;
;;;50          SPI_InitTypeDef  SPI_InitStructure;
;;;51     
;;;52          RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);//使能GPIOA时钟
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;53          RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);//使能SPI1时钟
00000c  2101              MOVS     r1,#1
00000e  0308              LSLS     r0,r1,#12
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;54     
;;;55          //PA5,6,7初始化设置
;;;56          GPIO_InitStructure.GPIO_Pin =GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;//PA5~7复用功能输出        
000014  20e0              MOVS     r0,#0xe0
000016  9005              STR      r0,[sp,#0x14]
;;;57          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
000018  2002              MOVS     r0,#2
00001a  f88d0018          STRB     r0,[sp,#0x18]
;;;58          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
00001e  2000              MOVS     r0,#0
000020  f88d001a          STRB     r0,[sp,#0x1a]
;;;59          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
000024  2003              MOVS     r0,#3
000026  f88d0019          STRB     r0,[sp,#0x19]
;;;60          GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;//上拉  
00002a  2001              MOVS     r0,#1
00002c  f88d001b          STRB     r0,[sp,#0x1b]
;;;61          GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化
000030  a905              ADD      r1,sp,#0x14
000032  4821              LDR      r0,|L3.184|
000034  f7fffffe          BL       GPIO_Init
;;;62     
;;;63          GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_SPI1);//PA5复用为 SPI1
000038  2205              MOVS     r2,#5
00003a  4611              MOV      r1,r2
00003c  481e              LDR      r0,|L3.184|
00003e  f7fffffe          BL       GPIO_PinAFConfig
;;;64          GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_SPI1);//PA6复用为 SPI1
000042  2205              MOVS     r2,#5
000044  2106              MOVS     r1,#6
000046  481c              LDR      r0,|L3.184|
000048  f7fffffe          BL       GPIO_PinAFConfig
;;;65          GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_SPI1);//PA7复用为 SPI1
00004c  2205              MOVS     r2,#5
00004e  2107              MOVS     r1,#7
000050  4819              LDR      r0,|L3.184|
000052  f7fffffe          BL       GPIO_PinAFConfig
;;;66     
;;;67          //这里只针对SPI口初始化
;;;68          RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1,ENABLE);//复位SPI1
000056  2101              MOVS     r1,#1
000058  0308              LSLS     r0,r1,#12
00005a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;69          RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1,DISABLE);//停止复位SPI1
00005e  2100              MOVS     r1,#0
000060  f44f5080          MOV      r0,#0x1000
000064  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;70     
;;;71          SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; 
000068  2000              MOVS     r0,#0
00006a  f8ad0000          STRH     r0,[sp,#0]
;;;72          SPI_InitStructure.SPI_Mode = SPI_Mode_Master;                //为主SPI
00006e  f44f7082          MOV      r0,#0x104
000072  f8ad0002          STRH     r0,[sp,#2]
;;;73          SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;                //SPI发送接收16位帧结构
000076  f44f6000          MOV      r0,#0x800
00007a  f8ad0004          STRH     r0,[sp,#4]
;;;74          SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;                //串行同步时钟的空闲状态为低电平
00007e  2000              MOVS     r0,#0
000080  f8ad0006          STRH     r0,[sp,#6]
;;;75          SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;        //串行同步时钟的第二个跳变沿（上升或下降）数据被采样
000084  2001              MOVS     r0,#1
000086  f8ad0008          STRH     r0,[sp,#8]
;;;76          SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;                //NSS信号由软件管理
00008a  0240              LSLS     r0,r0,#9
00008c  f8ad000a          STRH     r0,[sp,#0xa]
;;;77          SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;  //波特率预分频值为4(21MHz)
000090  2008              MOVS     r0,#8
000092  f8ad000c          STRH     r0,[sp,#0xc]
;;;78          SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;        //数据从MSB位开始
000096  2000              MOVS     r0,#0
000098  f8ad000e          STRH     r0,[sp,#0xe]
;;;79          SPI_InitStructure.SPI_CRCPolynomial = 7;        //CRC值计算的多项式
00009c  2007              MOVS     r0,#7
00009e  f8ad0010          STRH     r0,[sp,#0x10]
;;;80          SPI_Init(SPI1, &SPI_InitStructure); 
0000a2  4669              MOV      r1,sp
0000a4  4805              LDR      r0,|L3.188|
0000a6  f7fffffe          BL       SPI_Init
;;;81     
;;;82          SPI_Cmd(SPI1, ENABLE); //使能SPI外设
0000aa  2101              MOVS     r1,#1
0000ac  4803              LDR      r0,|L3.188|
0000ae  f7fffffe          BL       SPI_Cmd
;;;83     }
0000b2  b007              ADD      sp,sp,#0x1c
0000b4  bd00              POP      {pc}
;;;84     
                          ENDP

0000b6  0000              DCW      0x0000
                  |L3.184|
                          DCD      0x40020000
                  |L3.188|
                          DCD      0x40013000

                          AREA ||i.SPI2_Init||, CODE, READONLY, ALIGN=2

                  SPI2_Init PROC
;;;7      
;;;8      void SPI2_Init(void)
000000  b500              PUSH     {lr}
;;;9      {         
000002  b087              SUB      sp,sp,#0x1c
;;;10          GPIO_InitTypeDef  GPIO_InitStructure;
;;;11          SPI_InitTypeDef  SPI_InitStructure;
;;;12     
;;;13          RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);//使能GPIOB时钟
000004  2101              MOVS     r1,#1
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;14          RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,ENABLE);//使能SPI1时钟
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;15     
;;;16          //PA5,6,7初始化设置
;;;17          GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;//PA5~7复用功能输出        
000014  f44f4060          MOV      r0,#0xe000
000018  9005              STR      r0,[sp,#0x14]
;;;18          GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
00001a  2002              MOVS     r0,#2
00001c  f88d0018          STRB     r0,[sp,#0x18]
;;;19          GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
000020  2000              MOVS     r0,#0
000022  f88d001a          STRB     r0,[sp,#0x1a]
;;;20          GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
000026  2003              MOVS     r0,#3
000028  f88d0019          STRB     r0,[sp,#0x19]
;;;21          GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;//上拉  
00002c  2001              MOVS     r0,#1
00002e  f88d001b          STRB     r0,[sp,#0x1b]
;;;22          GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
000032  a905              ADD      r1,sp,#0x14
000034  4820              LDR      r0,|L4.184|
000036  f7fffffe          BL       GPIO_Init
;;;23     
;;;24          GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_SPI2);//PA5复用为 SPI1
00003a  2205              MOVS     r2,#5
00003c  210d              MOVS     r1,#0xd
00003e  481e              LDR      r0,|L4.184|
000040  f7fffffe          BL       GPIO_PinAFConfig
;;;25          GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_SPI2);//PA6复用为 SPI1
000044  2205              MOVS     r2,#5
000046  210e              MOVS     r1,#0xe
000048  481b              LDR      r0,|L4.184|
00004a  f7fffffe          BL       GPIO_PinAFConfig
;;;26          GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_SPI2);//PA7复用为 SPI1
00004e  2205              MOVS     r2,#5
000050  210f              MOVS     r1,#0xf
000052  4819              LDR      r0,|L4.184|
000054  f7fffffe          BL       GPIO_PinAFConfig
;;;27     
;;;28          //这里只针对SPI口初始化
;;;29          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2,ENABLE);//复位SPI1
000058  2101              MOVS     r1,#1
00005a  0388              LSLS     r0,r1,#14
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;30          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2,DISABLE);//停止复位SPI1
000060  2100              MOVS     r1,#0
000062  f44f4080          MOV      r0,#0x4000
000066  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;31     
;;;32          SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; 
00006a  2000              MOVS     r0,#0
00006c  f8ad0000          STRH     r0,[sp,#0]
;;;33          SPI_InitStructure.SPI_Mode = SPI_Mode_Master;                //为主SPI
000070  f44f7082          MOV      r0,#0x104
000074  f8ad0002          STRH     r0,[sp,#2]
;;;34          SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;                //SPI发送接收16位帧结构
000078  f44f6000          MOV      r0,#0x800
00007c  f8ad0004          STRH     r0,[sp,#4]
;;;35          SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;                //串行同步时钟的空闲状态为低电平
000080  2000              MOVS     r0,#0
000082  f8ad0006          STRH     r0,[sp,#6]
;;;36          SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;        //串行同步时钟的第二个跳变沿（上升或下降）数据被采样
000086  2001              MOVS     r0,#1
000088  f8ad0008          STRH     r0,[sp,#8]
;;;37          SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;                //NSS信号由软件管理
00008c  0240              LSLS     r0,r0,#9
00008e  f8ad000a          STRH     r0,[sp,#0xa]
;;;38          SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;  //波特率预分频值为4(21MHz)
000092  2008              MOVS     r0,#8
000094  f8ad000c          STRH     r0,[sp,#0xc]
;;;39          SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;        //数据从MSB位开始
000098  2000              MOVS     r0,#0
00009a  f8ad000e          STRH     r0,[sp,#0xe]
;;;40          SPI_InitStructure.SPI_CRCPolynomial = 7;        //CRC值计算的多项式
00009e  2007              MOVS     r0,#7
0000a0  f8ad0010          STRH     r0,[sp,#0x10]
;;;41          SPI_Init(SPI2, &SPI_InitStructure); 
0000a4  4669              MOV      r1,sp
0000a6  4805              LDR      r0,|L4.188|
0000a8  f7fffffe          BL       SPI_Init
;;;42     
;;;43          SPI_Cmd(SPI2, ENABLE); //使能SPI外设
0000ac  2101              MOVS     r1,#1
0000ae  4803              LDR      r0,|L4.188|
0000b0  f7fffffe          BL       SPI_Cmd
;;;44     }
0000b4  b007              ADD      sp,sp,#0x1c
0000b6  bd00              POP      {pc}
;;;45     
                          ENDP

                  |L4.184|
                          DCD      0x40020400
                  |L4.188|
                          DCD      0x40003800

                          AREA ||i.TIM1_Init||, CODE, READONLY, ALIGN=2

                  TIM1_Init PROC
;;;252    
;;;253    void TIM1_Init(u16 period)//period设置24以1MHz采样，period设置240以100KHz采样，period设置2400以10KHz采样，period设置24000以1KHz采样，
000000  b510              PUSH     {r4,lr}
;;;254    {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;255         GPIO_InitTypeDef  GPIO_InitStructure;
;;;256         
;;;257         TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
;;;258         TIM_OCInitTypeDef TIM_OCInitStructure;
;;;259    
;;;260         RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);//使能GPIOE时钟
000006  2101              MOVS     r1,#1
000008  2010              MOVS     r0,#0x10
00000a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;261         RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
00000e  2101              MOVS     r1,#1
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;262         
;;;263         GPIO_InitStructure.GPIO_Pin=GPIO_Pin_8 |GPIO_Pin_9 | GPIO_Pin_12 |GPIO_Pin_13;
000016  f44f504c          MOV      r0,#0x3300
00001a  9008              STR      r0,[sp,#0x20]
;;;264         GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF;//模式必须为复用
00001c  2002              MOVS     r0,#2
00001e  f88d0024          STRB     r0,[sp,#0x24]
;;;265         //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;266         GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000022  2000              MOVS     r0,#0
000024  f88d0026          STRB     r0,[sp,#0x26]
;;;267         GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;//频率为快速
000028  2003              MOVS     r0,#3
00002a  f88d0025          STRB     r0,[sp,#0x25]
;;;268         GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;
00002e  2001              MOVS     r0,#1
000030  f88d0027          STRB     r0,[sp,#0x27]
;;;269         GPIO_Init(GPIOE, &GPIO_InitStructure);
000034  a908              ADD      r1,sp,#0x20
000036  482f              LDR      r0,|L5.244|
000038  f7fffffe          BL       GPIO_Init
;;;270         GPIO_PinAFConfig(GPIOE, GPIO_PinSource8, GPIO_AF_TIM1);//PE8 作为 AD的/convst信号
00003c  2201              MOVS     r2,#1
00003e  2108              MOVS     r1,#8
000040  482c              LDR      r0,|L5.244|
000042  f7fffffe          BL       GPIO_PinAFConfig
;;;271         GPIO_PinAFConfig(GPIOE, GPIO_PinSource9, GPIO_AF_TIM1);
000046  2201              MOVS     r2,#1
000048  2109              MOVS     r1,#9
00004a  482a              LDR      r0,|L5.244|
00004c  f7fffffe          BL       GPIO_PinAFConfig
;;;272         GPIO_PinAFConfig(GPIOE, GPIO_PinSource12, GPIO_AF_TIM1);//PE12 作为 AD的/CS信号
000050  2201              MOVS     r2,#1
000052  210c              MOVS     r1,#0xc
000054  4827              LDR      r0,|L5.244|
000056  f7fffffe          BL       GPIO_PinAFConfig
;;;273         GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_TIM1);
00005a  2201              MOVS     r2,#1
00005c  210d              MOVS     r1,#0xd
00005e  4825              LDR      r0,|L5.244|
000060  f7fffffe          BL       GPIO_PinAFConfig
;;;274         
;;;275         //初始化
;;;276         TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //死区控制用。
000064  2000              MOVS     r0,#0
000066  f8ad001c          STRH     r0,[sp,#0x1c]
;;;277         TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //向上计数
00006a  f8ad0016          STRH     r0,[sp,#0x16]
;;;278         TIM_TimeBaseStructure.TIM_Prescaler = 7 - 1;   //Timer clock = 168M /(TIM_Prescaler+1) = 24M
00006e  2006              MOVS     r0,#6
000070  f8ad0014          STRH     r0,[sp,#0x14]
;;;279         TIM_TimeBaseStructure.TIM_RepetitionCounter = 4;
000074  2004              MOVS     r0,#4
000076  f88d001e          STRB     r0,[sp,#0x1e]
;;;280         TIM_TimeBaseStructure.TIM_Period = period - 1;
00007a  1e60              SUBS     r0,r4,#1
00007c  9006              STR      r0,[sp,#0x18]
;;;281         TIM_TimeBaseInit(TIM1,&TIM_TimeBaseStructure);
00007e  a905              ADD      r1,sp,#0x14
000080  481d              LDR      r0,|L5.248|
000082  f7fffffe          BL       TIM_TimeBaseInit
;;;282         
;;;283         //配置输出比较，产生PWM方波
;;;284         TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;//PWM1为正常占空比模式，PWM2为反极性模式
000086  2060              MOVS     r0,#0x60
000088  f8ad0000          STRH     r0,[sp,#0]
;;;285         TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
00008c  2001              MOVS     r0,#1
00008e  f8ad0002          STRH     r0,[sp,#2]
;;;286         TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
000092  2004              MOVS     r0,#4
000094  f8ad0004          STRH     r0,[sp,#4]
;;;287         TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
000098  2000              MOVS     r0,#0
00009a  f8ad000c          STRH     r0,[sp,#0xc]
;;;288         TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;//输出反相 TIM_OCNPolarity_Low;//输出同相，
00009e  f8ad000e          STRH     r0,[sp,#0xe]
;;;289         TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
0000a2  f44f7080          MOV      r0,#0x100
0000a6  f8ad0010          STRH     r0,[sp,#0x10]
;;;290         TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset;
0000aa  2000              MOVS     r0,#0
0000ac  f8ad0012          STRH     r0,[sp,#0x12]
;;;291    
;;;292         TIM_OCInitStructure.TIM_Pulse = 1;//ccr1;//PE8 作为 AD的/convst信号
0000b0  2001              MOVS     r0,#1
0000b2  9002              STR      r0,[sp,#8]
;;;293         TIM_OC1Init(TIM1,&TIM_OCInitStructure);//触发DMA2_Stream3 channel6
0000b4  4669              MOV      r1,sp
0000b6  4810              LDR      r0,|L5.248|
0000b8  f7fffffe          BL       TIM_OC1Init
;;;294         
;;;295         TIM_OCInitStructure.TIM_Pulse = 1;//ccr2;
0000bc  2001              MOVS     r0,#1
0000be  9002              STR      r0,[sp,#8]
;;;296         TIM_OC2Init(TIM1,&TIM_OCInitStructure);//触发DMA2_Stream2 channel6
0000c0  4669              MOV      r1,sp
0000c2  480d              LDR      r0,|L5.248|
0000c4  f7fffffe          BL       TIM_OC2Init
;;;297         
;;;298         TIM_OCInitStructure.TIM_Pulse = 24;//ccr3;//PE12 作为 AD的/CS信号
0000c8  2018              MOVS     r0,#0x18
0000ca  9002              STR      r0,[sp,#8]
;;;299         TIM_OC3Init(TIM1,&TIM_OCInitStructure);
0000cc  4669              MOV      r1,sp
0000ce  480a              LDR      r0,|L5.248|
0000d0  f7fffffe          BL       TIM_OC3Init
;;;300    
;;;301         TIM_Cmd(TIM1,ENABLE);
0000d4  2101              MOVS     r1,#1
0000d6  4808              LDR      r0,|L5.248|
0000d8  f7fffffe          BL       TIM_Cmd
;;;302         TIM_CtrlPWMOutputs(TIM1,ENABLE);
0000dc  2101              MOVS     r1,#1
0000de  4806              LDR      r0,|L5.248|
0000e0  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;303         
;;;304         /* TIM1 DMA 请求使能 */
;;;305         TIM_DMACmd(TIM1, TIM_DMA_CC1 | TIM_DMA_CC2, ENABLE);//
0000e4  2201              MOVS     r2,#1
0000e6  f44f61c0          MOV      r1,#0x600
0000ea  4803              LDR      r0,|L5.248|
0000ec  f7fffffe          BL       TIM_DMACmd
;;;306    }
0000f0  b00a              ADD      sp,sp,#0x28
0000f2  bd10              POP      {r4,pc}
;;;307    
                          ENDP

                  |L5.244|
                          DCD      0x40021000
                  |L5.248|
                          DCD      0x40010000

                          AREA ||i.TIM2_Init||, CODE, READONLY, ALIGN=2

                  TIM2_Init PROC
;;;197    
;;;198    void TIM2_Init(u16 period)//period设置24以1MHz采样，period设置240以100KHz采样，period设置2400以10KHz采样，period设置24000以1KHz采样，
000000  b510              PUSH     {r4,lr}
;;;199    {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;200         GPIO_InitTypeDef  GPIO_InitStructure;
;;;201         
;;;202         TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
;;;203         TIM_OCInitTypeDef TIM_OCInitStructure;
;;;204    
;;;205         RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);//使能GPIOE时钟
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;206         RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
00000e  2101              MOVS     r1,#1
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;207         
;;;208         GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0 |GPIO_Pin_1 | GPIO_Pin_2 |GPIO_Pin_3;
000016  200f              MOVS     r0,#0xf
000018  9008              STR      r0,[sp,#0x20]
;;;209         GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF;			//模式必须为复用
00001a  2002              MOVS     r0,#2
00001c  f88d0024          STRB     r0,[sp,#0x24]
;;;210         //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;211         GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000020  2000              MOVS     r0,#0
000022  f88d0026          STRB     r0,[sp,#0x26]
;;;212         GPIO_InitStructure.GPIO_Speed=GPIO_Speed_100MHz;//频率为快速
000026  2003              MOVS     r0,#3
000028  f88d0025          STRB     r0,[sp,#0x25]
;;;213         GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;
00002c  2001              MOVS     r0,#1
00002e  f88d0027          STRB     r0,[sp,#0x27]
;;;214         GPIO_Init(GPIOA, &GPIO_InitStructure);
000032  a908              ADD      r1,sp,#0x20
000034  4830              LDR      r0,|L6.248|
000036  f7fffffe          BL       GPIO_Init
;;;215         GPIO_PinAFConfig(GPIOA, GPIO_PinSource0, GPIO_AF_TIM2);//PE8 作为 AD的/convst信号
00003a  2201              MOVS     r2,#1
00003c  2100              MOVS     r1,#0
00003e  482e              LDR      r0,|L6.248|
000040  f7fffffe          BL       GPIO_PinAFConfig
;;;216         GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_TIM2);
000044  2201              MOVS     r2,#1
000046  4611              MOV      r1,r2
000048  482b              LDR      r0,|L6.248|
00004a  f7fffffe          BL       GPIO_PinAFConfig
;;;217         GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_TIM2);//PE12 作为 AD的/CS信号
00004e  2201              MOVS     r2,#1
000050  2102              MOVS     r1,#2
000052  4829              LDR      r0,|L6.248|
000054  f7fffffe          BL       GPIO_PinAFConfig
;;;218         GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_TIM2);
000058  2201              MOVS     r2,#1
00005a  2103              MOVS     r1,#3
00005c  4826              LDR      r0,|L6.248|
00005e  f7fffffe          BL       GPIO_PinAFConfig
;;;219         
;;;220         //初始化
;;;221         TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //死区控制用。
000062  2000              MOVS     r0,#0
000064  f8ad001c          STRH     r0,[sp,#0x1c]
;;;222         TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //向上计数
000068  f8ad0016          STRH     r0,[sp,#0x16]
;;;223         TIM_TimeBaseStructure.TIM_Prescaler = 7 - 1;   //Timer clock = 168M /(TIM_Prescaler+1) = 24M
00006c  2006              MOVS     r0,#6
00006e  f8ad0014          STRH     r0,[sp,#0x14]
;;;224         TIM_TimeBaseStructure.TIM_RepetitionCounter = 4;
000072  2004              MOVS     r0,#4
000074  f88d001e          STRB     r0,[sp,#0x1e]
;;;225         TIM_TimeBaseStructure.TIM_Period = period - 1;
000078  1e60              SUBS     r0,r4,#1
00007a  9006              STR      r0,[sp,#0x18]
;;;226         TIM_TimeBaseInit(TIM2,&TIM_TimeBaseStructure);
00007c  a905              ADD      r1,sp,#0x14
00007e  f04f4080          MOV      r0,#0x40000000
000082  f7fffffe          BL       TIM_TimeBaseInit
;;;227         
;;;228         //配置输出比较，产生PWM方波
;;;229         TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;//PWM1为正常占空比模式，PWM2为反极性模式
000086  2060              MOVS     r0,#0x60
000088  f8ad0000          STRH     r0,[sp,#0]
;;;230         TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
00008c  2001              MOVS     r0,#1
00008e  f8ad0002          STRH     r0,[sp,#2]
;;;231         TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
000092  2004              MOVS     r0,#4
000094  f8ad0004          STRH     r0,[sp,#4]
;;;232         TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;
000098  2002              MOVS     r0,#2
00009a  f8ad000c          STRH     r0,[sp,#0xc]
;;;233         TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;//输出反相 TIM_OCNPolarity_Low;//输出同相，
00009e  2000              MOVS     r0,#0
0000a0  f8ad000e          STRH     r0,[sp,#0xe]
;;;234         TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
0000a4  f44f7080          MOV      r0,#0x100
0000a8  f8ad0010          STRH     r0,[sp,#0x10]
;;;235         TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset;
0000ac  2000              MOVS     r0,#0
0000ae  f8ad0012          STRH     r0,[sp,#0x12]
;;;236    
;;;237         TIM_OCInitStructure.TIM_Pulse = 1;//ccr1;//PE8 作为 AD的/convst信号
0000b2  2001              MOVS     r0,#1
0000b4  9002              STR      r0,[sp,#8]
;;;238         TIM_OC1Init(TIM2,&TIM_OCInitStructure);//触发DMA2_Stream3 channel6
0000b6  4669              MOV      r1,sp
0000b8  0780              LSLS     r0,r0,#30
0000ba  f7fffffe          BL       TIM_OC1Init
;;;239         
;;;240         TIM_OCInitStructure.TIM_Pulse = 1;//ccr2;
0000be  2001              MOVS     r0,#1
0000c0  9002              STR      r0,[sp,#8]
;;;241         TIM_OC2Init(TIM2,&TIM_OCInitStructure);//触发DMA2_Stream2 channel6
0000c2  4669              MOV      r1,sp
0000c4  0780              LSLS     r0,r0,#30
0000c6  f7fffffe          BL       TIM_OC2Init
;;;242         
;;;243         TIM_OCInitStructure.TIM_Pulse = 24;//ccr3;//PE12 作为 AD的/CS信号
0000ca  2018              MOVS     r0,#0x18
0000cc  9002              STR      r0,[sp,#8]
;;;244         TIM_OC3Init(TIM2,&TIM_OCInitStructure);
0000ce  4669              MOV      r1,sp
0000d0  f04f4080          MOV      r0,#0x40000000
0000d4  f7fffffe          BL       TIM_OC3Init
;;;245    
;;;246         TIM_Cmd(TIM2,ENABLE);
0000d8  2101              MOVS     r1,#1
0000da  0788              LSLS     r0,r1,#30
0000dc  f7fffffe          BL       TIM_Cmd
;;;247         TIM_CtrlPWMOutputs(TIM2,ENABLE);
0000e0  2101              MOVS     r1,#1
0000e2  0788              LSLS     r0,r1,#30
0000e4  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;248         
;;;249         /* TIM1 DMA 请求使能 */
;;;250         TIM_DMACmd(TIM2, TIM_DMA_CC1 | TIM_DMA_CC2, ENABLE);//
0000e8  2201              MOVS     r2,#1
0000ea  f44f61c0          MOV      r1,#0x600
0000ee  0790              LSLS     r0,r2,#30
0000f0  f7fffffe          BL       TIM_DMACmd
;;;251    }
0000f4  b00a              ADD      sp,sp,#0x28
0000f6  bd10              POP      {r4,pc}
;;;252    
                          ENDP

                  |L6.248|
                          DCD      0x40020000

                          AREA ||.data||, DATA, ALIGN=1

                  SPI1_Rx_Buff
                          %        8
                  SPI1_Tx_Buff
000008  d000d000          DCW      0xd000,0xd000
00000c  d000d000          DCW      0xd000,0xd000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\MiddleWareDrv\\DMA_TimerSPI_MD.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_DMA_TimerSPI_MD_c_e194a275____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_DMA_TimerSPI_MD_c_e194a275____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_DMA_TimerSPI_MD_c_e194a275____REVSH|
#line 144
|__asm___17_DMA_TimerSPI_MD_c_e194a275____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_DMA_TimerSPI_MD_c_e194a275____RRX|
#line 300
|__asm___17_DMA_TimerSPI_MD_c_e194a275____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
