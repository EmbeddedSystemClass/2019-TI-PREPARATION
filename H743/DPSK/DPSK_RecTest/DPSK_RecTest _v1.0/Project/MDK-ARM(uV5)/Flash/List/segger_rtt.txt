; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\segger_rtt.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\segger_rtt.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\MiddleWareDrv -I..\..\User\RTT -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 --omf_browse=.\flash\obj\segger_rtt.crf ..\..\User\RTT\SEGGER_RTT.c]
                          THUMB

                          AREA ||i.SEGGER_RTT_AllocDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_AllocDownBuffer PROC
;;;830    */
;;;831    int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;832      int BufferIndex;
;;;833    
;;;834      INIT();
00000c  bf00              NOP      
00000e  4825              LDR      r0,|L1.164|
000010  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000012  b908              CBNZ     r0,|L1.24|
000014  f7fffffe          BL       _DoInit
                  |L1.24|
000018  bf00              NOP      
;;;835      SEGGER_RTT_LOCK();
;;;836      BufferIndex = 0;
00001a  2400              MOVS     r4,#0
;;;837      do {
00001c  bf00              NOP      
                  |L1.30|
;;;838        if (_SEGGER_RTT.aDown[BufferIndex].pBuffer == NULL) {
00001e  eb040144          ADD      r1,r4,r4,LSL #1
000022  4820              LDR      r0,|L1.164|
000024  3048              ADDS     r0,r0,#0x48
000026  eb0000c1          ADD      r0,r0,r1,LSL #3
00002a  6840              LDR      r0,[r0,#4]
00002c  b900              CBNZ     r0,|L1.48|
;;;839          break;
00002e  e004              B        |L1.58|
                  |L1.48|
;;;840        }
;;;841        BufferIndex++;
000030  1c64              ADDS     r4,r4,#1
;;;842      } while (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers);
000032  481c              LDR      r0,|L1.164|
000034  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000036  42a0              CMP      r0,r4
000038  dcf1              BGT      |L1.30|
                  |L1.58|
00003a  bf00              NOP                            ;839
;;;843      if (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers) {
00003c  4819              LDR      r0,|L1.164|
00003e  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000040  42a0              CMP      r0,r4
000042  dd29              BLE      |L1.152|
;;;844        _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
000044  eb040144          ADD      r1,r4,r4,LSL #1
000048  4816              LDR      r0,|L1.164|
00004a  3048              ADDS     r0,r0,#0x48
00004c  f8405031          STR      r5,[r0,r1,LSL #3]
;;;845        _SEGGER_RTT.aDown[BufferIndex].pBuffer      = pBuffer;
000050  eb040144          ADD      r1,r4,r4,LSL #1
000054  eb0000c1          ADD      r0,r0,r1,LSL #3
000058  6047              STR      r7,[r0,#4]
;;;846        _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
00005a  eb040144          ADD      r1,r4,r4,LSL #1
00005e  4811              LDR      r0,|L1.164|
000060  3048              ADDS     r0,r0,#0x48
000062  eb0000c1          ADD      r0,r0,r1,LSL #3
000066  6086              STR      r6,[r0,#8]
;;;847        _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
000068  2100              MOVS     r1,#0
00006a  eb040244          ADD      r2,r4,r4,LSL #1
00006e  480d              LDR      r0,|L1.164|
000070  3048              ADDS     r0,r0,#0x48
000072  eb0000c2          ADD      r0,r0,r2,LSL #3
000076  6101              STR      r1,[r0,#0x10]
;;;848        _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
000078  eb040244          ADD      r2,r4,r4,LSL #1
00007c  4809              LDR      r0,|L1.164|
00007e  3048              ADDS     r0,r0,#0x48
000080  eb0000c2          ADD      r0,r0,r2,LSL #3
000084  60c1              STR      r1,[r0,#0xc]
;;;849        _SEGGER_RTT.aDown[BufferIndex].Flags        = Flags;
000086  eb040144          ADD      r1,r4,r4,LSL #1
00008a  4806              LDR      r0,|L1.164|
00008c  3048              ADDS     r0,r0,#0x48
00008e  eb0000c1          ADD      r0,r0,r1,LSL #3
000092  f8c08014          STR      r8,[r0,#0x14]
000096  e001              B        |L1.156|
                  |L1.152|
;;;850      } else {
;;;851        BufferIndex = -1;
000098  f04f34ff          MOV      r4,#0xffffffff
                  |L1.156|
;;;852      }
;;;853      SEGGER_RTT_UNLOCK();
;;;854      return BufferIndex;
00009c  4620              MOV      r0,r4
;;;855    }
00009e  e8bd81f0          POP      {r4-r8,pc}
;;;856    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L1.164|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_AllocUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_AllocUpBuffer PROC
;;;875    */
;;;876    int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;877      int BufferIndex;
;;;878    
;;;879      INIT();
00000c  bf00              NOP      
00000e  4825              LDR      r0,|L2.164|
000010  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000012  b908              CBNZ     r0,|L2.24|
000014  f7fffffe          BL       _DoInit
                  |L2.24|
000018  bf00              NOP      
;;;880      SEGGER_RTT_LOCK();
;;;881      BufferIndex = 0;
00001a  2400              MOVS     r4,#0
;;;882      do {
00001c  bf00              NOP      
                  |L2.30|
;;;883        if (_SEGGER_RTT.aUp[BufferIndex].pBuffer == NULL) {
00001e  eb040144          ADD      r1,r4,r4,LSL #1
000022  4820              LDR      r0,|L2.164|
000024  3018              ADDS     r0,r0,#0x18
000026  eb0000c1          ADD      r0,r0,r1,LSL #3
00002a  6840              LDR      r0,[r0,#4]
00002c  b900              CBNZ     r0,|L2.48|
;;;884          break;
00002e  e004              B        |L2.58|
                  |L2.48|
;;;885        }
;;;886        BufferIndex++;
000030  1c64              ADDS     r4,r4,#1
;;;887      } while (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers);
000032  481c              LDR      r0,|L2.164|
000034  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000036  42a0              CMP      r0,r4
000038  dcf1              BGT      |L2.30|
                  |L2.58|
00003a  bf00              NOP                            ;884
;;;888      if (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers) {
00003c  4819              LDR      r0,|L2.164|
00003e  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000040  42a0              CMP      r0,r4
000042  dd29              BLE      |L2.152|
;;;889        _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
000044  eb040144          ADD      r1,r4,r4,LSL #1
000048  4816              LDR      r0,|L2.164|
00004a  3018              ADDS     r0,r0,#0x18
00004c  f8405031          STR      r5,[r0,r1,LSL #3]
;;;890        _SEGGER_RTT.aUp[BufferIndex].pBuffer      = pBuffer;
000050  eb040144          ADD      r1,r4,r4,LSL #1
000054  eb0000c1          ADD      r0,r0,r1,LSL #3
000058  6047              STR      r7,[r0,#4]
;;;891        _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
00005a  eb040144          ADD      r1,r4,r4,LSL #1
00005e  4811              LDR      r0,|L2.164|
000060  3018              ADDS     r0,r0,#0x18
000062  eb0000c1          ADD      r0,r0,r1,LSL #3
000066  6086              STR      r6,[r0,#8]
;;;892        _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
000068  2100              MOVS     r1,#0
00006a  eb040244          ADD      r2,r4,r4,LSL #1
00006e  480d              LDR      r0,|L2.164|
000070  3018              ADDS     r0,r0,#0x18
000072  eb0000c2          ADD      r0,r0,r2,LSL #3
000076  6101              STR      r1,[r0,#0x10]
;;;893        _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
000078  eb040244          ADD      r2,r4,r4,LSL #1
00007c  4809              LDR      r0,|L2.164|
00007e  3018              ADDS     r0,r0,#0x18
000080  eb0000c2          ADD      r0,r0,r2,LSL #3
000084  60c1              STR      r1,[r0,#0xc]
;;;894        _SEGGER_RTT.aUp[BufferIndex].Flags        = Flags;
000086  eb040144          ADD      r1,r4,r4,LSL #1
00008a  4806              LDR      r0,|L2.164|
00008c  3018              ADDS     r0,r0,#0x18
00008e  eb0000c1          ADD      r0,r0,r1,LSL #3
000092  f8c08014          STR      r8,[r0,#0x14]
000096  e001              B        |L2.156|
                  |L2.152|
;;;895      } else {
;;;896        BufferIndex = -1;
000098  f04f34ff          MOV      r4,#0xffffffff
                  |L2.156|
;;;897      }
;;;898      SEGGER_RTT_UNLOCK();
;;;899      return BufferIndex;
00009c  4620              MOV      r0,r4
;;;900    }
00009e  e8bd81f0          POP      {r4-r8,pc}
;;;901    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L2.164|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigDownBuffer PROC
;;;963    */
;;;964    int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;965      int r;
;;;966    
;;;967      INIT();
000010  bf00              NOP      
000012  481e              LDR      r0,|L3.140|
000014  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000016  b908              CBNZ     r0,|L3.28|
000018  f7fffffe          BL       _DoInit
                  |L3.28|
00001c  bf00              NOP      
;;;968      if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
00001e  481b              LDR      r0,|L3.140|
000020  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000022  42a0              CMP      r0,r4
000024  d92c              BLS      |L3.128|
;;;969        SEGGER_RTT_LOCK();
;;;970        if (BufferIndex > 0u) {
000026  b30c              CBZ      r4,|L3.108|
;;;971          _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
000028  eb040144          ADD      r1,r4,r4,LSL #1
00002c  4817              LDR      r0,|L3.140|
00002e  3048              ADDS     r0,r0,#0x48
000030  f8406031          STR      r6,[r0,r1,LSL #3]
;;;972          _SEGGER_RTT.aDown[BufferIndex].pBuffer      = pBuffer;
000034  eb040144          ADD      r1,r4,r4,LSL #1
000038  eb0000c1          ADD      r0,r0,r1,LSL #3
00003c  6047              STR      r7,[r0,#4]
;;;973          _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
00003e  eb040144          ADD      r1,r4,r4,LSL #1
000042  4812              LDR      r0,|L3.140|
000044  3048              ADDS     r0,r0,#0x48
000046  eb0000c1          ADD      r0,r0,r1,LSL #3
00004a  f8c08008          STR      r8,[r0,#8]
;;;974          _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
00004e  2100              MOVS     r1,#0
000050  eb040244          ADD      r2,r4,r4,LSL #1
000054  480d              LDR      r0,|L3.140|
000056  3048              ADDS     r0,r0,#0x48
000058  eb0000c2          ADD      r0,r0,r2,LSL #3
00005c  6101              STR      r1,[r0,#0x10]
;;;975          _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
00005e  eb040244          ADD      r2,r4,r4,LSL #1
000062  480a              LDR      r0,|L3.140|
000064  3048              ADDS     r0,r0,#0x48
000066  eb0000c2          ADD      r0,r0,r2,LSL #3
00006a  60c1              STR      r1,[r0,#0xc]
                  |L3.108|
;;;976        }
;;;977        _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
00006c  eb040144          ADD      r1,r4,r4,LSL #1
000070  4806              LDR      r0,|L3.140|
000072  3048              ADDS     r0,r0,#0x48
000074  eb0000c1          ADD      r0,r0,r1,LSL #3
000078  f8c09014          STR      r9,[r0,#0x14]
;;;978        SEGGER_RTT_UNLOCK();
;;;979        r =  0;
00007c  2500              MOVS     r5,#0
00007e  e001              B        |L3.132|
                  |L3.128|
;;;980      } else {
;;;981        r = -1;
000080  f04f35ff          MOV      r5,#0xffffffff
                  |L3.132|
;;;982      }
;;;983      return r;
000084  4628              MOV      r0,r5
;;;984    }
000086  e8bd87f0          POP      {r4-r10,pc}
;;;985    
                          ENDP

00008a  0000              DCW      0x0000
                  |L3.140|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigUpBuffer PROC
;;;921    */
;;;922    int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;923      int r;
;;;924    
;;;925      INIT();
000010  bf00              NOP      
000012  481e              LDR      r0,|L4.140|
000014  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000016  b908              CBNZ     r0,|L4.28|
000018  f7fffffe          BL       _DoInit
                  |L4.28|
00001c  bf00              NOP      
;;;926      if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
00001e  481b              LDR      r0,|L4.140|
000020  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000022  42a0              CMP      r0,r4
000024  d92c              BLS      |L4.128|
;;;927        SEGGER_RTT_LOCK();
;;;928        if (BufferIndex > 0u) {
000026  b30c              CBZ      r4,|L4.108|
;;;929          _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
000028  eb040144          ADD      r1,r4,r4,LSL #1
00002c  4817              LDR      r0,|L4.140|
00002e  3018              ADDS     r0,r0,#0x18
000030  f8406031          STR      r6,[r0,r1,LSL #3]
;;;930          _SEGGER_RTT.aUp[BufferIndex].pBuffer      = pBuffer;
000034  eb040144          ADD      r1,r4,r4,LSL #1
000038  eb0000c1          ADD      r0,r0,r1,LSL #3
00003c  6047              STR      r7,[r0,#4]
;;;931          _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
00003e  eb040144          ADD      r1,r4,r4,LSL #1
000042  4812              LDR      r0,|L4.140|
000044  3018              ADDS     r0,r0,#0x18
000046  eb0000c1          ADD      r0,r0,r1,LSL #3
00004a  f8c08008          STR      r8,[r0,#8]
;;;932          _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
00004e  2100              MOVS     r1,#0
000050  eb040244          ADD      r2,r4,r4,LSL #1
000054  480d              LDR      r0,|L4.140|
000056  3018              ADDS     r0,r0,#0x18
000058  eb0000c2          ADD      r0,r0,r2,LSL #3
00005c  6101              STR      r1,[r0,#0x10]
;;;933          _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
00005e  eb040244          ADD      r2,r4,r4,LSL #1
000062  480a              LDR      r0,|L4.140|
000064  3018              ADDS     r0,r0,#0x18
000066  eb0000c2          ADD      r0,r0,r2,LSL #3
00006a  60c1              STR      r1,[r0,#0xc]
                  |L4.108|
;;;934        }
;;;935        _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
00006c  eb040144          ADD      r1,r4,r4,LSL #1
000070  4806              LDR      r0,|L4.140|
000072  3018              ADDS     r0,r0,#0x18
000074  eb0000c1          ADD      r0,r0,r1,LSL #3
000078  f8c09014          STR      r9,[r0,#0x14]
;;;936        SEGGER_RTT_UNLOCK();
;;;937        r =  0;
00007c  2500              MOVS     r5,#0
00007e  e001              B        |L4.132|
                  |L4.128|
;;;938      } else {
;;;939        r = -1;
000080  f04f35ff          MOV      r5,#0xffffffff
                  |L4.132|
;;;940      }
;;;941      return r;
000084  4628              MOV      r0,r5
;;;942    }
000086  e8bd87f0          POP      {r4-r10,pc}
;;;943    
                          ENDP

00008a  0000              DCW      0x0000
                  |L4.140|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_GetKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_GetKey PROC
;;;725    */
;;;726    int SEGGER_RTT_GetKey(void) {
000000  b538              PUSH     {r3-r5,lr}
;;;727      char c;
;;;728      int r;
;;;729    
;;;730      r = (int)SEGGER_RTT_Read(0u, &c, 1u);
000002  2201              MOVS     r2,#1
000004  4669              MOV      r1,sp
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       SEGGER_RTT_Read
00000c  4604              MOV      r4,r0
;;;731      if (r == 1) {
00000e  2c01              CMP      r4,#1
000010  d102              BNE      |L5.24|
;;;732        r = (int)(unsigned char)c;
000012  f89d4000          LDRB     r4,[sp,#0]
000016  e001              B        |L5.28|
                  |L5.24|
;;;733      } else {
;;;734        r = -1;
000018  f04f34ff          MOV      r4,#0xffffffff
                  |L5.28|
;;;735      }
;;;736      return r;
00001c  4620              MOV      r0,r4
;;;737    }
00001e  bd38              POP      {r3-r5,pc}
;;;738    
                          ENDP


                          AREA ||i.SEGGER_RTT_HasData||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasData PROC
;;;802    */
;;;803    unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;804      SEGGER_RTT_BUFFER_DOWN* pRing;
;;;805      unsigned                v;
;;;806    
;;;807      pRing = &_SEGGER_RTT.aDown[BufferIndex];
000004  eb010441          ADD      r4,r1,r1,LSL #1
000008  4803              LDR      r0,|L6.24|
00000a  eb0002c4          ADD      r2,r0,r4,LSL #3
;;;808      v = pRing->WrOff;
00000e  68d3              LDR      r3,[r2,#0xc]
;;;809      return v - pRing->RdOff;
000010  6910              LDR      r0,[r2,#0x10]
000012  1a18              SUBS     r0,r3,r0
;;;810    }
000014  bd10              POP      {r4,pc}
;;;811    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      _SEGGER_RTT+0x48

                          AREA ||i.SEGGER_RTT_HasKey||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasKey PROC
;;;776    */
;;;777    int SEGGER_RTT_HasKey(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;778      unsigned RdOff;
;;;779      int r;
;;;780    
;;;781      INIT();
000002  bf00              NOP      
000004  4807              LDR      r0,|L7.36|
000006  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000008  b908              CBNZ     r0,|L7.14|
00000a  f7fffffe          BL       _DoInit
                  |L7.14|
00000e  bf00              NOP      
;;;782      RdOff = _SEGGER_RTT.aDown[0].RdOff;
000010  4804              LDR      r0,|L7.36|
000012  6d85              LDR      r5,[r0,#0x58]
;;;783      if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
000014  6d40              LDR      r0,[r0,#0x54]
000016  42a8              CMP      r0,r5
000018  d001              BEQ      |L7.30|
;;;784        r = 1;
00001a  2401              MOVS     r4,#1
00001c  e000              B        |L7.32|
                  |L7.30|
;;;785      } else {
;;;786        r = 0;
00001e  2400              MOVS     r4,#0
                  |L7.32|
;;;787      }
;;;788      return r;
000020  4620              MOV      r0,r4
;;;789    }
000022  bd70              POP      {r4-r6,pc}
;;;790    
                          ENDP

                  |L7.36|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_Init||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Init PROC
;;;1056   */
;;;1057   void SEGGER_RTT_Init (void) {
000000  b510              PUSH     {r4,lr}
;;;1058     INIT();
000002  bf00              NOP      
000004  4803              LDR      r0,|L8.20|
000006  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000008  b908              CBNZ     r0,|L8.14|
00000a  f7fffffe          BL       _DoInit
                  |L8.14|
00000e  bf00              NOP      
;;;1059   }
000010  bd10              POP      {r4,pc}
;;;1060   
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_Read||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Read PROC
;;;444    */
;;;445    unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;446      unsigned NumBytesRead;
;;;447      //
;;;448      SEGGER_RTT_LOCK();
;;;449      //
;;;450      // Call the non-locking read function
;;;451      //
;;;452      NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       SEGGER_RTT_ReadNoLock
000014  4607              MOV      r7,r0
;;;453      //
;;;454      // Finish up.
;;;455      //
;;;456      SEGGER_RTT_UNLOCK();
;;;457      //
;;;458      return NumBytesRead;
000016  4638              MOV      r0,r7
;;;459    }
000018  e8bd81f0          POP      {r4-r8,pc}
;;;460    
                          ENDP


                          AREA ||i.SEGGER_RTT_ReadNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ReadNoLock PROC
;;;377    */
;;;378    unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  4683              MOV      r11,r0
000006  4617              MOV      r7,r2
;;;379      unsigned                NumBytesRem;
;;;380      unsigned                NumBytesRead;
;;;381      unsigned                RdOff;
;;;382      unsigned                WrOff;
;;;383      unsigned char*          pBuffer;
;;;384      SEGGER_RTT_BUFFER_DOWN* pRing;
;;;385      //
;;;386      INIT();
000008  bf00              NOP      
00000a  4822              LDR      r0,|L10.148|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L10.20|
000010  f7fffffe          BL       _DoInit
                  |L10.20|
000014  bf00              NOP      
;;;387      pRing = &_SEGGER_RTT.aDown[BufferIndex];
000016  eb0b014b          ADD      r1,r11,r11,LSL #1
00001a  481e              LDR      r0,|L10.148|
00001c  3048              ADDS     r0,r0,#0x48
00001e  eb0006c1          ADD      r6,r0,r1,LSL #3
;;;388      pBuffer = (unsigned char*)pData;
000022  f8dd9004          LDR      r9,[sp,#4]
;;;389      RdOff = pRing->RdOff;
000026  6935              LDR      r5,[r6,#0x10]
;;;390      WrOff = pRing->WrOff;
000028  f8d6a00c          LDR      r10,[r6,#0xc]
;;;391      NumBytesRead = 0u;
00002c  f04f0800          MOV      r8,#0
;;;392      //
;;;393      // Read from current read position to wrap-around of buffer, first
;;;394      //
;;;395      if (RdOff > WrOff) {
000030  4555              CMP      r5,r10
000032  d915              BLS      |L10.96|
;;;396        NumBytesRem = pRing->SizeOfBuffer - RdOff;
000034  68b0              LDR      r0,[r6,#8]
000036  1b44              SUBS     r4,r0,r5
;;;397        NumBytesRem = MIN(NumBytesRem, BufferSize);
000038  42bc              CMP      r4,r7
00003a  d201              BCS      |L10.64|
00003c  4620              MOV      r0,r4
00003e  e000              B        |L10.66|
                  |L10.64|
000040  4638              MOV      r0,r7
                  |L10.66|
000042  4604              MOV      r4,r0
;;;398        memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000044  6870              LDR      r0,[r6,#4]
000046  1941              ADDS     r1,r0,r5
000048  4622              MOV      r2,r4
00004a  4648              MOV      r0,r9
00004c  f7fffffe          BL       __aeabi_memcpy
;;;399        NumBytesRead += NumBytesRem;
000050  44a0              ADD      r8,r8,r4
;;;400        pBuffer      += NumBytesRem;
000052  44a1              ADD      r9,r9,r4
;;;401        BufferSize   -= NumBytesRem;
000054  1b3f              SUBS     r7,r7,r4
;;;402        RdOff        += NumBytesRem;
000056  4425              ADD      r5,r5,r4
;;;403        //
;;;404        // Handle wrap-around of buffer
;;;405        //
;;;406        if (RdOff == pRing->SizeOfBuffer) {
000058  68b0              LDR      r0,[r6,#8]
00005a  42a8              CMP      r0,r5
00005c  d100              BNE      |L10.96|
;;;407          RdOff = 0u;
00005e  2500              MOVS     r5,#0
                  |L10.96|
;;;408        }
;;;409      }
;;;410      //
;;;411      // Read remaining items of buffer
;;;412      //
;;;413      NumBytesRem = WrOff - RdOff;
000060  ebaa0405          SUB      r4,r10,r5
;;;414      NumBytesRem = MIN(NumBytesRem, BufferSize);
000064  42bc              CMP      r4,r7
000066  d201              BCS      |L10.108|
000068  4620              MOV      r0,r4
00006a  e000              B        |L10.110|
                  |L10.108|
00006c  4638              MOV      r0,r7
                  |L10.110|
00006e  4604              MOV      r4,r0
;;;415      if (NumBytesRem > 0u) {
000070  b14c              CBZ      r4,|L10.134|
;;;416        memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000072  6870              LDR      r0,[r6,#4]
000074  1941              ADDS     r1,r0,r5
000076  4622              MOV      r2,r4
000078  4648              MOV      r0,r9
00007a  f7fffffe          BL       __aeabi_memcpy
;;;417        NumBytesRead += NumBytesRem;
00007e  44a0              ADD      r8,r8,r4
;;;418        pBuffer      += NumBytesRem;
000080  44a1              ADD      r9,r9,r4
;;;419        BufferSize   -= NumBytesRem;
000082  1b3f              SUBS     r7,r7,r4
;;;420        RdOff        += NumBytesRem;
000084  4425              ADD      r5,r5,r4
                  |L10.134|
;;;421      }
;;;422      if (NumBytesRead) {
000086  f1b80f00          CMP      r8,#0
00008a  d000              BEQ      |L10.142|
;;;423        pRing->RdOff = RdOff;
00008c  6135              STR      r5,[r6,#0x10]
                  |L10.142|
;;;424      }
;;;425      //
;;;426      return NumBytesRead;
00008e  4640              MOV      r0,r8
;;;427    }
000090  e8bd8ffe          POP      {r1-r11,pc}
;;;428    
                          ENDP

                  |L10.148|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameDownBuffer PROC
;;;1032   */
;;;1033   int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1034     int r;
;;;1035   
;;;1036     INIT();
000006  bf00              NOP      
000008  480a              LDR      r0,|L11.52|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L11.18|
00000e  f7fffffe          BL       _DoInit
                  |L11.18|
000012  bf00              NOP      
;;;1037     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
000014  4807              LDR      r0,|L11.52|
000016  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d907              BLS      |L11.44|
;;;1038       SEGGER_RTT_LOCK();
;;;1039       _SEGGER_RTT.aDown[BufferIndex].sName = sName;
00001c  eb040144          ADD      r1,r4,r4,LSL #1
000020  4804              LDR      r0,|L11.52|
000022  3048              ADDS     r0,r0,#0x48
000024  f8406031          STR      r6,[r0,r1,LSL #3]
;;;1040       SEGGER_RTT_UNLOCK();
;;;1041       r =  0;
000028  2500              MOVS     r5,#0
00002a  e001              B        |L11.48|
                  |L11.44|
;;;1042     } else {
;;;1043       r = -1;
00002c  f04f35ff          MOV      r5,#0xffffffff
                  |L11.48|
;;;1044     }
;;;1045     return r;
000030  4628              MOV      r0,r5
;;;1046   }
000032  bd70              POP      {r4-r6,pc}
;;;1047   
                          ENDP

                  |L11.52|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameUpBuffer PROC
;;;1001   */
;;;1002   int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1003     int r;
;;;1004   
;;;1005     INIT();
000006  bf00              NOP      
000008  480a              LDR      r0,|L12.52|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L12.18|
00000e  f7fffffe          BL       _DoInit
                  |L12.18|
000012  bf00              NOP      
;;;1006     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
000014  4807              LDR      r0,|L12.52|
000016  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d907              BLS      |L12.44|
;;;1007       SEGGER_RTT_LOCK();
;;;1008       _SEGGER_RTT.aUp[BufferIndex].sName = sName;
00001c  eb040144          ADD      r1,r4,r4,LSL #1
000020  4804              LDR      r0,|L12.52|
000022  3018              ADDS     r0,r0,#0x18
000024  f8406031          STR      r6,[r0,r1,LSL #3]
;;;1009       SEGGER_RTT_UNLOCK();
;;;1010       r =  0;
000028  2500              MOVS     r5,#0
00002a  e001              B        |L12.48|
                  |L12.44|
;;;1011     } else {
;;;1012       r = -1;
00002c  f04f35ff          MOV      r5,#0xffffffff
                  |L12.48|
;;;1013     }
;;;1014     return r;
000030  4628              MOV      r0,r5
;;;1015   }
000032  bd70              POP      {r4-r6,pc}
;;;1016   
                          ENDP

                  |L12.52|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetTerminal||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetTerminal PROC
;;;1074   */
;;;1075   int SEGGER_RTT_SetTerminal (char TerminalId) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
;;;1076     char                  ac[2];
;;;1077     SEGGER_RTT_BUFFER_UP* pRing;
;;;1078     unsigned Avail;
;;;1079     int r;
;;;1080     //
;;;1081     INIT();
000004  bf00              NOP      
000006  481a              LDR      r0,|L13.112|
000008  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000a  b908              CBNZ     r0,|L13.16|
00000c  f7fffffe          BL       _DoInit
                  |L13.16|
000010  bf00              NOP      
;;;1082     //
;;;1083     r = 0;
000012  2700              MOVS     r7,#0
;;;1084     ac[0] = 0xFFU;
000014  20ff              MOVS     r0,#0xff
000016  f88d0000          STRB     r0,[sp,#0]
;;;1085     if ((unsigned char)TerminalId < (unsigned char)sizeof(_aTerminalId)) { // We only support a certain number of channels
00001a  2c10              CMP      r4,#0x10
00001c  da23              BGE      |L13.102|
;;;1086       ac[1] = _aTerminalId[(unsigned char)TerminalId];
00001e  4815              LDR      r0,|L13.116|
000020  5d00              LDRB     r0,[r0,r4]
000022  f88d0001          STRB     r0,[sp,#1]
;;;1087       pRing = &_SEGGER_RTT.aUp[0];    // Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
000026  4d12              LDR      r5,|L13.112|
000028  3518              ADDS     r5,r5,#0x18
;;;1088       SEGGER_RTT_LOCK();    // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
;;;1089       if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
00002a  7d28              LDRB     r0,[r5,#0x14]
00002c  f0000003          AND      r0,r0,#3
000030  2802              CMP      r0,#2
000032  d107              BNE      |L13.68|
;;;1090         _ActiveTerminal = TerminalId;
000034  4810              LDR      r0,|L13.120|
000036  7004              STRB     r4,[r0,#0]
;;;1091         _WriteBlocking(pRing, ac, 2u);
000038  2202              MOVS     r2,#2
00003a  4669              MOV      r1,sp
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       _WriteBlocking
000042  e012              B        |L13.106|
                  |L13.68|
;;;1092       } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
;;;1093         Avail = _GetAvailWriteSpace(pRing);
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       _GetAvailWriteSpace
00004a  4606              MOV      r6,r0
;;;1094         if (Avail >= 2) {
00004c  2e02              CMP      r6,#2
00004e  d307              BCC      |L13.96|
;;;1095           _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
000050  4809              LDR      r0,|L13.120|
000052  7004              STRB     r4,[r0,#0]
;;;1096           _WriteNoCheck(pRing, ac, 2u);
000054  2202              MOVS     r2,#2
000056  4669              MOV      r1,sp
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       _WriteNoCheck
00005e  e004              B        |L13.106|
                  |L13.96|
;;;1097         } else {
;;;1098           r = -1;
000060  f04f37ff          MOV      r7,#0xffffffff
000064  e001              B        |L13.106|
                  |L13.102|
;;;1099         }
;;;1100       }
;;;1101       SEGGER_RTT_UNLOCK();
;;;1102     } else {
;;;1103       r = -1;
000066  f04f37ff          MOV      r7,#0xffffffff
                  |L13.106|
;;;1104     }
;;;1105     return r;
00006a  4638              MOV      r0,r7
;;;1106   }
00006c  bdf8              POP      {r3-r7,pc}
;;;1107   
                          ENDP

00006e  0000              DCW      0x0000
                  |L13.112|
                          DCD      _SEGGER_RTT
                  |L13.116|
                          DCD      _aTerminalId
                  |L13.120|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_TerminalOut||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_TerminalOut PROC
;;;1124   */
;;;1125   int SEGGER_RTT_TerminalOut (char TerminalId, const char* s) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4689              MOV      r9,r1
;;;1126     int                   Status;
;;;1127     unsigned              FragLen;
;;;1128     unsigned              Avail;
;;;1129     SEGGER_RTT_BUFFER_UP* pRing;
;;;1130     //
;;;1131     INIT();
000008  bf00              NOP      
00000a  4833              LDR      r0,|L14.216|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L14.20|
000010  f7fffffe          BL       _DoInit
                  |L14.20|
000014  bf00              NOP      
;;;1132     //
;;;1133     // Validate terminal ID.
;;;1134     //
;;;1135     if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
000016  2f10              CMP      r7,#0x10
000018  da59              BGE      |L14.206|
;;;1136       //
;;;1137       // Get "to-host" ring buffer.
;;;1138       //
;;;1139       pRing = &_SEGGER_RTT.aUp[0];
00001a  f8df80bc          LDR      r8,|L14.216|
00001e  f1080818          ADD      r8,r8,#0x18
;;;1140       //
;;;1141       // Need to be able to change terminal, write data, change back.
;;;1142       // Compute the fixed and variable sizes.
;;;1143       //
;;;1144       FragLen = strlen(s);
000022  4648              MOV      r0,r9
000024  f7fffffe          BL       strlen
000028  4606              MOV      r6,r0
;;;1145       //
;;;1146       // How we output depends upon the mode...
;;;1147       //
;;;1148       SEGGER_RTT_LOCK();
;;;1149       Avail = _GetAvailWriteSpace(pRing);
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       _GetAvailWriteSpace
000030  4605              MOV      r5,r0
;;;1150       switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
000032  f8980014          LDRB     r0,[r8,#0x14]
000036  f0000003          AND      r0,r0,#3
00003a  b120              CBZ      r0,|L14.70|
00003c  2801              CMP      r0,#1
00003e  d017              BEQ      |L14.112|
000040  2802              CMP      r0,#2
000042  d140              BNE      |L14.198|
000044  e02f              B        |L14.166|
                  |L14.70|
;;;1151       case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1152         //
;;;1153         // If we are in skip mode and there is no space for the whole
;;;1154         // of this output, don't bother switching terminals at all.
;;;1155         //
;;;1156         if (Avail < (FragLen + 4u)) {
000046  1d30              ADDS     r0,r6,#4
000048  4285              CMP      r5,r0
00004a  d201              BCS      |L14.80|
;;;1157           Status = 0;
00004c  2400              MOVS     r4,#0
00004e  e00e              B        |L14.110|
                  |L14.80|
;;;1158         } else {
;;;1159           _PostTerminalSwitch(pRing, TerminalId);
000050  4639              MOV      r1,r7
000052  4640              MOV      r0,r8
000054  f7fffffe          BL       _PostTerminalSwitch
;;;1160           Status = (int)_WriteBlocking(pRing, s, FragLen);
000058  4632              MOV      r2,r6
00005a  4649              MOV      r1,r9
00005c  4640              MOV      r0,r8
00005e  f7fffffe          BL       _WriteBlocking
000062  4604              MOV      r4,r0
;;;1161           _PostTerminalSwitch(pRing, _ActiveTerminal);
000064  481d              LDR      r0,|L14.220|
000066  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
000068  4640              MOV      r0,r8
00006a  f7fffffe          BL       _PostTerminalSwitch
                  |L14.110|
;;;1162         }
;;;1163         break;
00006e  e02d              B        |L14.204|
                  |L14.112|
;;;1164       case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1165         //
;;;1166         // If we are in trim mode and there is not enough space for everything,
;;;1167         // trim the output but always include the terminal switch.  If no room
;;;1168         // for terminal switch, skip that totally.
;;;1169         //
;;;1170         if (Avail < 4u) {
000070  2d04              CMP      r5,#4
000072  d202              BCS      |L14.122|
;;;1171           Status = -1;
000074  f04f34ff          MOV      r4,#0xffffffff
000078  e014              B        |L14.164|
                  |L14.122|
;;;1172         } else {
;;;1173           _PostTerminalSwitch(pRing, TerminalId);
00007a  4639              MOV      r1,r7
00007c  4640              MOV      r0,r8
00007e  f7fffffe          BL       _PostTerminalSwitch
;;;1174           Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
000082  1f28              SUBS     r0,r5,#4
000084  42b0              CMP      r0,r6
000086  d901              BLS      |L14.140|
000088  4630              MOV      r0,r6
00008a  e000              B        |L14.142|
                  |L14.140|
00008c  1f28              SUBS     r0,r5,#4
                  |L14.142|
00008e  4602              MOV      r2,r0
000090  4649              MOV      r1,r9
000092  4640              MOV      r0,r8
000094  f7fffffe          BL       _WriteBlocking
000098  4604              MOV      r4,r0
;;;1175           _PostTerminalSwitch(pRing, _ActiveTerminal);
00009a  4810              LDR      r0,|L14.220|
00009c  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
00009e  4640              MOV      r0,r8
0000a0  f7fffffe          BL       _PostTerminalSwitch
                  |L14.164|
;;;1176         }
;;;1177         break;
0000a4  e012              B        |L14.204|
                  |L14.166|
;;;1178       case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1179         //
;;;1180         // If we are in blocking mode, output everything.
;;;1181         //
;;;1182         _PostTerminalSwitch(pRing, TerminalId);
0000a6  4639              MOV      r1,r7
0000a8  4640              MOV      r0,r8
0000aa  f7fffffe          BL       _PostTerminalSwitch
;;;1183         Status = (int)_WriteBlocking(pRing, s, FragLen);
0000ae  4632              MOV      r2,r6
0000b0  4649              MOV      r1,r9
0000b2  4640              MOV      r0,r8
0000b4  f7fffffe          BL       _WriteBlocking
0000b8  4604              MOV      r4,r0
;;;1184         _PostTerminalSwitch(pRing, _ActiveTerminal);
0000ba  4808              LDR      r0,|L14.220|
0000bc  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000be  4640              MOV      r0,r8
0000c0  f7fffffe          BL       _PostTerminalSwitch
;;;1185         break;
0000c4  e002              B        |L14.204|
                  |L14.198|
;;;1186       default:
;;;1187         Status = -1;
0000c6  f04f34ff          MOV      r4,#0xffffffff
;;;1188         break;
0000ca  bf00              NOP      
                  |L14.204|
0000cc  e001              B        |L14.210|
                  |L14.206|
;;;1189       }
;;;1190       //
;;;1191       // Finish up.
;;;1192       //
;;;1193       SEGGER_RTT_UNLOCK();
;;;1194     } else {
;;;1195       Status = -1;
0000ce  f04f34ff          MOV      r4,#0xffffffff
                  |L14.210|
;;;1196     }
;;;1197     return Status;
0000d2  4620              MOV      r0,r4
;;;1198   }
0000d4  e8bd87f0          POP      {r4-r10,pc}
;;;1199   
                          ENDP

                  |L14.216|
                          DCD      _SEGGER_RTT
                  |L14.220|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_WaitKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WaitKey PROC
;;;753    */
;;;754    int SEGGER_RTT_WaitKey(void) {
000000  b510              PUSH     {r4,lr}
;;;755      int r;
;;;756    
;;;757      do {
000002  bf00              NOP      
                  |L15.4|
;;;758        r = SEGGER_RTT_GetKey();
000004  f7fffffe          BL       SEGGER_RTT_GetKey
;;;759      } while (r < 0);
000008  2800              CMP      r0,#0
00000a  dbfb              BLT      |L15.4|
;;;760      return r;
;;;761    }
00000c  bd10              POP      {r4,pc}
;;;762    
                          ENDP


                          AREA ||i.SEGGER_RTT_Write||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Write PROC
;;;665    */
;;;666    unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;667      unsigned Status;
;;;668      //
;;;669      INIT();
00000a  bf00              NOP      
00000c  4807              LDR      r0,|L16.44|
00000e  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000010  b908              CBNZ     r0,|L16.22|
000012  f7fffffe          BL       _DoInit
                  |L16.22|
000016  bf00              NOP      
;;;670      SEGGER_RTT_LOCK();
;;;671      //
;;;672      // Call the non-locking write function
;;;673      //
;;;674      Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
000018  4632              MOV      r2,r6
00001a  4629              MOV      r1,r5
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SEGGER_RTT_WriteNoLock
000022  4607              MOV      r7,r0
;;;675      //
;;;676      // Finish up.
;;;677      //
;;;678      SEGGER_RTT_UNLOCK();
;;;679      //
;;;680      return Status;
000024  4638              MOV      r0,r7
;;;681    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;682    
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_WriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteNoLock PROC
;;;594    */
;;;595    unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;596      unsigned              Status;
;;;597      unsigned              Avail;
;;;598      const char*           pData;
;;;599      SEGGER_RTT_BUFFER_UP* pRing;
;;;600    
;;;601      pData = (const char *)pBuffer;
00000a  46c2              MOV      r10,r8
;;;602      //
;;;603      // Get "to-host" ring buffer.
;;;604      //
;;;605      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  eb070147          ADD      r1,r7,r7,LSL #1
000010  481b              LDR      r0,|L17.128|
000012  eb0009c1          ADD      r9,r0,r1,LSL #3
;;;606      //
;;;607      // How we output depends upon the mode...
;;;608      //
;;;609      switch (pRing->Flags) {
000016  f8d90014          LDR      r0,[r9,#0x14]
00001a  b120              CBZ      r0,|L17.38|
00001c  2801              CMP      r0,#1
00001e  d011              BEQ      |L17.68|
000020  2802              CMP      r0,#2
000022  d126              BNE      |L17.114|
000024  e01e              B        |L17.100|
                  |L17.38|
;;;610      case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;611        //
;;;612        // If we are in skip mode and there is no space for the whole
;;;613        // of this output, don't bother.
;;;614        //
;;;615        Avail = _GetAvailWriteSpace(pRing);
000026  4648              MOV      r0,r9
000028  f7fffffe          BL       _GetAvailWriteSpace
00002c  4605              MOV      r5,r0
;;;616        if (Avail < NumBytes) {
00002e  42b5              CMP      r5,r6
000030  d201              BCS      |L17.54|
;;;617          Status = 0u;
000032  2400              MOVS     r4,#0
000034  e005              B        |L17.66|
                  |L17.54|
;;;618        } else {
;;;619          Status = NumBytes;
000036  4634              MOV      r4,r6
;;;620          _WriteNoCheck(pRing, pData, NumBytes);
000038  4632              MOV      r2,r6
00003a  4651              MOV      r1,r10
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       _WriteNoCheck
                  |L17.66|
;;;621        }
;;;622        break;
000042  e018              B        |L17.118|
                  |L17.68|
;;;623      case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;624        //
;;;625        // If we are in trim mode, trim to what we can output without blocking.
;;;626        //
;;;627        Avail = _GetAvailWriteSpace(pRing);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       _GetAvailWriteSpace
00004a  4605              MOV      r5,r0
;;;628        Status = Avail < NumBytes ? Avail : NumBytes;
00004c  42b5              CMP      r5,r6
00004e  d201              BCS      |L17.84|
000050  4628              MOV      r0,r5
000052  e000              B        |L17.86|
                  |L17.84|
000054  4630              MOV      r0,r6
                  |L17.86|
000056  4604              MOV      r4,r0
;;;629        _WriteNoCheck(pRing, pData, Status);
000058  4622              MOV      r2,r4
00005a  4651              MOV      r1,r10
00005c  4648              MOV      r0,r9
00005e  f7fffffe          BL       _WriteNoCheck
;;;630        break;
000062  e008              B        |L17.118|
                  |L17.100|
;;;631      case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;632        //
;;;633        // If we are in blocking mode, output everything.
;;;634        //
;;;635        Status = _WriteBlocking(pRing, pData, NumBytes);
000064  4632              MOV      r2,r6
000066  4651              MOV      r1,r10
000068  4648              MOV      r0,r9
00006a  f7fffffe          BL       _WriteBlocking
00006e  4604              MOV      r4,r0
;;;636        break;
000070  e001              B        |L17.118|
                  |L17.114|
;;;637      default:
;;;638        Status = 0u;
000072  2400              MOVS     r4,#0
;;;639        break;
000074  bf00              NOP      
                  |L17.118|
000076  bf00              NOP                            ;622
;;;640      }
;;;641      //
;;;642      // Finish up.
;;;643      //
;;;644      return Status;
000078  4620              MOV      r0,r4
;;;645    }
00007a  e8bd87f0          POP      {r4-r10,pc}
;;;646    
                          ENDP

00007e  0000              DCW      0x0000
                  |L17.128|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteSkipNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteSkipNoLock PROC
;;;484    */
;;;485    unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  4683              MOV      r11,r0
000006  4615              MOV      r5,r2
;;;486      const char*           pData;
;;;487      SEGGER_RTT_BUFFER_UP* pRing;
;;;488      unsigned              Avail;
;;;489      unsigned              RdOff;
;;;490      unsigned              WrOff;
;;;491      unsigned              Rem;
;;;492    
;;;493      pData = (const char *)pBuffer;
000008  f8dd9004          LDR      r9,[sp,#4]
;;;494      //
;;;495      // Get "to-host" ring buffer and copy some elements into local variables.
;;;496      //
;;;497      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  eb0b014b          ADD      r1,r11,r11,LSL #1
000010  4828              LDR      r0,|L18.180|
000012  eb0004c1          ADD      r4,r0,r1,LSL #3
;;;498      RdOff = pRing->RdOff;
000016  f8d4a010          LDR      r10,[r4,#0x10]
;;;499      WrOff = pRing->WrOff;
00001a  68e6              LDR      r6,[r4,#0xc]
;;;500      //
;;;501      // Handle the most common cases fastest.
;;;502      // Which is:
;;;503      //    RdOff <= WrOff -> Space until wrap around is free.
;;;504      //  AND
;;;505      //    WrOff + NumBytes < SizeOfBuffer -> No Wrap around necessary.
;;;506      //
;;;507      //  OR
;;;508      //
;;;509      //    RdOff > WrOff -> Space until RdOff - 1 is free.
;;;510      //  AND
;;;511      //    WrOff + NumBytes < RdOff -> Data fits into buffer
;;;512      //
;;;513      if (RdOff <= WrOff) {
00001c  45b2              CMP      r10,r6
00001e  d837              BHI      |L18.144|
;;;514        //
;;;515        // Get space until WrOff will be at wrap around.
;;;516        //
;;;517        Avail = pRing->SizeOfBuffer - 1u - WrOff ;
000020  68a0              LDR      r0,[r4,#8]
000022  1e40              SUBS     r0,r0,#1
000024  1b87              SUBS     r7,r0,r6
;;;518        if (Avail >= NumBytes) {
000026  42af              CMP      r7,r5
000028  d30f              BCC      |L18.74|
;;;519    #if 1 // memcpy() is good for large amounts of data, but the overhead is too big for small amounts. Use a simple byte loop instead.
;;;520          char* pDst;
;;;521          pDst = pRing->pBuffer + WrOff;
00002a  6860              LDR      r0,[r4,#4]
00002c  1981              ADDS     r1,r0,r6
;;;522          WrOff += NumBytes;
00002e  442e              ADD      r6,r6,r5
;;;523          do {
000030  bf00              NOP      
                  |L18.50|
;;;524            *pDst++ = *pData++;
000032  f8190b01          LDRB     r0,[r9],#1
000036  f8010b01          STRB     r0,[r1],#1
;;;525          } while (--NumBytes);
00003a  1e68              SUBS     r0,r5,#1
00003c  1e05              SUBS     r5,r0,#0
00003e  d1f8              BNE      |L18.50|
;;;526          pRing->WrOff = WrOff + NumBytes;
000040  1970              ADDS     r0,r6,r5
000042  60e0              STR      r0,[r4,#0xc]
;;;527    #else
;;;528          memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
;;;529          pRing->WrOff = WrOff + NumBytes;
;;;530    #endif
;;;531          return 1;
000044  2001              MOVS     r0,#1
                  |L18.70|
;;;532        }
;;;533        //
;;;534        // If data did not fit into space until wrap around calculate complete space in buffer.
;;;535        //
;;;536        Avail += RdOff;
;;;537        //
;;;538        // If there is still no space for the whole of this output, don't bother.
;;;539        //
;;;540        if (Avail >= NumBytes) {
;;;541          //
;;;542          //  OK, we have enough space in buffer. Copy in one or 2 chunks
;;;543          //
;;;544          Rem = pRing->SizeOfBuffer - WrOff;      // Space until end of buffer
;;;545          if (Rem > NumBytes) {
;;;546            memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
;;;547            pRing->WrOff = WrOff + NumBytes;
;;;548          } else {
;;;549            //
;;;550            // We reach the end of the buffer, so need to wrap around
;;;551            //
;;;552            memcpy(pRing->pBuffer + WrOff, pData, Rem);
;;;553            memcpy(pRing->pBuffer, pData + Rem, NumBytes - Rem);
;;;554            pRing->WrOff = NumBytes - Rem;
;;;555          }
;;;556          return 1;
;;;557        }
;;;558      } else {
;;;559        Avail = RdOff - WrOff - 1u;
;;;560        if (Avail >= NumBytes) {
;;;561          memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
;;;562          pRing->WrOff = WrOff + NumBytes;
;;;563          return 1;
;;;564        }
;;;565      }
;;;566      //
;;;567      // If we reach this point no data has been written
;;;568      //
;;;569      return 0;
;;;570    }
000046  e8bd8ffe          POP      {r1-r11,pc}
                  |L18.74|
00004a  4457              ADD      r7,r7,r10             ;536
00004c  42af              CMP      r7,r5                 ;540
00004e  d32e              BCC      |L18.174|
000050  68a0              LDR      r0,[r4,#8]            ;544
000052  eba00806          SUB      r8,r0,r6              ;544
000056  45a8              CMP      r8,r5                 ;545
000058  d908              BLS      |L18.108|
00005a  6861              LDR      r1,[r4,#4]            ;546
00005c  1988              ADDS     r0,r1,r6              ;546
00005e  462a              MOV      r2,r5                 ;546
000060  4649              MOV      r1,r9                 ;546
000062  f7fffffe          BL       __aeabi_memcpy
000066  1970              ADDS     r0,r6,r5              ;547
000068  60e0              STR      r0,[r4,#0xc]          ;547
00006a  e00f              B        |L18.140|
                  |L18.108|
00006c  6861              LDR      r1,[r4,#4]            ;552
00006e  1988              ADDS     r0,r1,r6              ;552
000070  4642              MOV      r2,r8                 ;552
000072  4649              MOV      r1,r9                 ;552
000074  f7fffffe          BL       __aeabi_memcpy
000078  eba50208          SUB      r2,r5,r8              ;553
00007c  eb090108          ADD      r1,r9,r8              ;553
000080  6860              LDR      r0,[r4,#4]            ;553
000082  f7fffffe          BL       __aeabi_memcpy
000086  eba50008          SUB      r0,r5,r8              ;554
00008a  60e0              STR      r0,[r4,#0xc]          ;554
                  |L18.140|
00008c  2001              MOVS     r0,#1                 ;556
00008e  e7da              B        |L18.70|
                  |L18.144|
000090  ebaa0006          SUB      r0,r10,r6             ;559
000094  1e47              SUBS     r7,r0,#1              ;559
000096  42af              CMP      r7,r5                 ;560
000098  d309              BCC      |L18.174|
00009a  6861              LDR      r1,[r4,#4]            ;561
00009c  1988              ADDS     r0,r1,r6              ;561
00009e  462a              MOV      r2,r5                 ;561
0000a0  4649              MOV      r1,r9                 ;561
0000a2  f7fffffe          BL       __aeabi_memcpy
0000a6  1970              ADDS     r0,r6,r5              ;562
0000a8  60e0              STR      r0,[r4,#0xc]          ;562
0000aa  2001              MOVS     r0,#1                 ;563
0000ac  e7cb              B        |L18.70|
                  |L18.174|
0000ae  2000              MOVS     r0,#0                 ;569
0000b0  e7c9              B        |L18.70|
;;;571    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L18.180|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteString||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WriteString PROC
;;;703    */
;;;704    unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;705      unsigned Len;
;;;706    
;;;707      Len = STRLEN(s);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       strlen
00000c  4606              MOV      r6,r0
;;;708      return SEGGER_RTT_Write(BufferIndex, s, Len);
00000e  4632              MOV      r2,r6
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SEGGER_RTT_Write
;;;709    }
000018  bd70              POP      {r4-r6,pc}
;;;710    
                          ENDP


                          AREA ||i._DoInit||, CODE, READONLY, ALIGN=2

                  _DoInit PROC
;;;170                    } while (0)
;;;171    static void _DoInit(void) {
000000  b510              PUSH     {r4,lr}
;;;172      SEGGER_RTT_CB* p;
;;;173      //
;;;174      // Initialize control block
;;;175      //
;;;176      p = &_SEGGER_RTT;
000002  4c12              LDR      r4,|L20.76|
;;;177      p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
000004  2002              MOVS     r0,#2
000006  6120              STR      r0,[r4,#0x10]
;;;178      p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
000008  6160              STR      r0,[r4,#0x14]
;;;179      //
;;;180      // Initialize up buffer 0
;;;181      //
;;;182      p->aUp[0].sName         = "Terminal";
00000a  a011              ADR      r0,|L20.80|
00000c  61a0              STR      r0,[r4,#0x18]
;;;183      p->aUp[0].pBuffer       = _acUpBuffer;
00000e  4913              LDR      r1,|L20.92|
000010  61e1              STR      r1,[r4,#0x1c]
;;;184      p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
000012  f44f6180          MOV      r1,#0x400
000016  6221              STR      r1,[r4,#0x20]
;;;185      p->aUp[0].RdOff         = 0u;
000018  2100              MOVS     r1,#0
00001a  62a1              STR      r1,[r4,#0x28]
;;;186      p->aUp[0].WrOff         = 0u;
00001c  6261              STR      r1,[r4,#0x24]
;;;187      p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
00001e  62e1              STR      r1,[r4,#0x2c]
;;;188      //
;;;189      // Initialize down buffer 0
;;;190      //
;;;191      p->aDown[0].sName         = "Terminal";
000020  a00b              ADR      r0,|L20.80|
000022  64a0              STR      r0,[r4,#0x48]
;;;192      p->aDown[0].pBuffer       = _acDownBuffer;
000024  490e              LDR      r1,|L20.96|
000026  64e1              STR      r1,[r4,#0x4c]
;;;193      p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
000028  2110              MOVS     r1,#0x10
00002a  6521              STR      r1,[r4,#0x50]
;;;194      p->aDown[0].RdOff         = 0u;
00002c  2100              MOVS     r1,#0
00002e  65a1              STR      r1,[r4,#0x58]
;;;195      p->aDown[0].WrOff         = 0u;
000030  6561              STR      r1,[r4,#0x54]
;;;196      p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
000032  65e1              STR      r1,[r4,#0x5c]
;;;197      //
;;;198      // Finish initialization of the control block.
;;;199      // Copy Id string in three steps to make sure "SEGGER RTT" is not found
;;;200      // in initializer memory (usually flash) by J-Link
;;;201      //
;;;202      strcpy(&p->acID[7], "RTT");
000034  a10b              ADR      r1,|L20.100|
000036  1de0              ADDS     r0,r4,#7
000038  f7fffffe          BL       strcpy
;;;203      strcpy(&p->acID[0], "SEGGER");
00003c  a10a              ADR      r1,|L20.104|
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       strcpy
;;;204      p->acID[6] = ' ';
000044  2020              MOVS     r0,#0x20
000046  71a0              STRB     r0,[r4,#6]
;;;205    }
000048  bd10              POP      {r4,pc}
;;;206    
                          ENDP

00004a  0000              DCW      0x0000
                  |L20.76|
                          DCD      _SEGGER_RTT
                  |L20.80|
000050  5465726d          DCB      "Terminal",0
000054  696e616c
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L20.92|
                          DCD      _acUpBuffer
                  |L20.96|
                          DCD      _acDownBuffer
                  |L20.100|
000064  52545400          DCB      "RTT",0
                  |L20.104|
000068  53454747          DCB      "SEGGER",0
00006c  455200  
00006f  00                DCB      0

                          AREA ||i._GetAvailWriteSpace||, CODE, READONLY, ALIGN=1

                  _GetAvailWriteSpace PROC
;;;336    */
;;;337    static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;338      unsigned RdOff;
;;;339      unsigned WrOff;
;;;340      unsigned r;
;;;341      //
;;;342      // Avoid warnings regarding volatile access order.  It's not a problem
;;;343      // in this case, but dampen compiler enthusiasm.
;;;344      //
;;;345      RdOff = pRing->RdOff;
000004  690a              LDR      r2,[r1,#0x10]
;;;346      WrOff = pRing->WrOff;
000006  68cb              LDR      r3,[r1,#0xc]
;;;347      if (RdOff <= WrOff) {
000008  429a              CMP      r2,r3
00000a  d804              BHI      |L21.22|
;;;348        r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
00000c  688c              LDR      r4,[r1,#8]
00000e  1e64              SUBS     r4,r4,#1
000010  1ae4              SUBS     r4,r4,r3
000012  18a0              ADDS     r0,r4,r2
000014  e001              B        |L21.26|
                  |L21.22|
;;;349      } else {
;;;350        r = RdOff - WrOff - 1u;
000016  1ad4              SUBS     r4,r2,r3
000018  1e60              SUBS     r0,r4,#1
                  |L21.26|
;;;351      }
;;;352      return r;
;;;353    }
00001a  bd10              POP      {r4,pc}
;;;354    
                          ENDP


                          AREA ||i._PostTerminalSwitch||, CODE, READONLY, ALIGN=2

                  _PostTerminalSwitch PROC
;;;314    */
;;;315    static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
000000  b538              PUSH     {r3-r5,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;316      char ac[2];
;;;317    
;;;318      ac[0] = 0xFFu;
000006  20ff              MOVS     r0,#0xff
000008  f88d0000          STRB     r0,[sp,#0]
;;;319      ac[1] = _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
00000c  4804              LDR      r0,|L22.32|
00000e  5d00              LDRB     r0,[r0,r4]
000010  f88d0001          STRB     r0,[sp,#1]
;;;320      _WriteBlocking(pRing, ac, 2u);
000014  2202              MOVS     r2,#2
000016  4669              MOV      r1,sp
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       _WriteBlocking
;;;321    }
00001e  bd38              POP      {r3-r5,pc}
;;;322    
                          ENDP

                  |L22.32|
                          DCD      _aTerminalId

                          AREA ||i._WriteBlocking||, CODE, READONLY, ALIGN=1

                  _WriteBlocking PROC
;;;225    */
;;;226    static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;227      unsigned NumBytesToWrite;
;;;228      unsigned NumBytesWritten;
;;;229      unsigned RdOff;
;;;230      unsigned WrOff;
;;;231      //
;;;232      // Write data to buffer and handle wrap-around if necessary
;;;233      //
;;;234      NumBytesWritten = 0u;
00000a  f04f0a00          MOV      r10,#0
;;;235      WrOff = pRing->WrOff;
00000e  68e5              LDR      r5,[r4,#0xc]
;;;236      do {
000010  bf00              NOP      
                  |L23.18|
;;;237        RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
000012  f8d48010          LDR      r8,[r4,#0x10]
;;;238        if (RdOff > WrOff) {
000016  45a8              CMP      r8,r5
000018  d903              BLS      |L23.34|
;;;239          NumBytesToWrite = RdOff - WrOff - 1u;
00001a  eba80005          SUB      r0,r8,r5
00001e  1e46              SUBS     r6,r0,#1
000020  e004              B        |L23.44|
                  |L23.34|
;;;240        } else {
;;;241          NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
000022  eba50008          SUB      r0,r5,r8
000026  1c40              ADDS     r0,r0,#1
000028  68a1              LDR      r1,[r4,#8]
00002a  1a0e              SUBS     r6,r1,r0
                  |L23.44|
;;;242        }
;;;243        NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
00002c  68a0              LDR      r0,[r4,#8]
00002e  1b40              SUBS     r0,r0,r5
000030  42b0              CMP      r0,r6
000032  d901              BLS      |L23.56|
000034  4630              MOV      r0,r6
000036  e001              B        |L23.60|
                  |L23.56|
000038  68a0              LDR      r0,[r4,#8]
00003a  1b40              SUBS     r0,r0,r5
                  |L23.60|
00003c  4606              MOV      r6,r0
;;;244        NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
00003e  42be              CMP      r6,r7
000040  d201              BCS      |L23.70|
000042  4630              MOV      r0,r6
000044  e000              B        |L23.72|
                  |L23.70|
000046  4638              MOV      r0,r7
                  |L23.72|
000048  4606              MOV      r6,r0
;;;245        memcpy(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
00004a  6861              LDR      r1,[r4,#4]
00004c  1948              ADDS     r0,r1,r5
00004e  4632              MOV      r2,r6
000050  4649              MOV      r1,r9
000052  f7fffffe          BL       __aeabi_memcpy
;;;246        NumBytesWritten += NumBytesToWrite;
000056  44b2              ADD      r10,r10,r6
;;;247        pBuffer         += NumBytesToWrite;
000058  44b1              ADD      r9,r9,r6
;;;248        NumBytes        -= NumBytesToWrite;
00005a  1bbf              SUBS     r7,r7,r6
;;;249        WrOff           += NumBytesToWrite;
00005c  4435              ADD      r5,r5,r6
;;;250        if (WrOff == pRing->SizeOfBuffer) {
00005e  68a0              LDR      r0,[r4,#8]
000060  42a8              CMP      r0,r5
000062  d100              BNE      |L23.102|
;;;251          WrOff = 0u;
000064  2500              MOVS     r5,#0
                  |L23.102|
;;;252        }
;;;253        pRing->WrOff = WrOff;
000066  60e5              STR      r5,[r4,#0xc]
;;;254      } while (NumBytes);
000068  2f00              CMP      r7,#0
00006a  d1d2              BNE      |L23.18|
;;;255      //
;;;256      return NumBytesWritten;
00006c  4650              MOV      r0,r10
;;;257    }
00006e  e8bd87f0          POP      {r4-r10,pc}
;;;258    
                          ENDP


                          AREA ||i._WriteNoCheck||, CODE, READONLY, ALIGN=1

                  _WriteNoCheck PROC
;;;276    */
;;;277    static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;278      unsigned NumBytesAtOnce;
;;;279      unsigned WrOff;
;;;280      unsigned Rem;
;;;281    
;;;282      WrOff = pRing->WrOff;
00000a  68e6              LDR      r6,[r4,#0xc]
;;;283      Rem = pRing->SizeOfBuffer - WrOff;
00000c  68a0              LDR      r0,[r4,#8]
00000e  1b87              SUBS     r7,r0,r6
;;;284      if (Rem > NumBytes) {
000010  42af              CMP      r7,r5
000012  d908              BLS      |L24.38|
;;;285        //
;;;286        // All data fits before wrap around
;;;287        //
;;;288        memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
000014  6861              LDR      r1,[r4,#4]
000016  1988              ADDS     r0,r1,r6
000018  462a              MOV      r2,r5
00001a  4649              MOV      r1,r9
00001c  f7fffffe          BL       __aeabi_memcpy
;;;289        pRing->WrOff = WrOff + NumBytes;
000020  1970              ADDS     r0,r6,r5
000022  60e0              STR      r0,[r4,#0xc]
000024  e010              B        |L24.72|
                  |L24.38|
;;;290      } else {
;;;291        //
;;;292        // We reach the end of the buffer, so need to wrap around
;;;293        //
;;;294        NumBytesAtOnce = Rem;
000026  46b8              MOV      r8,r7
;;;295        memcpy(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
000028  6861              LDR      r1,[r4,#4]
00002a  1988              ADDS     r0,r1,r6
00002c  4642              MOV      r2,r8
00002e  4649              MOV      r1,r9
000030  f7fffffe          BL       __aeabi_memcpy
;;;296        NumBytesAtOnce = NumBytes - Rem;
000034  eba50807          SUB      r8,r5,r7
;;;297        memcpy(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
000038  eb090107          ADD      r1,r9,r7
00003c  4642              MOV      r2,r8
00003e  6860              LDR      r0,[r4,#4]
000040  f7fffffe          BL       __aeabi_memcpy
;;;298        pRing->WrOff = NumBytesAtOnce;
000044  f8c4800c          STR      r8,[r4,#0xc]
                  |L24.72|
;;;299      }
;;;300    }
000048  e8bd87f0          POP      {r4-r10,pc}
;;;301    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _acUpBuffer
                          %        1024
                  _acDownBuffer
                          %        16
                  _SEGGER_RTT
                          %        120

                          AREA ||.data||, DATA, ALIGN=0

                  _aTerminalId
000000  30313233          DCB      0x30,0x31,0x32,0x33
000004  34353637          DCB      0x34,0x35,0x36,0x37
000008  38394142          DCB      0x38,0x39,0x41,0x42
00000c  43444546          DCB      0x43,0x44,0x45,0x46
                  _ActiveTerminal
000010  00                DCB      0x00
