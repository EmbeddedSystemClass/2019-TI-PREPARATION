L 1 "..\..\User\SEGGER\SEGGER_SYSVIEW.c"
N/*********************************************************************
N*                SEGGER Microcontroller GmbH & Co. KG                *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*       (c) 2015 - 2016  SEGGER Microcontroller GmbH & Co. KG        *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER SystemView * Real-time application analysis           *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* conditions are met:                                                *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this list of conditions and the following disclaimer.    *
N*                                                                    *
N* o Redistributions in binary form must reproduce the above          *
N*   copyright notice, this list of conditions and the following      *
N*   disclaimer in the documentation and/or other materials provided  *
N*   with the distribution.                                           *
N*                                                                    *
N* o Neither the name of SEGGER Microcontroller GmbH & Co. KG         *
N*   nor the names of its contributors may be used to endorse or      *
N*   promote products derived from this software without specific     *
N*   prior written permission.                                        *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SystemView version: V2.40a                                    *
N*                                                                    *
N**********************************************************************
N-------------------------- END-OF-HEADER -----------------------------
N
NFile    : SEGGER_SYSVIEW.c
NPurpose : System visualization API implementation.
NRevision: $Rev: 4039 $
N
NAdditional information:
N  Packet format:
N    Packets with IDs 0..23 are standard packets with known structure.
N    For efficiency, they do *NOT* contain a length field.
N    <ID><Data><TimeStampDelta>
N
N    Packets with IDs 24..31 are standard packets with extendible
N    structure and contain a length field.
N    <ID><Lenght><Data><TimeStampDelta>
N
N    Packets with IDs >= 32 always contain a length field.
N    <ID><Length><Data><TimeStampDelta>
N
N  Packet IDs:
N       0..  31 : Standard packets, known by SystemViewer.
N      32..1023 : OS-definable packets, described in a SystemView description file.
N    1024..2047 : User-definable packets, described in a SystemView description file.
N    2048..32767: Undefined.
N
N  Data encoding:
N    Basic types (int, short, char, ...):
N      Basic types are encoded little endian with most-significant bit variant
N      encoding.
N      Each encoded byte contains 7 data bits [6:0] and the MSB continuation bit.
N      The continuation bit indicates whether the next byte belongs to the data
N      (bit set) or this is the last byte (bit clear).
N      The most significant bits of data are encoded first, proceeding to the
N      least significant bits in the final byte (little endian).
N
N      Example encoding:
N        Data: 0x1F4 (500)
N        Encoded: 0xF4 (First 7 data bits 74 | Continuation bit)
N                 0x03 (Second 7 data bits 03, no continuation)
N
N        Data: 0xFFFFFFFF
N        Encoded: 0xFF 0xFF 0xFF 0xFF 0x0F
N
N        Data: 0xA2 (162),   0x03 (3), 0x7000
N        Encoded: 0xA2 0x01  0x03      0x80 0xE0 0x01
N
N    Byte arrays and strings:
N      Byte arrays and strings are encoded as <NumBytes> followed by the raw data.
N      NumBytes is encoded as a basic type with a theoretical maximum of 4G.
N
N      Example encoding:
N        Data: "Hello World\0" (0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F 0x72 0x6C 0x64 0x00)
N        Encoded: 0x0B 0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F 0x72 0x6C 0x64
N
N  Examples packets:
N  01 F4 03 80 80 10 // Overflow packet. Data is a single U32.
N                       This packet means: 500 packets lost, Timestamp is 0x40000
N
N  02 0F 50          // ISR(15) Enter. Timestamp 80 (0x50)
N
N  03 20             // ISR Exit. Timestamp 32 (0x20) (Shortest possible packet.)
N
N  Sample code for user defined Packets:
N    #define MY_ID   0x400                // Any value between 0x400 and 0x7FF
N    void SendMyPacket(unsigned Para0, unsigned Para1, const char* s) {
N      U8  aPacket[SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + MAX_STR_LEN + 1];
N      U8* pPayload;
N      //
N      pPayload = SEGGER_SYSVIEW_PPREPARE_PACKET(aPacket);               // Prepare the packet for SystemView
N      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para0);             // Add the first parameter to the packet
N      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para1);             // Add the second parameter to the packet
N      pPayload = SEGGER_SYSVIEW_EncodeString(pPayload, s, MAX_STR_LEN); // Add the string to the packet
N      //
N      SEGGER_SYSVIEW_SendPacket(&aPacket[0], pPayload, MY_ID);          // Send the packet with EventId = MY_ID
N    }
N
N    #define MY_ID_1 0x401
N    void SendOnePara(unsigned Para0) {
N      SEGGER_SYSVIEW_RecordU32(MY_ID_1, Para0);
N    }
N
N*/
N
N/*********************************************************************
N*
N*       #include section
N*
N**********************************************************************
N*/
N
N#include "SEGGER_SYSVIEW_Int.h"
L 1 "..\..\User\SEGGER\SEGGER_SYSVIEW_Int.h" 1
N/*********************************************************************
N*                SEGGER Microcontroller GmbH & Co. KG                *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*       (c) 2015 - 2016  SEGGER Microcontroller GmbH & Co. KG        *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER SystemView * Real-time application analysis           *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* conditions are met:                                                *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this list of conditions and the following disclaimer.    *
N*                                                                    *
N* o Redistributions in binary form must reproduce the above          *
N*   copyright notice, this list of conditions and the following      *
N*   disclaimer in the documentation and/or other materials provided  *
N*   with the distribution.                                           *
N*                                                                    *
N* o Neither the name of SEGGER Microcontroller GmbH & Co. KG         *
N*   nor the names of its contributors may be used to endorse or      *
N*   promote products derived from this software without specific     *
N*   prior written permission.                                        *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SystemView version: V2.40a                                    *
N*                                                                    *
N**********************************************************************
N-------------------------- END-OF-HEADER -----------------------------
NFile    : SEGGER_SYSVIEW_Int.h
NPurpose : SEGGER SystemView internal header.
NRevision: $Rev: 3734 $
N*/
N
N#ifndef SEGGER_SYSVIEW_INT_H
N#define SEGGER_SYSVIEW_INT_H
N
N/*********************************************************************
N*
N*       #include Section
N*
N**********************************************************************
N*/
N
N#include "SEGGER_SYSVIEW.h"
L 1 "..\..\User\SEGGER\SEGGER_SYSVIEW.h" 1
N/*********************************************************************
N*                SEGGER Microcontroller GmbH & Co. KG                *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*       (c) 2015 - 2016  SEGGER Microcontroller GmbH & Co. KG        *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER SystemView * Real-time application analysis           *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* conditions are met:                                                *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this list of conditions and the following disclaimer.    *
N*                                                                    *
N* o Redistributions in binary form must reproduce the above          *
N*   copyright notice, this list of conditions and the following      *
N*   disclaimer in the documentation and/or other materials provided  *
N*   with the distribution.                                           *
N*                                                                    *
N* o Neither the name of SEGGER Microcontroller GmbH & Co. KG         *
N*   nor the names of its contributors may be used to endorse or      *
N*   promote products derived from this software without specific     *
N*   prior written permission.                                        *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SystemView version: V2.40a                                    *
N*                                                                    *
N**********************************************************************
N-------------------------- END-OF-HEADER -----------------------------
NFile    : SEGGER_SYSVIEW.h
NPurpose : System visualization API.
NRevision: $Rev: 3807 $
N*/
N
N#ifndef SEGGER_SYSVIEW_H
N#define SEGGER_SYSVIEW_H
N
N/*********************************************************************
N*
N*       #include Section
N*
N**********************************************************************
N*/
N
N#include "SEGGER.h"
L 1 "..\..\User\SEGGER\SEGGER.h" 1
N/*********************************************************************
N*                SEGGER Microcontroller GmbH & Co. KG                *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*       (c) 2015 - 2016  SEGGER Microcontroller GmbH & Co. KG        *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER SystemView * Real-time application analysis           *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* conditions are met:                                                *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this list of conditions and the following disclaimer.    *
N*                                                                    *
N* o Redistributions in binary form must reproduce the above          *
N*   copyright notice, this list of conditions and the following      *
N*   disclaimer in the documentation and/or other materials provided  *
N*   with the distribution.                                           *
N*                                                                    *
N* o Neither the name of SEGGER Microcontroller GmbH & Co. KG         *
N*   nor the names of its contributors may be used to endorse or      *
N*   promote products derived from this software without specific     *
N*   prior written permission.                                        *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SystemView version: V2.40a                                    *
N*                                                                    *
N**********************************************************************
N----------------------------------------------------------------------
NFile    : SEGGER.h
NPurpose : Global types etc & general purpose utility functions
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef SEGGER_H            // Guard against multiple inclusion
N#define SEGGER_H
N
N#include "Global.h"         // Type definitions: U8, U16, U32, I8, I16, I32
L 1 "..\..\User\SEGGER\Global.h" 1
N/*********************************************************************
N*                SEGGER Microcontroller GmbH & Co. KG                *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*       (c) 2015 - 2016  SEGGER Microcontroller GmbH & Co. KG        *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER SystemView * Real-time application analysis           *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* conditions are met:                                                *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this list of conditions and the following disclaimer.    *
N*                                                                    *
N* o Redistributions in binary form must reproduce the above          *
N*   copyright notice, this list of conditions and the following      *
N*   disclaimer in the documentation and/or other materials provided  *
N*   with the distribution.                                           *
N*                                                                    *
N* o Neither the name of SEGGER Microcontroller GmbH & Co. KG         *
N*   nor the names of its contributors may be used to endorse or      *
N*   promote products derived from this software without specific     *
N*   prior written permission.                                        *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SystemView version: V2.40a                                    *
N*                                                                    *
N**********************************************************************
N----------------------------------------------------------------------
NFile    : Global.h
NPurpose : Global types
N          In case your application already has a Global.h, you should
N          merge the files. In order to use Segger code, the types
N          U8, U16, U32, I8, I16, I32 need to be defined in Global.h;
N          additional definitions do not hurt.
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GLOBAL_H            // Guard against multiple inclusion
N#define GLOBAL_H
N
N#define U8    unsigned char
N#define U16   unsigned short
N#define U32   unsigned long
N#define I8    signed char
N#define I16   signed short
N#define I32   signed long
N
N#ifdef _WIN32
S  //
S  // Microsoft VC6 compiler related
S  //
S  #define U64   unsigned __int64
S  #define U128  unsigned __int128
S  #define I64   __int64
S  #define I128  __int128
S  #if _MSC_VER <= 1200
S    #define U64_C(x) x##UI64
S  #else
S    #define U64_C(x) x##ULL
S  #endif
N#else 
N  //
N  // C99 compliant compiler
N  //
N  #define U64   unsigned long long
N  #define I64   signed long long
N  #define U64_C(x) x##ULL
N#endif
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 68 "..\..\User\SEGGER\SEGGER.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Keywords/specifiers
N*
N**********************************************************************
N*/
N
N#ifndef INLINE
N  #ifdef _WIN32
S    //
S    // Microsoft VC6 and newer.
S    // Force inlining without cost checking.
S    //
S    #define INLINE  __forceinline
N  #else
N    #if (defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__) || defined(__RX) || defined(__ICCRX__))
X    #if (0L || 1L || 0L || 0L || 0L)
N      //
N      // Other known compilers.
N      //
N      #define INLINE  inline
N    #else
S      //
S      // Unknown compilers.
S      //
S      #define INLINE
N    #endif
N  #endif
N#endif
N
N/*********************************************************************
N*
N*       Function-like macros
N*
N**********************************************************************
N*/
N
N#define SEGGER_COUNTOF(a)          (sizeof((a))/sizeof((a)[0]))
N#define SEGGER_MIN(a,b)            (((a) < (b)) ? (a) : (b))
N#define SEGGER_MAX(a,b)            (((a) > (b)) ? (a) : (b))
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  char *pBuffer;
N  int   BufferSize;
N  int   Cnt;
N} SEGGER_BUFFER_DESC;
N
Ntypedef struct {
N  int  CacheLineSize;                                // 0: No Cache. Most Systems such as ARM9 use a 32 bytes cache line size.
N  void (*pfDMB)       (void);                        // Optional DMB function for Data Memory Barrier to make sure all memory operations are completed.
N  void (*pfClean)     (void *p, unsigned NumBytes);  // Optional clean function for cached memory.
N  void (*pfInvalidate)(void *p, unsigned NumBytes);  // Optional invalidate function for cached memory.
N} SEGGER_CACHE_CONFIG;
N
N/*********************************************************************
N*
N*       Utility functions
N*
N**********************************************************************
N*/
N
Nvoid SEGGER_ARM_memcpy   (void *pDest, const void *pSrc, int NumBytes);
Nvoid SEGGER_memcpy       (void *pDest, const void *pSrc, int NumBytes);
Nvoid SEGGER_memxor       (void *pDest, const void *pSrc, unsigned NumBytes);
Nvoid SEGGER_StoreChar    (SEGGER_BUFFER_DESC *p, char c);
Nvoid SEGGER_PrintUnsigned(SEGGER_BUFFER_DESC *pBufferDesc, U32 v, unsigned Base, int NumDigits);
Xvoid SEGGER_PrintUnsigned(SEGGER_BUFFER_DESC *pBufferDesc, unsigned long v, unsigned Base, int NumDigits);
Nvoid SEGGER_PrintInt     (SEGGER_BUFFER_DESC *pBufferDesc, I32 v, unsigned Base, unsigned NumDigits);
Xvoid SEGGER_PrintInt     (SEGGER_BUFFER_DESC *pBufferDesc, signed long v, unsigned Base, unsigned NumDigits);
Nint  SEGGER_snprintf     (char *pBuffer, int BufferSize, const char *sFormat, ...);
N
N
N#if defined(__cplusplus)
X#if 0L
S}                /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 75 "..\..\User\SEGGER\SEGGER_SYSVIEW.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/*********************************************************************
N*
N*       Defines, fixed
N*
N**********************************************************************
N*/
N
N#define SEGGER_SYSVIEW_VERSION        21000
N
N#define SEGGER_SYSVIEW_INFO_SIZE      9   // Minimum size, which has to be reserved for a packet. 1-2 byte of message type, 0-2  byte of payload length, 1-5 bytes of timestamp.
N#define SEGGER_SYSVIEW_QUANTA_U32     5   // Maximum number of bytes to encode a U32, should be reserved for each 32-bit value in a packet.
N
N#define SEGGER_SYSVIEW_LOG            (0u)
N#define SEGGER_SYSVIEW_WARNING        (1u)
N#define SEGGER_SYSVIEW_ERROR          (2u)
N#define SEGGER_SYSVIEW_FLAG_APPEND    (1u << 6)
N
N#define SEGGER_SYSVIEW_PREPARE_PACKET(p)  (p) + 4
N//
N// SystemView events. First 32 IDs from 0 .. 31 are reserved for these
N//
N#define   SYSVIEW_EVTID_NOP                0  // Dummy packet.
N#define   SYSVIEW_EVTID_OVERFLOW           1
N#define   SYSVIEW_EVTID_ISR_ENTER          2
N#define   SYSVIEW_EVTID_ISR_EXIT           3
N#define   SYSVIEW_EVTID_TASK_START_EXEC    4
N#define   SYSVIEW_EVTID_TASK_STOP_EXEC     5
N#define   SYSVIEW_EVTID_TASK_START_READY   6
N#define   SYSVIEW_EVTID_TASK_STOP_READY    7
N#define   SYSVIEW_EVTID_TASK_CREATE        8
N#define   SYSVIEW_EVTID_TASK_INFO          9
N#define   SYSVIEW_EVTID_TRACE_START       10
N#define   SYSVIEW_EVTID_TRACE_STOP        11
N#define   SYSVIEW_EVTID_SYSTIME_CYCLES    12
N#define   SYSVIEW_EVTID_SYSTIME_US        13
N#define   SYSVIEW_EVTID_SYSDESC           14
N#define   SYSVIEW_EVTID_USER_START        15
N#define   SYSVIEW_EVTID_USER_STOP         16
N#define   SYSVIEW_EVTID_IDLE              17
N#define   SYSVIEW_EVTID_ISR_TO_SCHEDULER  18
N#define   SYSVIEW_EVTID_TIMER_ENTER       19
N#define   SYSVIEW_EVTID_TIMER_EXIT        20
N#define   SYSVIEW_EVTID_STACK_INFO        21
N#define   SYSVIEW_EVTID_MODULEDESC        22
N
N#define   SYSVIEW_EVTID_INIT              24
N#define   SYSVIEW_EVTID_NAME_RESOURCE     25
N#define   SYSVIEW_EVTID_PRINT_FORMATTED   26
N#define   SYSVIEW_EVTID_NUMMODULES        27
N#define   SYSVIEW_EVTID_END_CALL          28
N#define   SYSVIEW_EVTID_TASK_TERMINATE    29
N
N#define   SYSVIEW_EVTID_EX                31
N//
N// Event masks to disable/enable events
N//
N#define   SYSVIEW_EVTMASK_NOP               (1 << SYSVIEW_EVTID_NOP)
N#define   SYSVIEW_EVTMASK_OVERFLOW          (1 << SYSVIEW_EVTID_OVERFLOW)
N#define   SYSVIEW_EVTMASK_ISR_ENTER         (1 << SYSVIEW_EVTID_ISR_ENTER)
N#define   SYSVIEW_EVTMASK_ISR_EXIT          (1 << SYSVIEW_EVTID_ISR_EXIT)
N#define   SYSVIEW_EVTMASK_TASK_START_EXEC   (1 << SYSVIEW_EVTID_TASK_START_EXEC)
N#define   SYSVIEW_EVTMASK_TASK_STOP_EXEC    (1 << SYSVIEW_EVTID_TASK_STOP_EXEC)
N#define   SYSVIEW_EVTMASK_TASK_START_READY  (1 << SYSVIEW_EVTID_TASK_START_READY)
N#define   SYSVIEW_EVTMASK_TASK_STOP_READY   (1 << SYSVIEW_EVTID_TASK_STOP_READY)
N#define   SYSVIEW_EVTMASK_TASK_CREATE       (1 << SYSVIEW_EVTID_TASK_CREATE)
N#define   SYSVIEW_EVTMASK_TASK_INFO         (1 << SYSVIEW_EVTID_TASK_INFO)
N#define   SYSVIEW_EVTMASK_TRACE_START       (1 << SYSVIEW_EVTID_TRACE_START)
N#define   SYSVIEW_EVTMASK_TRACE_STOP        (1 << SYSVIEW_EVTID_TRACE_STOP)
N#define   SYSVIEW_EVTMASK_SYSTIME_CYCLES    (1 << SYSVIEW_EVTID_SYSTIME_CYCLES)
N#define   SYSVIEW_EVTMASK_SYSTIME_US        (1 << SYSVIEW_EVTID_SYSTIME_US)
N#define   SYSVIEW_EVTMASK_SYSDESC           (1 << SYSVIEW_EVTID_SYSDESC)
N#define   SYSVIEW_EVTMASK_USER_START        (1 << SYSVIEW_EVTID_USER_START)
N#define   SYSVIEW_EVTMASK_USER_STOP         (1 << SYSVIEW_EVTID_USER_STOP)
N#define   SYSVIEW_EVTMASK_IDLE              (1 << SYSVIEW_EVTID_IDLE)
N#define   SYSVIEW_EVTMASK_ISR_TO_SCHEDULER  (1 << SYSVIEW_EVTID_ISR_TO_SCHEDULER)
N#define   SYSVIEW_EVTMASK_TIMER_ENTER       (1 << SYSVIEW_EVTID_TIMER_ENTER)
N#define   SYSVIEW_EVTMASK_TIMER_EXIT        (1 << SYSVIEW_EVTID_TIMER_EXIT)
N#define   SYSVIEW_EVTMASK_STACK_INFO        (1 << SYSVIEW_EVTID_STACK_INFO)
N#define   SYSVIEW_EVTMASK_MODULEDESC        (1 << SYSVIEW_EVTID_MODULEDESC)
N
N#define   SYSVIEW_EVTMASK_INIT              (1 << SYSVIEW_EVTID_INIT)
N#define   SYSVIEW_EVTMASK_NAME_RESOURCE     (1 << SYSVIEW_EVTID_NAME_RESOURCE)
N#define   SYSVIEW_EVTMASK_PRINT_FORMATTED   (1 << SYSVIEW_EVTID_PRINT_FORMATTED)
N#define   SYSVIEW_EVTMASK_NUMMODULES        (1 << SYSVIEW_EVTID_NUMMODULES)
N#define   SYSVIEW_EVTMASK_END_CALL          (1 << SYSVIEW_EVTID_END_CALL)
N#define   SYSVIEW_EVTMASK_TASK_TERMINATE    (1 << SYSVIEW_EVTID_TASK_TERMINATE)
N
N#define   SYSVIEW_EVTMASK_EX                (1 << SYSVIEW_EVTID_EX)
N
N#define   SYSVIEW_EVTMASK_ALL_INTERRUPTS    ( SYSVIEW_EVTMASK_ISR_ENTER           \
N                                            | SYSVIEW_EVTMASK_ISR_EXIT            \
N                                            | SYSVIEW_EVTMASK_ISR_TO_SCHEDULER)
X#define   SYSVIEW_EVTMASK_ALL_INTERRUPTS    ( SYSVIEW_EVTMASK_ISR_ENTER                                                       | SYSVIEW_EVTMASK_ISR_EXIT                                                        | SYSVIEW_EVTMASK_ISR_TO_SCHEDULER)
N#define   SYSVIEW_EVTMASK_ALL_TASKS         ( SYSVIEW_EVTMASK_TASK_START_EXEC     \
N                                            | SYSVIEW_EVTMASK_TASK_STOP_EXEC      \
N                                            | SYSVIEW_EVTMASK_TASK_START_READY    \
N                                            | SYSVIEW_EVTMASK_TASK_STOP_READY     \
N                                            | SYSVIEW_EVTMASK_TASK_CREATE         \
N                                            | SYSVIEW_EVTMASK_TASK_INFO           \
N                                            | SYSVIEW_EVTMASK_STACK_INFO          \
N                                            | SYSVIEW_EVTMASK_TASK_TERMINATE)
X#define   SYSVIEW_EVTMASK_ALL_TASKS         ( SYSVIEW_EVTMASK_TASK_START_EXEC                                                 | SYSVIEW_EVTMASK_TASK_STOP_EXEC                                                  | SYSVIEW_EVTMASK_TASK_START_READY                                                | SYSVIEW_EVTMASK_TASK_STOP_READY                                                 | SYSVIEW_EVTMASK_TASK_CREATE                                                     | SYSVIEW_EVTMASK_TASK_INFO                                                       | SYSVIEW_EVTMASK_STACK_INFO                                                      | SYSVIEW_EVTMASK_TASK_TERMINATE)
N
N/*********************************************************************
N*
N*       Structures
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  U32          TaskID;
X  unsigned long          TaskID;
N  const char*  sName;
N  U32          Prio;
X  unsigned long          Prio;
N  U32          StackBase;
X  unsigned long          StackBase;
N  U32          StackSize;
X  unsigned long          StackSize;
N} SEGGER_SYSVIEW_TASKINFO;
N
Ntypedef struct SEGGER_SYSVIEW_MODULE_STRUCT SEGGER_SYSVIEW_MODULE;
N
Nstruct SEGGER_SYSVIEW_MODULE_STRUCT {
N  const char*                   sModule;
N        U32                     NumEvents;
X        unsigned long                     NumEvents;
N        U32                     EventOffset;
X        unsigned long                     EventOffset;
N        void                    (*pfSendModuleDesc)(void);
N        SEGGER_SYSVIEW_MODULE*  pNext;
N};
N
Ntypedef void (SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC)(void);
N
N/*********************************************************************
N*
N*       API functions
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  U64  (*pfGetTime)      (void);
X  unsigned long long  (*pfGetTime)      (void);
N  void (*pfSendTaskList) (void);
N} SEGGER_SYSVIEW_OS_API;
N
N/*********************************************************************
N*
N*       Control and initialization functions
N*/
Nvoid SEGGER_SYSVIEW_Init                          (U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc);
Xvoid SEGGER_SYSVIEW_Init                          (unsigned long SysFreq, unsigned long CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc);
Nvoid SEGGER_SYSVIEW_SetRAMBase                    (U32 RAMBaseAddress);
Xvoid SEGGER_SYSVIEW_SetRAMBase                    (unsigned long RAMBaseAddress);
Nvoid SEGGER_SYSVIEW_Start                         (void);
Nvoid SEGGER_SYSVIEW_Stop                          (void);
Nvoid SEGGER_SYSVIEW_GetSysDesc                    (void);
Nvoid SEGGER_SYSVIEW_SendTaskList                  (void);
Nvoid SEGGER_SYSVIEW_SendTaskInfo                  (const SEGGER_SYSVIEW_TASKINFO* pInfo);
Nvoid SEGGER_SYSVIEW_SendSysDesc                   (const char* sSysDesc);
N
N/*********************************************************************
N*
N*       Event recording functions
N*/
Nvoid SEGGER_SYSVIEW_RecordVoid                    (unsigned EventId);
Nvoid SEGGER_SYSVIEW_RecordU32                     (unsigned EventId, U32 Para0);
Xvoid SEGGER_SYSVIEW_RecordU32                     (unsigned EventId, unsigned long Para0);
Nvoid SEGGER_SYSVIEW_RecordU32x2                   (unsigned EventId, U32 Para0, U32 Para1);
Xvoid SEGGER_SYSVIEW_RecordU32x2                   (unsigned EventId, unsigned long Para0, unsigned long Para1);
Nvoid SEGGER_SYSVIEW_RecordU32x3                   (unsigned EventId, U32 Para0, U32 Para1, U32 Para2);
Xvoid SEGGER_SYSVIEW_RecordU32x3                   (unsigned EventId, unsigned long Para0, unsigned long Para1, unsigned long Para2);
Nvoid SEGGER_SYSVIEW_RecordU32x4                   (unsigned EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3);
Xvoid SEGGER_SYSVIEW_RecordU32x4                   (unsigned EventId, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3);
Nvoid SEGGER_SYSVIEW_RecordU32x5                   (unsigned EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4);
Xvoid SEGGER_SYSVIEW_RecordU32x5                   (unsigned EventId, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3, unsigned long Para4);
Nvoid SEGGER_SYSVIEW_RecordU32x6                   (unsigned EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5);
Xvoid SEGGER_SYSVIEW_RecordU32x6                   (unsigned EventId, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3, unsigned long Para4, unsigned long Para5);
Nvoid SEGGER_SYSVIEW_RecordU32x7                   (unsigned EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6);
Xvoid SEGGER_SYSVIEW_RecordU32x7                   (unsigned EventId, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3, unsigned long Para4, unsigned long Para5, unsigned long Para6);
Nvoid SEGGER_SYSVIEW_RecordU32x8                   (unsigned EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7);
Xvoid SEGGER_SYSVIEW_RecordU32x8                   (unsigned EventId, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3, unsigned long Para4, unsigned long Para5, unsigned long Para6, unsigned long Para7);
Nvoid SEGGER_SYSVIEW_RecordU32x9                   (unsigned EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8);
Xvoid SEGGER_SYSVIEW_RecordU32x9                   (unsigned EventId, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3, unsigned long Para4, unsigned long Para5, unsigned long Para6, unsigned long Para7, unsigned long Para8);
Nvoid SEGGER_SYSVIEW_RecordU32x10                  (unsigned EventId, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8, U32 Para9);
Xvoid SEGGER_SYSVIEW_RecordU32x10                  (unsigned EventId, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3, unsigned long Para4, unsigned long Para5, unsigned long Para6, unsigned long Para7, unsigned long Para8, unsigned long Para9);
Nvoid SEGGER_SYSVIEW_RecordString                  (unsigned EventId, const char* pString);
Nvoid SEGGER_SYSVIEW_RecordSystime                 (void);
Nvoid SEGGER_SYSVIEW_RecordEnterISR                (void);
Nvoid SEGGER_SYSVIEW_RecordExitISR                 (void);
Nvoid SEGGER_SYSVIEW_RecordExitISRToScheduler      (void);
Nvoid SEGGER_SYSVIEW_RecordEnterTimer              (U32 TimerId);
Xvoid SEGGER_SYSVIEW_RecordEnterTimer              (unsigned long TimerId);
Nvoid SEGGER_SYSVIEW_RecordExitTimer               (void);
Nvoid SEGGER_SYSVIEW_RecordEndCall                 (unsigned EventID);
Nvoid SEGGER_SYSVIEW_RecordEndCallU32              (unsigned EventID, U32 Para0);
Xvoid SEGGER_SYSVIEW_RecordEndCallU32              (unsigned EventID, unsigned long Para0);
N
Nvoid SEGGER_SYSVIEW_OnIdle                        (void);
Nvoid SEGGER_SYSVIEW_OnTaskCreate                  (unsigned TaskId);
Nvoid SEGGER_SYSVIEW_OnTaskTerminate               (unsigned TaskId);
Nvoid SEGGER_SYSVIEW_OnTaskStartExec               (unsigned TaskId);
Nvoid SEGGER_SYSVIEW_OnTaskStopExec                (void);
Nvoid SEGGER_SYSVIEW_OnTaskStartReady              (unsigned TaskId);
Nvoid SEGGER_SYSVIEW_OnTaskStopReady               (unsigned TaskId, unsigned Cause);
Nvoid SEGGER_SYSVIEW_OnUserStart                   (unsigned UserId);       // Start of user defined event (such as a subroutine to profile)
Nvoid SEGGER_SYSVIEW_OnUserStop                    (unsigned UserId);       // Start of user defined event
N
Nvoid SEGGER_SYSVIEW_NameResource                  (U32 ResourceId, const char* sName);
Xvoid SEGGER_SYSVIEW_NameResource                  (unsigned long ResourceId, const char* sName);
N
Nint  SEGGER_SYSVIEW_SendPacket                    (U8* pPacket, U8* pPayloadEnd, unsigned EventId);
Xint  SEGGER_SYSVIEW_SendPacket                    (unsigned char* pPacket, unsigned char* pPayloadEnd, unsigned EventId);
N
N/*********************************************************************
N*
N*       Event parameter encoding functions
N*/
NU8*  SEGGER_SYSVIEW_EncodeU32                     (U8* pPayload, unsigned Value);
Xunsigned char*  SEGGER_SYSVIEW_EncodeU32                     (unsigned char* pPayload, unsigned Value);
NU8*  SEGGER_SYSVIEW_EncodeData                    (U8* pPayload, const char* pSrc, unsigned Len);
Xunsigned char*  SEGGER_SYSVIEW_EncodeData                    (unsigned char* pPayload, const char* pSrc, unsigned Len);
NU8*  SEGGER_SYSVIEW_EncodeString                  (U8* pPayload, const char* s, unsigned MaxLen);
Xunsigned char*  SEGGER_SYSVIEW_EncodeString                  (unsigned char* pPayload, const char* s, unsigned MaxLen);
NU8*  SEGGER_SYSVIEW_EncodeId                      (U8* pPayload, unsigned Id);
Xunsigned char*  SEGGER_SYSVIEW_EncodeId                      (unsigned char* pPayload, unsigned Id);
NU32  SEGGER_SYSVIEW_ShrinkId                      (U32 Id);
Xunsigned long  SEGGER_SYSVIEW_ShrinkId                      (unsigned long Id);
N
N
N/*********************************************************************
N*
N*       Middleware module registration
N*/
Nvoid SEGGER_SYSVIEW_RegisterModule                (SEGGER_SYSVIEW_MODULE* pModule);
Nvoid SEGGER_SYSVIEW_RecordModuleDescription       (const SEGGER_SYSVIEW_MODULE* pModule, const char* sDescription);
Nvoid SEGGER_SYSVIEW_SendModule                    (U8 ModuleId);
Xvoid SEGGER_SYSVIEW_SendModule                    (unsigned char ModuleId);
Nvoid SEGGER_SYSVIEW_SendModuleDescription         (void);
Nvoid SEGGER_SYSVIEW_SendNumModules                (void);
N
N/*********************************************************************
N*
N*       printf-Style functions
N*/
N#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
Nvoid SEGGER_SYSVIEW_PrintfHostEx                  (const char* s, U32 Options, ...);
Xvoid SEGGER_SYSVIEW_PrintfHostEx                  (const char* s, unsigned long Options, ...);
Nvoid SEGGER_SYSVIEW_PrintfTargetEx                (const char* s, U32 Options, ...);
Xvoid SEGGER_SYSVIEW_PrintfTargetEx                (const char* s, unsigned long Options, ...);
Nvoid SEGGER_SYSVIEW_PrintfHost                    (const char* s, ...);
Nvoid SEGGER_SYSVIEW_PrintfTarget                  (const char* s, ...);
Nvoid SEGGER_SYSVIEW_WarnfHost                     (const char* s, ...);
Nvoid SEGGER_SYSVIEW_WarnfTarget                   (const char* s, ...);
Nvoid SEGGER_SYSVIEW_ErrorfHost                    (const char* s, ...);
Nvoid SEGGER_SYSVIEW_ErrorfTarget                  (const char* s, ...);
N#endif
N
Nvoid SEGGER_SYSVIEW_Print                         (const char* s);
Nvoid SEGGER_SYSVIEW_Warn                          (const char* s);
Nvoid SEGGER_SYSVIEW_Error                         (const char* s);
N
N/*********************************************************************
N*
N*       Run-time configuration functions
N*/
Nvoid SEGGER_SYSVIEW_EnableEvents                  (U32 EnableMask);
Xvoid SEGGER_SYSVIEW_EnableEvents                  (unsigned long EnableMask);
Nvoid SEGGER_SYSVIEW_DisableEvents                 (U32 DisableMask);
Xvoid SEGGER_SYSVIEW_DisableEvents                 (unsigned long DisableMask);
N
N/*********************************************************************
N*
N*       Application-provided functions
N*/
Nvoid SEGGER_SYSVIEW_Conf                          (void);
NU32  SEGGER_SYSVIEW_X_GetTimestamp                (void);
Xunsigned long  SEGGER_SYSVIEW_X_GetTimestamp                (void);
NU32  SEGGER_SYSVIEW_X_GetInterruptId              (void);
Xunsigned long  SEGGER_SYSVIEW_X_GetInterruptId              (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N/*************************** End of file ****************************/
L 75 "..\..\User\SEGGER\SEGGER_SYSVIEW_Int.h" 2
N#include "SEGGER_SYSVIEW_Conf.h"
L 1 "..\..\User\SEGGER\SEGGER_SYSVIEW_Conf.h" 1
N/*********************************************************************
N*                SEGGER Microcontroller GmbH & Co. KG                *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*       (c) 2015 - 2016  SEGGER Microcontroller GmbH & Co. KG        *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER SystemView * Real-time application analysis           *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* conditions are met:                                                *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this list of conditions and the following disclaimer.    *
N*                                                                    *
N* o Redistributions in binary form must reproduce the above          *
N*   copyright notice, this list of conditions and the following      *
N*   disclaimer in the documentation and/or other materials provided  *
N*   with the distribution.                                           *
N*                                                                    *
N* o Neither the name of SEGGER Microcontroller GmbH & Co. KG         *
N*   nor the names of its contributors may be used to endorse or      *
N*   promote products derived from this software without specific     *
N*   prior written permission.                                        *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SystemView version: V2.40a                                    *
N*                                                                    *
N**********************************************************************
N-------------------------- END-OF-HEADER -----------------------------
N
NFile    : SEGGER_SYSVIEW_Conf.h
NPurpose : SEGGER SystemView configuration.
NRevision: $Rev: 3734 $
N*/
N
N#ifndef SEGGER_SYSVIEW_CONF_H
N#define SEGGER_SYSVIEW_CONF_H
N
N/*********************************************************************
N*
N*       Defines, fixed
N*
N**********************************************************************
N*/
N//
N// Constants for known core configuration
N//
N#define SEGGER_SYSVIEW_CORE_OTHER   0
N#define SEGGER_SYSVIEW_CORE_CM0     1 // Cortex-M0/M0+/M1
N#define SEGGER_SYSVIEW_CORE_CM3     2 // Cortex-M3/M4/M7
N#define SEGGER_SYSVIEW_CORE_RX      3 // Renesas RX
N
N#if (defined __SES_ARM) || (defined __CROSSWORKS_ARM) || (defined __GNUC__)
X#if (0L) || (0L) || (0L)
S  #ifdef __ARM_ARCH_6M__
S    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
S  #elif (defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__))
S    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
S  #endif
S#elif defined(__ICCARM__)
X#elif 0L
S  #if (defined (__ARM6M__) && (__CORE__ == __ARM6M__))
S    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
S  #elif ((defined (__ARM7M__) && (__CORE__ == __ARM7M__)) || (defined (__ARM7EM__) && (__CORE__ == __ARM7EM__)))
S    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3
S  #endif
N#elif defined(__CC_ARM)
X#elif 1L
N  #if (defined(__TARGET_ARCH_6S_M))
X  #if (0L)
S    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM0
N  #elif (defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
X  #elif (0L || 1L)
N    #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_CM3	
N  #endif
N#elif defined(__ICCRX__)
S  #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_RX
S#elif defined(__RX)
S  #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_RX
N#endif
N
N#ifndef   SEGGER_SYSVIEW_CORE
S  #define SEGGER_SYSVIEW_CORE SEGGER_SYSVIEW_CORE_OTHER
N#endif
N
N/*********************************************************************
N*
N*       Defines, configurable
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       SystemView buffer configuration
N*/
N#define SEGGER_SYSVIEW_RTT_BUFFER_SIZE      1024                                // Number of bytes that SystemView uses for the buffer.
N#define SEGGER_SYSVIEW_RTT_CHANNEL          1                                   // The RTT channel that SystemView will use. 0: Auto selection
N
N#define SEGGER_SYSVIEW_USE_STATIC_BUFFER    1                                   // Use a static buffer to generate events instead of a buffer on the stack
N
N#define SEGGER_SYSVIEW_POST_MORTEM_MODE     0                                   // 1: Enable post mortem analysis mode
N
N/*********************************************************************
N*
N*       SystemView timestamp configuration
N*/
N#if SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM3
X#if 2 == 2
N  #define SEGGER_SYSVIEW_GET_TIMESTAMP()      (*(U32 *)(0xE0001004))            // Retrieve a system timestamp. Cortex-M cycle counter.
N  #define SEGGER_SYSVIEW_TIMESTAMP_BITS       32                                // Define number of valid bits low-order delivered by clock source
N#else
S  #define SEGGER_SYSVIEW_GET_TIMESTAMP()      SEGGER_SYSVIEW_X_GetTimestamp()   // Retrieve a system timestamp via user-defined function
S  #define SEGGER_SYSVIEW_TIMESTAMP_BITS       32                                // Define number of valid bits low-order delivered by SEGGER_SYSVIEW_X_GetTimestamp()
N#endif
N
N/*********************************************************************
N*
N*       SystemView Id configuration
N*/
N#define SEGGER_SYSVIEW_ID_BASE         0x10000000                               // Default value for the lowest Id reported by the application. Can be overridden by the application via SEGGER_SYSVIEW_SetRAMBase(). (i.e. 0x20000000 when all Ids are an address in this RAM)
N#define SEGGER_SYSVIEW_ID_SHIFT        2                                        // Number of bits to shift the Id to save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
N
N/*********************************************************************
N*
N*       SystemView interrupt configuration
N*/
N#if SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM3
X#if 2 == 2
N  #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()   ((*(U32 *)(0xE000ED04)) & 0x1FF)  // Get the currently active interrupt Id. (i.e. read Cortex-M ICSR[8:0] = active vector)
N#elif SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM0
S  #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()   ((*(U32 *)(0xE000ED04)) & 0x3F)   // Get the currently active interrupt Id. (i.e. read Cortex-M ICSR[5:0] = active vector)
S#else
S  #define SEGGER_SYSVIEW_GET_INTERRUPT_ID()   SEGGER_SYSVIEW_X_GetInterruptId() // Get the currently active interrupt Id from the user-provided function.
N#endif
N
N#endif  // SEGGER_SYSVIEW_CONF_H
N
N/*************************** End of file ****************************/
L 76 "..\..\User\SEGGER\SEGGER_SYSVIEW_Int.h" 2
N#include "SEGGER_SYSVIEW_ConfDefaults.h"
L 1 "..\..\User\SEGGER\SEGGER_SYSVIEW_ConfDefaults.h" 1
N/*********************************************************************
N*                SEGGER Microcontroller GmbH & Co. KG                *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*       (c) 2015 - 2016  SEGGER Microcontroller GmbH & Co. KG        *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER SystemView * Real-time application analysis           *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* conditions are met:                                                *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this list of conditions and the following disclaimer.    *
N*                                                                    *
N* o Redistributions in binary form must reproduce the above          *
N*   copyright notice, this list of conditions and the following      *
N*   disclaimer in the documentation and/or other materials provided  *
N*   with the distribution.                                           *
N*                                                                    *
N* o Neither the name of SEGGER Microcontroller GmbH & Co. KG         *
N*   nor the names of its contributors may be used to endorse or      *
N*   promote products derived from this software without specific     *
N*   prior written permission.                                        *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SystemView version: V2.40a                                    *
N*                                                                    *
N**********************************************************************
N-------------------------- END-OF-HEADER -----------------------------
NFile    : SEGGER_SYSVIEW_ConfDefaults.h
NPurpose : Defines defaults for configurable defines used in
N          SEGGER SystemView.
NRevision: $Rev: 3734 $
N*/
N
N#ifndef SEGGER_SYSVIEW_CONFDEFAULTS_H
N#define SEGGER_SYSVIEW_CONFDEFAULTS_H
N
N/*********************************************************************
N*
N*       #include Section
N*
N**********************************************************************
N*/
N
N#include "SEGGER_SYSVIEW_Conf.h"
N#include "SEGGER_RTT_Conf.h"
L 1 "..\..\User\SEGGER\SEGGER_RTT_Conf.h" 1
N/*********************************************************************
N*                SEGGER Microcontroller GmbH & Co. KG                *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*       (c) 2015 - 2016  SEGGER Microcontroller GmbH & Co. KG        *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER SystemView * Real-time application analysis           *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* conditions are met:                                                *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this list of conditions and the following disclaimer.    *
N*                                                                    *
N* o Redistributions in binary form must reproduce the above          *
N*   copyright notice, this list of conditions and the following      *
N*   disclaimer in the documentation and/or other materials provided  *
N*   with the distribution.                                           *
N*                                                                    *
N* o Neither the name of SEGGER Microcontroller GmbH & Co. KG         *
N*   nor the names of its contributors may be used to endorse or      *
N*   promote products derived from this software without specific     *
N*   prior written permission.                                        *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SystemView version: V2.40a                                    *
N*                                                                    *
N**********************************************************************
N----------------------------------------------------------------------
NFile    : SEGGER_RTT_Conf.h
NPurpose : Implementation of SEGGER real-time transfer (RTT) which 
N          allows real-time communication on targets which support 
N          debugger memory accesses while the CPU is running.
NRevision: $Rev: 3892 $
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef SEGGER_RTT_CONF_H
N#define SEGGER_RTT_CONF_H
N
N#ifdef __IAR_SYSTEMS_ICC__
S  #include <intrinsics.h>
N#endif
N
N/*********************************************************************
N*
N*       Defines, configurable
N*
N**********************************************************************
N*/
N
N#define SEGGER_RTT_MAX_NUM_UP_BUFFERS             (3)     // Max. number of up-buffers (T->H) available on this target    (Default: 3)
N#define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS           (3)     // Max. number of down-buffers (H->T) available on this target  (Default: 3)
N
N#define BUFFER_SIZE_UP                            (1024)  // Size of the buffer for terminal output of target, up to host (Default: 1k)
N#define BUFFER_SIZE_DOWN                          (16)    // Size of the buffer for terminal input to target from host (Usually keyboard input) (Default: 16)
N
N#define SEGGER_RTT_PRINTF_BUFFER_SIZE             (64u)    // Size of buffer for RTT printf to bulk-send chars via RTT     (Default: 64)
N
N#define SEGGER_RTT_MODE_DEFAULT                   SEGGER_RTT_MODE_NO_BLOCK_SKIP // Mode for pre-initialized terminal channel (buffer 0)
N
N//
N// Target is not allowed to perform other RTT operations while string still has not been stored completely.
N// Otherwise we would probably end up with a mixed string in the buffer.
N// If using  RTT from within interrupts, multiple tasks or multi processors, define the SEGGER_RTT_LOCK() and SEGGER_RTT_UNLOCK() function here.
N// 
N// SEGGER_RTT_MAX_INTERRUPT_PRIORITY can be used in the sample lock routines on Cortex-M3/4.
N// Make sure to mask all interrupts which can send RTT data, i.e. generate SystemView events, or cause task switches.
N// When high-priority interrupts must not be masked while sending RTT data, SEGGER_RTT_MAX_INTERRUPT_PRIORITY needs to be adjusted accordingly.
N// (Higher priority = lower priority number)
N// Default value for embOS: 128u
N// Default configuration in FreeRTOS: configMAX_SYSCALL_INTERRUPT_PRIORITY: ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
N// In case of doubt mask all interrupts: 1 << (8 - BASEPRI_PRIO_BITS) i.e. 1 << 5 when 3 bits are implemented in NVIC
N// or define SEGGER_RTT_LOCK() to completely disable interrupts.
N// 
N
N#define SEGGER_RTT_MAX_INTERRUPT_PRIORITY         (0x20)   // Interrupt priority to lock on SEGGER_RTT_LOCK on Cortex-M3/4 (Default: 0x20)
N
N/*********************************************************************
N*
N*       RTT lock configuration for SEGGER Embedded Studio, 
N*       Rowley CrossStudio and GCC
N*/
N#if (defined __SES_ARM) || (defined __CROSSWORKS_ARM) || (defined __GNUC__)
X#if (0L) || (0L) || (0L)
S  #ifdef __ARM_ARCH_6M__
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                    unsigned int LockState;                                         \
S                                  __asm volatile ("mrs   %0, primask  \n\t"                         \
S                                                  "mov   r1, $1     \n\t"                           \
S                                                  "msr   primask, r1  \n\t"                         \
S                                                  : "=r" (LockState)                                \
S                                                  :                                                 \
S                                                  : "r1"                                            \
S                                                  );                            
X    #define SEGGER_RTT_LOCK()   {                                                                                                       unsigned int LockState;                                                                           __asm volatile ("mrs   %0, primask  \n\t"                                                                           "mov   r1, $1     \n\t"                                                                             "msr   primask, r1  \n\t"                                                                           : "=r" (LockState)                                                                                  :                                                                                                   : "r1"                                                                                              );                            
S    
S    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   primask, %0  \n\t"                         \
S                                                  :                                                 \
S                                                  : "r" (LockState)                                 \
S                                                  :                                                 \
S                                                  );                                                \
S                                }                                             
X    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   primask, %0  \n\t"                                                                           :                                                                                                   : "r" (LockState)                                                                                   :                                                                                                   );                                                                                }                                             
S                                  
S  #elif (defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__))
S    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
S      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
S    #endif
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                    unsigned int LockState;                                         \
S                                  __asm volatile ("mrs   %0, basepri  \n\t"                         \
S                                                  "mov   r1, %1       \n\t"                         \
S                                                  "msr   basepri, r1  \n\t"                         \
S                                                  : "=r" (LockState)                                \
S                                                  : "i"(SEGGER_RTT_MAX_INTERRUPT_PRIORITY)          \
S                                                  : "r1"                                            \
S                                                  );                            
X    #define SEGGER_RTT_LOCK()   {                                                                                                       unsigned int LockState;                                                                           __asm volatile ("mrs   %0, basepri  \n\t"                                                                           "mov   r1, %1       \n\t"                                                                           "msr   basepri, r1  \n\t"                                                                           : "=r" (LockState)                                                                                  : "i"(SEGGER_RTT_MAX_INTERRUPT_PRIORITY)                                                            : "r1"                                                                                              );                            
S    
S    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   basepri, %0  \n\t"                         \
S                                                  :                                                 \
S                                                  : "r" (LockState)                                 \
S                                                  :                                                 \
S                                                  );                                                \
S                                }
X    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   basepri, %0  \n\t"                                                                           :                                                                                                   : "r" (LockState)                                                                                   :                                                                                                   );                                                                                }
S  
S  #elif defined(__ARM_ARCH_7A__)
S    #define SEGGER_RTT_LOCK() {                                                \
S                                 unsigned int LockState;                       \
S                                 __asm volatile ("mrs r1, CPSR \n\t"           \
S                                                 "mov %0, r1 \n\t"             \
S                                                 "orr r1, r1, #0xC0 \n\t"      \
S                                                 "msr CPSR_c, r1 \n\t"         \
S                                                 : "=r" (LockState)            \
S                                                 :                             \
S                                                 : "r1"                        \
S                                                 );
X    #define SEGGER_RTT_LOCK() {                                                                                 unsigned int LockState;                                                        __asm volatile ("mrs r1, CPSR \n\t"                                                            "mov %0, r1 \n\t"                                                              "orr r1, r1, #0xC0 \n\t"                                                       "msr CPSR_c, r1 \n\t"                                                          : "=r" (LockState)                                                             :                                                                              : "r1"                                                                         );
S
S    #define SEGGER_RTT_UNLOCK() __asm volatile ("mov r0, %0 \n\t"              \
S                                                "mrs r1, CPSR \n\t"            \
S                                                "bic r1, r1, #0xC0 \n\t"       \
S                                                "and r0, r0, #0xC0 \n\t"       \
S                                                "orr r1, r1, r0 \n\t"          \
S                                                "msr CPSR_c, r1 \n\t"          \
S                                                :                              \
S                                                : "r" (LockState)              \
S                                                : "r0", "r1"                   \
S                                                );                             \
S                            }
X    #define SEGGER_RTT_UNLOCK() __asm volatile ("mov r0, %0 \n\t"                                                              "mrs r1, CPSR \n\t"                                                            "bic r1, r1, #0xC0 \n\t"                                                       "and r0, r0, #0xC0 \n\t"                                                       "orr r1, r1, r0 \n\t"                                                          "msr CPSR_c, r1 \n\t"                                                          :                                                                              : "r" (LockState)                                                              : "r0", "r1"                                                                   );                                                         }
S#else
S    #define SEGGER_RTT_LOCK()  
S    #define SEGGER_RTT_UNLOCK()
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for IAR EWARM
N*/
N#ifdef __ICCARM__
S  #if (defined (__ARM6M__) && (__CORE__ == __ARM6M__))
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int LockState;                                           \
S                                  LockState = __get_PRIMASK();                                      \
S                                  __set_PRIMASK(1);                           
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int LockState;                                                                             LockState = __get_PRIMASK();                                                                        __set_PRIMASK(1);                           
S                                    
S    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(LockState);                                         \
S                                }
X    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(LockState);                                                                         }
S  #elif ((defined (__ARM7EM__) && (__CORE__ == __ARM7EM__)) || (defined (__ARM7M__) && (__CORE__ == __ARM7M__)))
S    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
S      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
S    #endif
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int LockState;                                           \
S                                  LockState = __get_BASEPRI();                                      \
S                                  __set_BASEPRI(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);                           
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int LockState;                                                                             LockState = __get_BASEPRI();                                                                        __set_BASEPRI(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);                           
S                                    
S    #define SEGGER_RTT_UNLOCK()   __set_BASEPRI(LockState);                                         \
S                                }  
X    #define SEGGER_RTT_UNLOCK()   __set_BASEPRI(LockState);                                                                         }  
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for IAR RX
N*/
N#ifdef __ICCRX__
S  #define SEGGER_RTT_LOCK()   {                                                                     \
S                                unsigned long LockState;                                            \
S                                LockState = __get_interrupt_state();                                \
S                                __disable_interrupt();                           
X  #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned long LockState;                                                                            LockState = __get_interrupt_state();                                                                __disable_interrupt();                           
S                                  
S  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(LockState);                                   \
S                              }
X  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(LockState);                                                                 }
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for KEIL ARM
N*/
N#ifdef __CC_ARM
N  #if (defined __TARGET_ARCH_6S_M)
X  #if (0L)
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int LockState;                                           \
S                                  register unsigned char PRIMASK __asm( "primask");                 \
S                                  LockState = PRIMASK;                                              \
S                                  PRIMASK = 1u;                                                     \
S                                  __schedule_barrier();
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int LockState;                                                                             register unsigned char PRIMASK __asm( "primask");                                                   LockState = PRIMASK;                                                                                PRIMASK = 1u;                                                                                       __schedule_barrier();
S
S    #define SEGGER_RTT_UNLOCK()   PRIMASK = LockState;                                              \
S                                  __schedule_barrier();                                             \
S                                }
X    #define SEGGER_RTT_UNLOCK()   PRIMASK = LockState;                                                                                __schedule_barrier();                                                                             }
N  #elif (defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
X  #elif (0L || 1L)
N    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
S      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
N    #endif
N    #define SEGGER_RTT_LOCK()   {                                                                   \
N                                  unsigned int LockState;                                           \
N                                  register unsigned char BASEPRI __asm( "basepri");                 \
N                                  LockState = BASEPRI;                                              \
N                                  BASEPRI = SEGGER_RTT_MAX_INTERRUPT_PRIORITY;                      \
N                                  __schedule_barrier();
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int LockState;                                                                             register unsigned char BASEPRI __asm( "basepri");                                                   LockState = BASEPRI;                                                                                BASEPRI = SEGGER_RTT_MAX_INTERRUPT_PRIORITY;                                                        __schedule_barrier();
N
N    #define SEGGER_RTT_UNLOCK()   BASEPRI = LockState;                                              \
N                                  __schedule_barrier();                                             \
N                                }
X    #define SEGGER_RTT_UNLOCK()   BASEPRI = LockState;                                                                                __schedule_barrier();                                                                             }
N  #endif
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration fallback
N*/
N#ifndef   SEGGER_RTT_LOCK
S  #define SEGGER_RTT_LOCK()                // Lock RTT (nestable)   (i.e. disable interrupts)
N#endif
N
N#ifndef   SEGGER_RTT_UNLOCK
S  #define SEGGER_RTT_UNLOCK()              // Unlock RTT (nestable) (i.e. enable previous interrupt lock state)
N#endif
N
N#endif
N/*************************** End of file ****************************/
L 77 "..\..\User\SEGGER\SEGGER_SYSVIEW_ConfDefaults.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*********************************************************************
N*
N*       Configuration defaults
N*
N**********************************************************************
N*/
N
N// Number of bytes that SystemView uses for a buffer.
N#ifndef   SEGGER_SYSVIEW_RTT_BUFFER_SIZE
S  #define SEGGER_SYSVIEW_RTT_BUFFER_SIZE    1024
N#endif
N
N// The RTT channel that SystemView will use.
N#ifndef   SEGGER_SYSVIEW_RTT_CHANNEL
S  #define SEGGER_SYSVIEW_RTT_CHANNEL        0
N#endif
N// Sanity check of RTT channel
N#if (SEGGER_SYSVIEW_RTT_CHANNEL == 0) && (SEGGER_RTT_MAX_NUM_UP_BUFFERS < 2)
X#if (1 == 0) && ((3) < 2)
S  #error "SEGGER_RTT_MAX_NUM_UP_BUFFERS in SEGGER_RTT_Conf.h has to be > 1!"
S#elif (SEGGER_SYSVIEW_RTT_CHANNEL >= SEGGER_RTT_MAX_NUM_UP_BUFFERS)
X#elif (1 >= (3))
S  #error "SEGGER_RTT_MAX_NUM_UP_BUFFERS  in SEGGER_RTT_Conf.h has to be > SEGGER_SYSVIEW_RTT_CHANNEL!"
N#endif
N
N// Place the SystemView buffer into its own/the RTT section
N#if !(defined SEGGER_SYSVIEW_BUFFER_SECTION) && (defined SEGGER_RTT_SECTION)
X#if !(0L) && (0L)
S  #define SEGGER_SYSVIEW_BUFFER_SECTION            SEGGER_RTT_SECTION
N#endif
N
N// Retrieve a system timestamp.  This gets the Cortex-M cycle counter.
N#ifndef   SEGGER_SYSVIEW_GET_TIMESTAMP
S  #error "SEGGER_SYSVIEW_GET_TIMESTAMP has to be defined in SEGGER_SYSVIEW_Conf.h!"
N#endif
N
N// Define number of valid bits low-order delivered by clock source.
N#ifndef   SEGGER_SYSVIEW_TIMESTAMP_BITS
S  #define SEGGER_SYSVIEW_TIMESTAMP_BITS     32
N#endif
N
N// Lowest Id reported by the Application.
N#ifndef   SEGGER_SYSVIEW_ID_BASE 
S  #define SEGGER_SYSVIEW_ID_BASE            0
N#endif
N
N// Number of bits to shift Ids to save bandwidth
N#ifndef   SEGGER_SYSVIEW_ID_SHIFT
S  #define SEGGER_SYSVIEW_ID_SHIFT           0
N#endif
N
N#ifndef   SEGGER_SYSVIEW_GET_INTERRUPT_ID
S  #error "SEGGER_SYSVIEW_GET_INTERRUPT_ID has to be defined in SEGGER_SYSVIEW_Conf.h!"
N#endif
N
N#ifndef   SEGGER_SYSVIEW_MAX_ARGUMENTS
N  #define SEGGER_SYSVIEW_MAX_ARGUMENTS      16
N#endif
N
N#ifndef   SEGGER_SYSVIEW_MAX_STRING_LEN
N  #define SEGGER_SYSVIEW_MAX_STRING_LEN     128
N#endif
N
N// Use a static buffer instead of a buffer on the stack for packets
N#ifndef   SEGGER_SYSVIEW_USE_STATIC_BUFFER
S  #define SEGGER_SYSVIEW_USE_STATIC_BUFFER  1
N#endif
N
N// Maximum packet size used by SystemView for the static buffer
N#ifndef   SEGGER_SYSVIEW_MAX_PACKET_SIZE
N  #define SEGGER_SYSVIEW_MAX_PACKET_SIZE   SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_ARGUMENTS * SEGGER_SYSVIEW_QUANTA_U32
N#endif
N
N// Use post-mortem analysis instead of real-time analysis
N#ifndef   SEGGER_SYSVIEW_POST_MORTEM_MODE
S  #define SEGGER_SYSVIEW_POST_MORTEM_MODE   0
N#endif
N
N// Configure how frequently syncronization is sent
N#ifndef   SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT
N  #define SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT  8
N#endif
N
N// Lock SystemView (nestable)
N#ifndef   SEGGER_SYSVIEW_LOCK
N  #define SEGGER_SYSVIEW_LOCK()             SEGGER_RTT_LOCK()
N#endif
N
N// Unlock SystemView (nestable)
N#ifndef   SEGGER_SYSVIEW_UNLOCK
N  #define SEGGER_SYSVIEW_UNLOCK()           SEGGER_RTT_UNLOCK()
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N/*************************** End of file ****************************/
L 77 "..\..\User\SEGGER\SEGGER_SYSVIEW_Int.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/*********************************************************************
N*
N*       Private data types
N*
N**********************************************************************
N*/
N//
N// Commands that Host can send to target
N//
Ntypedef enum {
N  SEGGER_SYSVIEW_COMMAND_ID_START = 1,
N  SEGGER_SYSVIEW_COMMAND_ID_STOP,
N  SEGGER_SYSVIEW_COMMAND_ID_GET_SYSTIME,
N  SEGGER_SYSVIEW_COMMAND_ID_GET_TASKLIST,
N  SEGGER_SYSVIEW_COMMAND_ID_GET_SYSDESC,
N  SEGGER_SYSVIEW_COMMAND_ID_GET_NUMMODULES,
N  SEGGER_SYSVIEW_COMMAND_ID_GET_MODULEDESC,
N  // Extended commands: Commands >= 128 have a second parameter
N  SEGGER_SYSVIEW_COMMAND_ID_GET_MODULE = 128,
N} SEGGER_SYSVIEW_COMMAND_ID;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N/*************************** End of file ****************************/
L 149 "..\..\User\SEGGER\SEGGER_SYSVIEW.c" 2
N#include "SEGGER_RTT.h"
L 1 "..\..\User\SEGGER\SEGGER_RTT.h" 1
N/*********************************************************************
N*                SEGGER Microcontroller GmbH & Co. KG                *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*       (c) 2015 - 2016  SEGGER Microcontroller GmbH & Co. KG        *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER SystemView * Real-time application analysis           *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* conditions are met:                                                *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this list of conditions and the following disclaimer.    *
N*                                                                    *
N* o Redistributions in binary form must reproduce the above          *
N*   copyright notice, this list of conditions and the following      *
N*   disclaimer in the documentation and/or other materials provided  *
N*   with the distribution.                                           *
N*                                                                    *
N* o Neither the name of SEGGER Microcontroller GmbH & Co. KG         *
N*   nor the names of its contributors may be used to endorse or      *
N*   promote products derived from this software without specific     *
N*   prior written permission.                                        *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SystemView version: V2.40a                                    *
N*                                                                    *
N**********************************************************************
N---------------------------END-OF-HEADER------------------------------
NFile    : SEGGER_RTT.h
NPurpose : Implementation of SEGGER real-time transfer which allows
N          real-time communication on targets which support debugger 
N          memory accesses while the CPU is running.
NRevision: $Rev: 3667 $
N----------------------------------------------------------------------
N*/
N
N#ifndef SEGGER_RTT_H
N#define SEGGER_RTT_H
N
N#include "SEGGER_RTT_Conf.h"
N
N/*********************************************************************
N*
N*       Defines, fixed
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N
N//
N// Description for a circular buffer (also called "ring buffer")
N// which is used as up-buffer (T->H)
N//
Ntypedef struct {
N  const     char*    sName;         // Optional name. Standard names so far are: "Terminal", "SysView", "J-Scope_t4i4"
N            char*    pBuffer;       // Pointer to start of buffer
N            unsigned SizeOfBuffer;  // Buffer size in bytes. Note that one byte is lost, as this implementation does not fill up the buffer in order to avoid the problem of being unable to distinguish between full and empty.
N            unsigned WrOff;         // Position of next item to be written by either target.
N  volatile  unsigned RdOff;         // Position of next item to be read by host. Must be volatile since it may be modified by host.
N            unsigned Flags;         // Contains configuration flags
N} SEGGER_RTT_BUFFER_UP;
N
N//
N// Description for a circular buffer (also called "ring buffer")
N// which is used as down-buffer (H->T)
N//
Ntypedef struct {
N  const     char*    sName;         // Optional name. Standard names so far are: "Terminal", "SysView", "J-Scope_t4i4"
N            char*    pBuffer;       // Pointer to start of buffer
N            unsigned SizeOfBuffer;  // Buffer size in bytes. Note that one byte is lost, as this implementation does not fill up the buffer in order to avoid the problem of being unable to distinguish between full and empty.
N  volatile  unsigned WrOff;         // Position of next item to be written by host. Must be volatile since it may be modified by host.
N            unsigned RdOff;         // Position of next item to be read by target (down-buffer).
N            unsigned Flags;         // Contains configuration flags
N} SEGGER_RTT_BUFFER_DOWN;
N
N//
N// RTT control block which describes the number of buffers available
N// as well as the configuration for each buffer
N//
N//
Ntypedef struct {
N  char                    acID[16];                                 // Initialized to "SEGGER RTT"
N  int                     MaxNumUpBuffers;                          // Initialized to SEGGER_RTT_MAX_NUM_UP_BUFFERS (type. 2)
N  int                     MaxNumDownBuffers;                        // Initialized to SEGGER_RTT_MAX_NUM_DOWN_BUFFERS (type. 2)
N  SEGGER_RTT_BUFFER_UP    aUp[SEGGER_RTT_MAX_NUM_UP_BUFFERS];       // Up buffers, transferring information up from target via debug probe to host
X  SEGGER_RTT_BUFFER_UP    aUp[(3)];       
N  SEGGER_RTT_BUFFER_DOWN  aDown[SEGGER_RTT_MAX_NUM_DOWN_BUFFERS];   // Down buffers, transferring information down from host via debug probe to target
X  SEGGER_RTT_BUFFER_DOWN  aDown[(3)];   
N} SEGGER_RTT_CB;
N
N/*********************************************************************
N*
N*       Global data
N*
N**********************************************************************
N*/
Nextern SEGGER_RTT_CB _SEGGER_RTT;
N
N/*********************************************************************
N*
N*       RTT API functions
N*
N**********************************************************************
N*/
N#ifdef __cplusplus
S  extern "C" {
N#endif
Nint          SEGGER_RTT_AllocDownBuffer  (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
Nint          SEGGER_RTT_AllocUpBuffer    (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
Nint          SEGGER_RTT_ConfigUpBuffer   (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
Nint          SEGGER_RTT_ConfigDownBuffer (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
Nint          SEGGER_RTT_GetKey           (void);
Nunsigned     SEGGER_RTT_HasData          (unsigned BufferIndex);
Nint          SEGGER_RTT_HasKey           (void);
Nvoid         SEGGER_RTT_Init             (void);
Nunsigned     SEGGER_RTT_Read             (unsigned BufferIndex,       void* pBuffer, unsigned BufferSize);
Nunsigned     SEGGER_RTT_ReadNoLock       (unsigned BufferIndex,       void* pData,   unsigned BufferSize);
Nint          SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName);
Nint          SEGGER_RTT_SetNameUpBuffer  (unsigned BufferIndex, const char* sName);
Nint          SEGGER_RTT_WaitKey          (void);
Nunsigned     SEGGER_RTT_Write            (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_WriteNoLock      (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_WriteSkipNoLock  (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_WriteString      (unsigned BufferIndex, const char* s);
Nvoid         SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
N//
N// Function macro for performance optimization
N//
N#define      SEGGER_RTT_HASDATA(n)       (_SEGGER_RTT.aDown[n].WrOff - _SEGGER_RTT.aDown[n].RdOff)
N
N/*********************************************************************
N*
N*       RTT "Terminal" API functions
N*
N**********************************************************************
N*/
Nint     SEGGER_RTT_SetTerminal        (char TerminalId);
Nint     SEGGER_RTT_TerminalOut        (char TerminalId, const char* s);
N
N/*********************************************************************
N*
N*       RTT printf functions (require SEGGER_RTT_printf.c)
N*
N**********************************************************************
N*/
Nint SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...);
N#ifdef __cplusplus
S  }
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N
N//
N// Operating modes. Define behavior if buffer is full (not enough space for entire message)
N//
N#define SEGGER_RTT_MODE_NO_BLOCK_SKIP         (0U)     // Skip. Do not block, output nothing. (Default)
N#define SEGGER_RTT_MODE_NO_BLOCK_TRIM         (1U)     // Trim: Do not block, output as much as fits.
N#define SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL    (2U)     // Block: Wait until there is space in the buffer.
N#define SEGGER_RTT_MODE_MASK                  (3U)
N
N//
N// Control sequences, based on ANSI.
N// Can be used to control color, and clear the screen
N//
N#define RTT_CTRL_RESET                "[0m"         // Reset to default colors
N#define RTT_CTRL_CLEAR                "[2J"         // Clear screen, reposition cursor to top left
N
N#define RTT_CTRL_TEXT_BLACK           "[2;30m"
N#define RTT_CTRL_TEXT_RED             "[2;31m"
N#define RTT_CTRL_TEXT_GREEN           "[2;32m"
N#define RTT_CTRL_TEXT_YELLOW          "[2;33m"
N#define RTT_CTRL_TEXT_BLUE            "[2;34m"
N#define RTT_CTRL_TEXT_MAGENTA         "[2;35m"
N#define RTT_CTRL_TEXT_CYAN            "[2;36m"
N#define RTT_CTRL_TEXT_WHITE           "[2;37m"
N
N#define RTT_CTRL_TEXT_BRIGHT_BLACK    "[1;30m"
N#define RTT_CTRL_TEXT_BRIGHT_RED      "[1;31m"
N#define RTT_CTRL_TEXT_BRIGHT_GREEN    "[1;32m"
N#define RTT_CTRL_TEXT_BRIGHT_YELLOW   "[1;33m"
N#define RTT_CTRL_TEXT_BRIGHT_BLUE     "[1;34m"
N#define RTT_CTRL_TEXT_BRIGHT_MAGENTA  "[1;35m"
N#define RTT_CTRL_TEXT_BRIGHT_CYAN     "[1;36m"
N#define RTT_CTRL_TEXT_BRIGHT_WHITE    "[1;37m"
N
N#define RTT_CTRL_BG_BLACK             "[24;40m"
N#define RTT_CTRL_BG_RED               "[24;41m"
N#define RTT_CTRL_BG_GREEN             "[24;42m"
N#define RTT_CTRL_BG_YELLOW            "[24;43m"
N#define RTT_CTRL_BG_BLUE              "[24;44m"
N#define RTT_CTRL_BG_MAGENTA           "[24;45m"
N#define RTT_CTRL_BG_CYAN              "[24;46m"
N#define RTT_CTRL_BG_WHITE             "[24;47m"
N
N#define RTT_CTRL_BG_BRIGHT_BLACK      "[4;40m"
N#define RTT_CTRL_BG_BRIGHT_RED        "[4;41m"
N#define RTT_CTRL_BG_BRIGHT_GREEN      "[4;42m"
N#define RTT_CTRL_BG_BRIGHT_YELLOW     "[4;43m"
N#define RTT_CTRL_BG_BRIGHT_BLUE       "[4;44m"
N#define RTT_CTRL_BG_BRIGHT_MAGENTA    "[4;45m"
N#define RTT_CTRL_BG_BRIGHT_CYAN       "[4;46m"
N#define RTT_CTRL_BG_BRIGHT_WHITE      "[4;47m"
N
N
N#endif
N
N/*************************** End of file ****************************/
L 150 "..\..\User\SEGGER\SEGGER_SYSVIEW.c" 2
N#include <string.h>
L 1 "C:\Program1\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 151 "..\..\User\SEGGER\SEGGER_SYSVIEW.c" 2
N#include <stdlib.h>
L 1 "C:\Program1\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 152 "..\..\User\SEGGER\SEGGER_SYSVIEW.c" 2
N#include <stdarg.h>
L 1 "C:\Program1\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
S     /* be cooperative with glibc */
S     typedef __CLIBNS va_list __gnuc_va_list;
S     #define __GNUC_VA_LIST
S     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 153 "..\..\User\SEGGER\SEGGER_SYSVIEW.c" 2
N
N/*********************************************************************
N*
N*       Defines, fixed
N*
N**********************************************************************
N*/
N#if SEGGER_SYSVIEW_ID_SHIFT
X#if 2
N  #define SHRINK_ID(Id)   (((Id) - _SYSVIEW_Globals.RAMBaseAddress) >> SEGGER_SYSVIEW_ID_SHIFT)
N#else
S  #define SHRINK_ID(Id)   ((Id) - _SYSVIEW_Globals.RAMBaseAddress)
N#endif
N
N#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
X#if 1 > 0
N  #define CHANNEL_ID_UP   SEGGER_SYSVIEW_RTT_CHANNEL
N  #define CHANNEL_ID_DOWN SEGGER_SYSVIEW_RTT_CHANNEL
N#else
S  #define CHANNEL_ID_UP   _SYSVIEW_Globals.UpChannel
S  #define CHANNEL_ID_DOWN _SYSVIEW_Globals.DownChannel
N#endif
N
N/*********************************************************************
N*
N*       Defines, configurable
N*
N**********************************************************************
N*/
N// Timestamps may be less than full 32-bits, in which case we need to zero
N// the unused bits to properly handle overflows.
N// Note that this is a quite common scenario, as a 32-bit time such as
N// SysTick might be scaled down to reduce bandwith
N// or a 16-bit hardware time might be used.
N#if SEGGER_SYSVIEW_TIMESTAMP_BITS < 32  // Eliminate unused bits in case hardware timestamps are less than 32 bits
X#if 32 < 32  
S  #define MAKE_DELTA_32BIT(Delta) Delta <<= 32 - SEGGER_SYSVIEW_TIMESTAMP_BITS; \
S                                  Delta >>= 32 - SEGGER_SYSVIEW_TIMESTAMP_BITS;
X  #define MAKE_DELTA_32BIT(Delta) Delta <<= 32 - SEGGER_SYSVIEW_TIMESTAMP_BITS;                                   Delta >>= 32 - SEGGER_SYSVIEW_TIMESTAMP_BITS;
N#else
N  #define MAKE_DELTA_32BIT(Delta)
N#endif
N
N
N/*********************************************************************
N*
N*       Defines, fixed
N*
N**********************************************************************
N*/
N#define ENABLE_STATE_OFF        0
N#define ENABLE_STATE_ON         1
N#define ENABLE_STATE_DROPPING   2
N
N#define FORMAT_FLAG_LEFT_JUSTIFY   (1u << 0)
N#define FORMAT_FLAG_PAD_ZERO       (1u << 1)
N#define FORMAT_FLAG_PRINT_SIGN     (1u << 2)
N#define FORMAT_FLAG_ALTERNATE      (1u << 3)
N
N#define MODULE_EVENT_OFFSET        (512)
N
N/*********************************************************************
N*
N*       Types, local
N*
N**********************************************************************
N*/
Ntypedef struct {
N  U8*       pBuffer;
X  unsigned char*       pBuffer;
N  U8*       pPayload;
X  unsigned char*       pPayload;
N  U8*       pPayloadStart;
X  unsigned char*       pPayloadStart;
N  U32       Options;
X  unsigned long       Options;
N  unsigned  Cnt;
N} SEGGER_SYSVIEW_PRINTF_DESC;
N
Ntypedef struct {
N        U8                      EnableState;   // 0: Disabled, 1: Enabled, (2: Dropping)
X        unsigned char                      EnableState;   
N        U8                      UpChannel;
X        unsigned char                      UpChannel;
N        U8                      RecursionCnt;
X        unsigned char                      RecursionCnt;
N        U32                     SysFreq;
X        unsigned long                     SysFreq;
N        U32                     CPUFreq;
X        unsigned long                     CPUFreq;
N        U32                     LastTxTimeStamp;
X        unsigned long                     LastTxTimeStamp;
N        U32                     RAMBaseAddress;
X        unsigned long                     RAMBaseAddress;
N#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
X#if (0 == 1)
S        U32                     PacketCount;
N#else
N        U32                     DropCount;
X        unsigned long                     DropCount;
N        U8                      DownChannel;
X        unsigned char                      DownChannel;
N#endif
N        U32                     DisabledEvents;
X        unsigned long                     DisabledEvents;
N  const SEGGER_SYSVIEW_OS_API*  pOSAPI;
N        SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC*   pfSendSysDesc;
N} SEGGER_SYSVIEW_GLOBALS;
N
N/*********************************************************************
N*
N*       Function prototypes, required
N*
N**********************************************************************
N*/
Nstatic void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned EventId);
Xstatic void _SendPacket(unsigned char* pStartPacket, unsigned char* pEndPacket, unsigned EventId);
N
N/*********************************************************************
N*
N*       Static data
N*
N**********************************************************************
N*/
Nstatic const U8 _abSync[10] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
Xstatic const unsigned char _abSync[10] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
N
N#ifdef SEGGER_SYSVIEW_SECTION
S  #if (defined __GNUC__)
S    __attribute__ ((section (SEGGER_SYSVIEW_SECTION))) static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
S    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
S    __attribute__ ((section (SEGGER_SYSVIEW_SECTION))) static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
S    #endif
S  #elif (defined __ICCARM__) || (defined __ICCRX__)
S    #pragma location=SEGGER_SYSVIEW_SECTION
S    static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
S    #pragma location=SEGGER_SYSVIEW_SECTION
S    static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
S  #elif (defined __CC_ARM__)
S    __attribute__ ((section (SEGGER_SYSVIEW_SECTION), zero_init)) static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
S    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
S    __attribute__ ((section (SEGGER_SYSVIEW_SECTION), zero_init)) static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
S    #endif
S  #else
S    static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
S    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
S    static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
S    #endif
S  #endif
N#else
N    static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
X    static char _UpBuffer  [1024];
N    #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
X    #if (0 != 1)
N    static char _DownBuffer[8];  // Small, fixed-size buffer, for back-channel comms
N    #endif
N#endif
N
Nstatic SEGGER_SYSVIEW_GLOBALS _SYSVIEW_Globals;
N
Nstatic SEGGER_SYSVIEW_MODULE* _pFirstModule;
Nstatic U8                     _NumModules;
Xstatic unsigned char                     _NumModules;
N
N/*********************************************************************
N*
N*       Static code
N*
N**********************************************************************
N*/
N
N#define ENCODE_U32(pDest, Value) {                                                  \
N                                   U8* pSysviewPointer;                             \
N                                   U32 SysViewData;                                 \
N                                   pSysviewPointer = pDest;                         \
N                                   SysViewData = Value;                             \
N                                   while(SysViewData > 0x7F) {                      \
N                                     *pSysviewPointer++ = (U8)(SysViewData | 0x80); \
N                                     SysViewData >>= 7;                             \
N                                   };                                               \
N                                   *pSysviewPointer++ = (U8)SysViewData;            \
N                                   pDest = pSysviewPointer;                         \
N                                 };
X#define ENCODE_U32(pDest, Value) {                                                                                     U8* pSysviewPointer;                                                                U32 SysViewData;                                                                    pSysviewPointer = pDest;                                                            SysViewData = Value;                                                                while(SysViewData > 0x7F) {                                                           *pSysviewPointer++ = (U8)(SysViewData | 0x80);                                      SysViewData >>= 7;                                                                };                                                                                  *pSysviewPointer++ = (U8)SysViewData;                                               pDest = pSysviewPointer;                                                          };
N
N
N
N#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
X#if (1 == 1)
Nstatic U8 _aPacket[SEGGER_SYSVIEW_MAX_PACKET_SIZE];
Xstatic unsigned char _aPacket[9 + 128 + 2 * 5 + 16 * 5];
N
N#define RECORD_START(PacketSize)  SEGGER_SYSVIEW_LOCK();                            \
N                                  pPayloadStart = _PreparePacket(_aPacket);
X#define RECORD_START(PacketSize)  SEGGER_SYSVIEW_LOCK();                                                              pPayloadStart = _PreparePacket(_aPacket);
N
N#define RECORD_END()              SEGGER_SYSVIEW_UNLOCK()
N
N#else
S
S#define RECORD_START(PacketSize)  U8 aPacket[(PacketSize)];                         \
S                                  pPayloadStart = _PreparePacket(aPacket);          \
S
X#define RECORD_START(PacketSize)  U8 aPacket[(PacketSize)];                                                           pPayloadStart = _PreparePacket(aPacket);          
S#define RECORD_END()
S
N#endif
N
N/*********************************************************************
N*
N*       _EncodeData()
N*
N*  Function description
N*    Encode a byte buffer in variable-length format.
N*
N*  Parameters
N*    pPayload - Pointer to where string will be encoded.
N*    pSrc     - Pointer to data buffer to be encoded.
N*    NumBytes - Number of bytes in the buffer to be encoded.
N*
N*  Return value
N*    Pointer to the byte following the value, i.e. the first free
N*    byte in the payload and the next position to store payload
N*    content.
N*
N*  Additional information
N*    The data is encoded as a count byte followed by the contents
N*    of the data buffer.
N*    Make sure NumBytes + 1 bytes are free for the payload.
N*/
Nstatic U8* _EncodeData(U8* pPayload, const char* pSrc, unsigned NumBytes) {
Xstatic unsigned char* _EncodeData(unsigned char* pPayload, const char* pSrc, unsigned NumBytes) {
N  unsigned n;
N  //
N  n = 0;
N  *pPayload++ = NumBytes;
N  while (n < NumBytes) {
N    *pPayload++ = *pSrc++;
N    n++;
N  }
N  return pPayload;
N}
N
N/*********************************************************************
N*
N*       _EncodeStr()
N*
N*  Function description
N*    Encode a string in variable-length format.
N*
N*  Parameters
N*    pPayload - Pointer to where string will be encoded.
N*    pText    - String to encode.
N*    Limit    - Maximum number of characters to encode from string.
N*
N*  Return value
N*    Pointer to the byte following the value, i.e. the first free
N*    byte in the payload and the next position to store payload
N*    content.
N*
N*  Additional information
N*    The string is encoded as a count byte followed by the contents
N*    of the string.
N*    No more than 1 + Limit bytes will be encoded to the payload.
N*/
Nstatic U8 *_EncodeStr(U8 *pPayload, const char *pText, unsigned Limit) {
Xstatic unsigned char *_EncodeStr(unsigned char *pPayload, const char *pText, unsigned Limit) {
N  unsigned n;
N  unsigned Len;
N  //
N  // Compute string len
N  //
N  Len = 0;
N  while(*(pText + Len) != 0) {
N    Len++;
N  }
N  if (Len > Limit) {
N    Len = Limit;
N  }
N  //
N  // Write Len
N  //
N  if (Len < 255)  {
N    *pPayload++ = Len; 
N  } else {
N    *pPayload++ = 255;
N    *pPayload++ = (Len & 255);
N    *pPayload++ = ((Len >> 8) & 255);
N  }
N  //
N  // copy string
N  //
N  n = 0;
N  while (n < Len) {
N    *pPayload++ = *pText++;
N    n++;
N  }
N  return pPayload;
N}
N
N/*********************************************************************
N*
N*       _PreparePacket()
N*
N*  Function description
N*    Prepare a SystemView event packet header.
N*
N*  Parameters
N*    pPacket - Pointer to start of packet to initialize.
N*
N*  Return value
N*    Pointer to first byte of packet payload.
N*
N*  Additional information
N*    The payload length and evnetId are not initialized.
N*    PreparePacket only reserves space for them and they are
N*    computed and filled in by the sending function.
N*/
Nstatic U8* _PreparePacket(U8* pPacket) {
Xstatic unsigned char* _PreparePacket(unsigned char* pPacket) {
N  return pPacket + 4;
N}
N
N/*********************************************************************
N*
N*       _HandleIncomingPacket()
N*
N*  Function description
N*    Read an incoming command from the down channel and process it.
N*
N*  Additional information
N*    This function is called each time after sending a packet.
N*    Processing incoming packets is done asynchronous. SystemView might
N*    already have sent event packets after the host has sent a command.
N*/
N#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
X#if (0 != 1)
Nstatic void _HandleIncomingPacket(void) {
N  U8  Cmd;
X  unsigned char  Cmd;
N  int Status;
N  //
N  Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
X  Status = SEGGER_RTT_ReadNoLock(1, &Cmd, 1);
N  if (Status > 0) {
N    switch (Cmd) {
N    case SEGGER_SYSVIEW_COMMAND_ID_START:
N      SEGGER_SYSVIEW_Start();
N      break;
N    case SEGGER_SYSVIEW_COMMAND_ID_STOP:
N      SEGGER_SYSVIEW_Stop();
N      break;
N    case SEGGER_SYSVIEW_COMMAND_ID_GET_SYSTIME:
N      SEGGER_SYSVIEW_RecordSystime();
N      break;
N    case SEGGER_SYSVIEW_COMMAND_ID_GET_TASKLIST:
N      SEGGER_SYSVIEW_SendTaskList();
N      break;
N    case SEGGER_SYSVIEW_COMMAND_ID_GET_SYSDESC:
N      SEGGER_SYSVIEW_GetSysDesc();
N      break;
N    case SEGGER_SYSVIEW_COMMAND_ID_GET_NUMMODULES:
N      SEGGER_SYSVIEW_SendNumModules();
N      break;
N    case SEGGER_SYSVIEW_COMMAND_ID_GET_MODULEDESC:
N      SEGGER_SYSVIEW_SendModuleDescription();
N      break;
N    case SEGGER_SYSVIEW_COMMAND_ID_GET_MODULE:
N      Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
X      Status = SEGGER_RTT_ReadNoLock(1, &Cmd, 1);
N      if (Status > 0) {
N        SEGGER_SYSVIEW_SendModule(Cmd);
N      }
N      break;
N    default:
N      if (Cmd >= 128) { // Unknown extended command. Dummy read its parameter.
N        SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
X        SEGGER_RTT_ReadNoLock(1, &Cmd, 1);
N      }
N      break;
N    }
N  }
N}
N#endif // (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
N
N/*********************************************************************
N*
N*       _TrySendOverflowPacket()
N*
N*  Function description
N*    Try to transmit an SystemView Overflow packet containing the
N*    number of dropped packets.
N*
N*  Additional information
N*    Format as follows:
N*      01 <DropCnt><TimeStamp>  Max. packet len is 1 + 5 + 5 = 11
N*
N*    Example packets sent
N*      01 20 40
N*
N*  Return value
N*    !=0:  Success, Message sent (stored in RTT-Buffer)
N*    ==0:  Buffer full, Message *NOT* stored
N*
N*/
N#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
X#if (0 != 1)
Nstatic int _TrySendOverflowPacket(void) {
N  U32 TimeStamp;
X  unsigned long TimeStamp;
N  I32 Delta;
X  signed long Delta;
N  int Status;
N  U8  aPacket[11];
X  unsigned char  aPacket[11];
N  U8* pPayload;
X  unsigned char* pPayload;
N
N  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
X  aPacket[0] = 1;      
N  pPayload   = &aPacket[1];
N  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = _SYSVIEW_Globals . DropCount; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  //
N  // Compute time stamp delta and append it to packet.
N  //
N  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
X  TimeStamp  = (*(unsigned long *)(0xE0001004));
N  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
N  MAKE_DELTA_32BIT(Delta);
X  ;
N  ENCODE_U32(pPayload, Delta);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Delta; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  //
N  // Try to store packet in RTT buffer and update time stamp when this was successful
N  //
N  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
X  Status = SEGGER_RTT_WriteSkipNoLock(1, aPacket, pPayload - aPacket);
N  if (Status) {
N    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
N    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
N  } else {
N    _SYSVIEW_Globals.DropCount++;
N  }
N  //
N  return Status;
N}
N#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
N
N/*********************************************************************
N*
N*       _SendSyncInfo()
N*
N*  Function description
N*    Send SystemView sync packet and system information in 
N*    post mortem mode.
N*
N*  Additional information
N*    Sync is 10 * 0x00 without timestamp
N*/
N#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
X#if (0 == 1)
Sstatic void _SendSyncInfo(void) {
S  //
S  // Add sync packet ( 10 * 0x00)
S  // Send system description
S  // Send system time
S  // Send task list
S  // Send module description
S  // Send module information
S  //
S  SEGGER_RTT_WriteWithOverwriteNoLock(CHANNEL_ID_UP, _abSync, 10);
S  SEGGER_SYSVIEW_RecordVoid(SYSVIEW_EVTID_TRACE_START);
S  {
S    U8* pPayload;
S    U8* pPayloadStart;
S    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
S    //
S    pPayload = pPayloadStart;
S    ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
S    ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
S    ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
S    ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
S    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
S    RECORD_END();
S  }
S  if (_SYSVIEW_Globals.pfSendSysDesc) {
S    _SYSVIEW_Globals.pfSendSysDesc();
S  }
S  SEGGER_SYSVIEW_RecordSystime();
S  SEGGER_SYSVIEW_SendTaskList();
S  if (_NumModules > 0) {
S    SEGGER_SYSVIEW_SendNumModules();
S    for (int n = 0; n < _NumModules; n++) {
S      SEGGER_SYSVIEW_SendModule(n);
S    }
S    SEGGER_SYSVIEW_SendModuleDescription();
S  }
S}
N#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
N
N/*********************************************************************
N*
N*       _SendPacket()
N*
N*  Function description
N*    Send a SystemView packet over RTT. RTT channel and mode are
N*    configured by macros when the SystemView component is initialized.
N*    This function takes care of maintaining the packet drop count
N*    and sending overflow packets when necessary.
N*    The packet must be passed without Id and Length because this
N*    function prepends it to the packet before transmission.
N*
N*  Parameters
N*    pStartPacket - Pointer to start of packet payload.
N*                   There must be at least 4 bytes free to prepend Id and Length.
N*    pEndPacket   - Pointer to end of packet payload.
N*    EventId      - Id of the event to send.
N*
N*/
Nstatic void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned EventId) {
Xstatic void _SendPacket(unsigned char* pStartPacket, unsigned char* pEndPacket, unsigned EventId) {
N  unsigned  NumBytes;
N  U32 TimeStamp;
X  unsigned long TimeStamp;
N  U32 Delta;
X  unsigned long Delta;
N#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
X#if (0 != 1)
N  int Status;
N#endif
N
N#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0)
X#if (1 == 0)
S  SEGGER_SYSVIEW_LOCK();
N#endif
N
N#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
X#if (0 == 1)
S  if (_SYSVIEW_Globals.EnableState == 0) {
S    goto SendDone;
S  }
N#else
N  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
N    goto Send;
N  }
N  if (_SYSVIEW_Globals.EnableState == 0) {
N    goto SendDone;
N  }
N  //
N  // Handle buffer full situations:
N  // Have packets been dropped before because buffer was full?
N  // In this case try to send and overflow packet.
N  //
N  if (_SYSVIEW_Globals.EnableState == 2) {
N    _TrySendOverflowPacket();
N    if (_SYSVIEW_Globals.EnableState != 1) {
N      goto SendDone;
N    }
N  }
NSend:
N#endif
N  //
N  // Check if event is disabled from being recorded.
N  //
N  if (EventId < 32) {
N    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
X    if (_SYSVIEW_Globals.DisabledEvents & ((unsigned long)1u << EventId)) {
N      goto SendDone;
N    }
N  }
N  //
N  // Prepare actual packet.
N  // If it is a known packet, prepend eventId only,
N  // otherwise prepend packet length and eventId.
N  //
N  if (EventId < 24) {
N    *--pStartPacket = EventId;
N  } else {
N    NumBytes = pEndPacket - pStartPacket;
N    if (NumBytes > 127) {
N      *--pStartPacket = (NumBytes >> 7);
N      *--pStartPacket = NumBytes | 0x80;
N    } else {
N      *--pStartPacket = NumBytes;
N    }
N    if (EventId > 127) {
N      *--pStartPacket = (EventId >> 7);
N      *--pStartPacket = EventId | 0x80;
N    } else {
N      *--pStartPacket = EventId;
N    }
N  }
N  //
N  // Compute time stamp delta and append it to packet.
N  //
N  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
X  TimeStamp  = (*(unsigned long *)(0xE0001004));
N  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
N  MAKE_DELTA_32BIT(Delta);
X  ;
N  ENCODE_U32(pEndPacket, Delta);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pEndPacket; SysViewData = Delta; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pEndPacket = pSysviewPointer; };;
N#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
X#if (0 == 1)
S  //
S  // Store packet in RTT buffer by overwriting old data and update time stamp
S  //
S  SEGGER_RTT_WriteWithOverwriteNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
S  _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
N#else
N  //
N  // Try to store packet in RTT buffer and update time stamp when this was successful
N  //
N  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
X  Status = SEGGER_RTT_WriteSkipNoLock(1, pStartPacket, pEndPacket - pStartPacket);
N  if (Status) {
N    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
N  } else {
N    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
N  }
N#endif
N
N#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
X#if (0 == 1)
S  //
S  // Add sync and system information periodically if we are in post mortem mode
S  //
S  if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
S    _SYSVIEW_Globals.RecursionCnt = 1;
S    if (_SYSVIEW_Globals.PacketCount++ & (1 << SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT)) {
S      _SendSyncInfo();
S      _SYSVIEW_Globals.PacketCount = 0;
S    }
S    _SYSVIEW_Globals.RecursionCnt = 0;
S  }
SSendDone:
S  ; // Avoid "label at end of compound statement" error when using static buffer
N#else
NSendDone:
N  //
N  // Check if host is sending data which needs to be processed.
N  // Note that since this code is called for every packet, it is very time critical, so we do
N  // only what is really needed here, which is checking if there is any data
N  //
N  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
X  if ((_SEGGER_RTT . aDown[1]. WrOff - _SEGGER_RTT . aDown[1]. RdOff)) {
N    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
N      _SYSVIEW_Globals.RecursionCnt = 1;
N      _HandleIncomingPacket();
N      _SYSVIEW_Globals.RecursionCnt = 0;
N    }
N  }
N#endif
N  //
N#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0)
X#if (1 == 0)
S  SEGGER_SYSVIEW_UNLOCK();  // We are done. Unlock and return
N#endif
N}
N
N#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
N/*********************************************************************
N*
N*       _APrintHost()
N*
N*  Function description
N*    Prepares a string and its parameters to be formatted on the host.
N*
N*  Parameters
N*    s            Pointer to format string.
N*    Options      Options to be sent to the host.
N*    pArguments   Pointer to array of arguments for the format string.
N*    NumArguments Number of arguments in the array.
N*/
Nstatic void _APrintHost(const char* s, U32 Options, U32* pArguments, U32 NumArguments) {
Xstatic void _APrintHost(const char* s, unsigned long Options, unsigned long* pArguments, unsigned long NumArguments) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_ARGUMENTS * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
X  pPayload = _EncodeStr(pPayloadStart, s, 128);
N  ENCODE_U32(pPayload, Options);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Options; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, NumArguments);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = NumArguments; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  while (NumArguments--) {
N    ENCODE_U32(pPayload, (*pArguments++));
X    { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = (*pArguments++); while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  }
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
X  _SendPacket(pPayloadStart, pPayload, 26);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       _VPrintHost()
N*
N*  Function description
N*    Prepares a string and its parameters to be formatted on the host.
N*
N*  Parameters
N*    s            Pointer to format string.
N*    Options      Options to be sent to the host.
N*    pParamList   Pointer to the list of arguments for the format string.
N*/
Nstatic void _VPrintHost(const char* s, U32 Options, va_list* pParamList) {
Xstatic void _VPrintHost(const char* s, unsigned long Options, va_list* pParamList) {
N  U32 aParas[SEGGER_SYSVIEW_MAX_ARGUMENTS];
X  unsigned long aParas[16];
N  U32 NumArguments;
X  unsigned long NumArguments;
N  const char* p;
N  
N  p = s;
N  NumArguments = 0;
N  while (*p) {
N    if (*p == '%') {
N      aParas[NumArguments++] = va_arg(*pParamList, int);
X      aParas[NumArguments++] = __va_arg(*pParamList, int);
N      if (NumArguments == SEGGER_SYSVIEW_MAX_ARGUMENTS) {
X      if (NumArguments == 16) {
N        break;
N      }
N    }
N    p++;
N  }
N  _APrintHost(s, Options, aParas, NumArguments);
N}
N
N/*********************************************************************
N*
N*       _StoreChar()
N*
N*  Function description
N*    Stores a character in the printf-buffer and sends the buffer when
N*     it is filled.
N*
N*  Parameters
N*    p            Pointer to the buffer description.
N*    c            Character to be printed.
N*/
Nstatic void _StoreChar(SEGGER_SYSVIEW_PRINTF_DESC * p, char c) {
N  unsigned Cnt;
N  U8* pPayload;
X  unsigned char* pPayload;
N  U32 Options;
X  unsigned long Options;
N
N  Cnt = p->Cnt;
N  if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
X  if ((Cnt + 1u) <= 128) {
N    *(p->pPayload++) = c;
N    p->Cnt = Cnt + 1u;
N  }
N  //
N  // Write part of string, when the buffer is full
N  //
N  if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
X  if (p->Cnt == 128) {
N    *(p->pPayloadStart) = p->Cnt;
N    pPayload = p->pPayload;
N    Options = p->Options;
N    ENCODE_U32(pPayload, Options);
X    { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Options; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N    ENCODE_U32(pPayload, 0);
X    { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = 0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N    _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
X    _SendPacket(p->pPayloadStart, pPayload, 26);
N    p->pPayloadStart = _PreparePacket(p->pBuffer);
N    p->pPayload = p->pPayloadStart + 1u;
N    p->Cnt = 0u;
N  }
N}
N
N/*********************************************************************
N*
N*       _PrintUnsigned()
N*
N*  Function description
N*    Print an unsigned integer with the given formatting into the 
N*     formatted string.
N*
N*  Parameters
N*    pBufferDesc  Pointer to the buffer description.
N*    v            Value to be printed.
N*    Base         Base of the value.
N*    NumDigits    Number of digits to be printed.
N*    FieldWidth   Width of the printed field.
N*    FormatFlags  Flags for formatting the value.
N*/
Nstatic void _PrintUnsigned(SEGGER_SYSVIEW_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
N  static const char _aV2C[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
N  unsigned Div;
N  unsigned Digit;
N  unsigned Number;
N  unsigned Width;
N  char c;
N
N  Number = v;
N  Digit = 1u;
N  //
N  // Get actual field width
N  //
N  Width = 1u;
N  while (Number >= Base) {
N    Number = (Number / Base);
N    Width++;
N  }
N  if (NumDigits > Width) {
N    Width = NumDigits;
N  }
N  //
N  // Print leading chars if necessary
N  //
N  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
X  if ((FormatFlags & (1u << 0)) == 0u) {
N    if (FieldWidth != 0u) {
N      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
X      if (((FormatFlags & (1u << 1)) == (1u << 1)) && (NumDigits == 0u)) {
N        c = '0';
N      } else {
N        c = ' ';
N      }
N      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
N        FieldWidth--;
N        _StoreChar(pBufferDesc, c);
N      }
N    }
N  }
N  //
N  // Compute Digit.
N  // Loop until Digit has the value of the highest digit required.
N  // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
N  //
N  while (1) {
N    if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
N      NumDigits--;
N    } else {
N      Div = v / Digit;
N      if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
N        break;
N      }
N    }
N    Digit *= Base;
N  }
N  //
N  // Output digits
N  //
N  do {
N    Div = v / Digit;
N    v -= Div * Digit;
N    _StoreChar(pBufferDesc, _aV2C[Div]);
N    Digit /= Base;
N  } while (Digit);
N  //
N  // Print trailing spaces if necessary
N  //
N  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
X  if ((FormatFlags & (1u << 0)) == (1u << 0)) {
N    if (FieldWidth != 0u) {
N      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
N        FieldWidth--;
N        _StoreChar(pBufferDesc, ' ');
N      }
N    }
N  }
N}
N
N/*********************************************************************
N*
N*       _PrintInt()
N*
N*  Function description
N*    Print a signed integer with the given formatting into the 
N*     formatted string.
N*
N*  Parameters
N*    pBufferDesc  Pointer to the buffer description.
N*    v            Value to be printed.
N*    Base         Base of the value.
N*    NumDigits    Number of digits to be printed.
N*    FieldWidth   Width of the printed field.
N*    FormatFlags  Flags for formatting the value.
N*/
Nstatic void _PrintInt(SEGGER_SYSVIEW_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
N  unsigned Width;
N  int Number;
N
N  Number = (v < 0) ? -v : v;
N
N  //
N  // Get actual field width
N  //
N  Width = 1u;
N  while (Number >= (int)Base) {
N    Number = (Number / (int)Base);
N    Width++;
N  }
N  if (NumDigits > Width) {
N    Width = NumDigits;
N  }
N  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
X  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & (1u << 2)) == (1u << 2)))) {
N    FieldWidth--;
N  }
N
N  //
N  // Print leading spaces if necessary
N  //
N  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
X  if ((((FormatFlags & (1u << 1)) == 0u) || (NumDigits != 0u)) && ((FormatFlags & (1u << 0)) == 0u)) {
N    if (FieldWidth != 0u) {
N      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
N        FieldWidth--;
N        _StoreChar(pBufferDesc, ' ');
N      }
N    }
N  }
N  //
N  // Print sign if necessary
N  //
N  if (v < 0) {
N    v = -v;
N    _StoreChar(pBufferDesc, '-');
N  } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
X  } else if ((FormatFlags & (1u << 2)) == (1u << 2)) {
N    _StoreChar(pBufferDesc, '+');
N  } else {
N
N  }
N  //
N  // Print leading zeros if necessary
N  //
N  if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
X  if (((FormatFlags & (1u << 1)) == (1u << 1)) && ((FormatFlags & (1u << 0)) == 0u) && (NumDigits == 0u)) {
N    if (FieldWidth != 0u) {
N      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
N        FieldWidth--;
N        _StoreChar(pBufferDesc, '0');
N      }
N    }
N  }
N  //
N  // Print number without sign
N  //
N  _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
N}
N
N/*********************************************************************
N*
N*       _VPrintTarget()
N*
N*  Function description
N*    Stores a formatted string.
N*    This data is read by the host.
N*
N*  Parameters
N*    sFormat      Pointer to format string.
N*    Options      Options to be sent to the host.
N*    pParamList   Pointer to the list of arguments for the format string.
N*/
Nstatic void _VPrintTarget(const char* sFormat, U32 Options, va_list* pParamList) {
Xstatic void _VPrintTarget(const char* sFormat, unsigned long Options, va_list* pParamList) {
N  SEGGER_SYSVIEW_PRINTF_DESC BufferDesc;
N  char      c;
N  int       v;
N  unsigned  NumDigits;
N  unsigned  FormatFlags;
N  unsigned  FieldWidth;
N  U8*       pPayloadStart;
X  unsigned char*       pPayloadStart;
N#if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
X#if 1 == 0
S  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 1 + 2 * SEGGER_SYSVIEW_QUANTA_U32);
S  SEGGER_SYSVIEW_LOCK();
N#else
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 1 + 2 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N#endif
N
N#if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
X#if 1 == 0
S  BufferDesc.pBuffer        = aPacket;
N#else
N  BufferDesc.pBuffer        = _aPacket;
N#endif
N  BufferDesc.Cnt            = 0u;
N  BufferDesc.pPayloadStart  = pPayloadStart;
N  BufferDesc.pPayload       = BufferDesc.pPayloadStart + 1u;
N  BufferDesc.Options        =  Options;
N
N  do {
N    c = *sFormat;
N    sFormat++;
N    if (c == 0u) {
N      break;
N    }
N    if (c == '%') {
N      //
N      // Filter out flags
N      //
N      FormatFlags = 0u;
N      v = 1;
N      do {
N        c = *sFormat;
N        switch (c) {
N        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
X        case '-': FormatFlags |= (1u << 0); sFormat++; break;
N        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
X        case '0': FormatFlags |= (1u << 1);     sFormat++; break;
N        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
X        case '+': FormatFlags |= (1u << 2);   sFormat++; break;
N        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
X        case '#': FormatFlags |= (1u << 3);    sFormat++; break;
N        default:  v = 0; break;
N        }
N      } while (v);
N      //
N      // filter out field with
N      //
N      FieldWidth = 0u;
N      do {
N        c = *sFormat;
N        if ((c < '0') || (c > '9')) {
N          break;
N        }
N        sFormat++;
N        FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
N      } while (1);
N
N      //
N      // Filter out precision (number of digits to display)
N      //
N      NumDigits = 0u;
N      c = *sFormat;
N      if (c == '.') {
N        sFormat++;
N        do {
N          c = *sFormat;
N          if ((c < '0') || (c > '9')) {
N            break;
N          }
N          sFormat++;
N          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
N        } while (1);
N      }
N      //
N      // Filter out length modifier
N      //
N      c = *sFormat;
N      do {
N        if ((c == 'l') || (c == 'h')) {
N          c = *sFormat;
N          sFormat++;
N        } else {
N          break;
N        }
N      } while (1);
N      //
N      // Handle specifiers
N      //
N      switch (c) {
N      case 'c': {
N        char c0;
N        v = va_arg(*pParamList, int);
X        v = __va_arg(*pParamList, int);
N        c0 = (char)v;
N        _StoreChar(&BufferDesc, c0);
N        break;
N      }
N      case 'd':
N        v = va_arg(*pParamList, int);
X        v = __va_arg(*pParamList, int);
N        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
N        break;
N      case 'u':
N        v = va_arg(*pParamList, int);
X        v = __va_arg(*pParamList, int);
N        _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
N        break;
N      case 'x':
N      case 'X':
N        v = va_arg(*pParamList, int);
X        v = __va_arg(*pParamList, int);
N        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
N        break;
N      case 'p':
N        v = va_arg(*pParamList, int);
X        v = __va_arg(*pParamList, int);
N        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
N        break;
N      case '%':
N        _StoreChar(&BufferDesc, '%');
N        break;
N      default:
N        break;
N      }
N      sFormat++;
N    } else {
N      _StoreChar(&BufferDesc, c);
N    }
N  } while (*sFormat);
N
N  //
N  // Write remaining data, if any
N  //
N  if (BufferDesc.Cnt != 0u) {
N    *(BufferDesc.pPayloadStart) = BufferDesc.Cnt;
N    ENCODE_U32(BufferDesc.pPayload, BufferDesc.Options);
X    { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = BufferDesc . pPayload; SysViewData = BufferDesc . Options; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; BufferDesc . pPayload = pSysviewPointer; };;
N    ENCODE_U32(BufferDesc.pPayload, 0);
X    { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = BufferDesc . pPayload; SysViewData = 0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; BufferDesc . pPayload = pSysviewPointer; };;
N    _SendPacket(BufferDesc.pPayloadStart, BufferDesc.pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
X    _SendPacket(BufferDesc.pPayloadStart, BufferDesc.pPayload, 26);
N  }
N#if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
X#if 1 == 0
S  SEGGER_SYSVIEW_UNLOCK();
S  RECORD_END();
N#else
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N#endif
N}
N#endif // SEGGER_SYSVIEW_EXCLUDE_PRINTF
N
N/*********************************************************************
N*
N*       Public functions
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_Init()
N*
N*  Function description
N*    Initializes the SYSVIEW module.
N*    Must be called before SystemViewer attaches to the system.
N*
N*  Parameters
N*    SysFreq        - Frequency of timestamp, i.e. CPU core clock frequency.
N*    CPUFreq        - CPU core clock frequency.
N*    pOSAPI         - Pointer to the API structure for OS-specific functions.
N*    pfSendSysDesc  - Pointer to SendSysDesc callback function.
N*
N*  Additional information
N*    This function initializes the RTT channel used to transport 
N*    SEGGER SystemView packets. 
N*    The channel is assigned the label "SysView" for client software 
N*    to identify the SystemView channel.
N*
N*  Notes
N*    The channel is configured by the macro SEGGER_SYSVIEW_RTT_CHANNEL.
N*/
Nvoid SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
Xvoid SEGGER_SYSVIEW_Init(unsigned long SysFreq, unsigned long CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
N#ifdef SEGGER_RTT_SECTION
S  //
S  // Explicitly initialize the RTT Control Block if it is in its dedicated section.
S  //
S  SEGGER_RTT_Init();
N#endif
N#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
X#if (0 == 1)
S#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
S  SEGGER_RTT_ConfigUpBuffer(SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
S#else
S  _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
S#endif
S  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
S  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
S  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
S  _SYSVIEW_Globals.SysFreq          = SysFreq;
S  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
S  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
S  _SYSVIEW_Globals.EnableState      = 0;
S  _SYSVIEW_Globals.PacketCount      = 0;
N#else // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
N#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
X#if 1 > 0
N  SEGGER_RTT_ConfigUpBuffer   (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
X  SEGGER_RTT_ConfigUpBuffer   (1, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   (0U));
N  SEGGER_RTT_ConfigDownBuffer (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
X  SEGGER_RTT_ConfigDownBuffer (1, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), (0U));
N#else
S  _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
S  //
S  // TODO: Use SEGGER_RTT_AllocDownBuffer when SystemViewer is able to handle another Down Channel than Up Channel.
S  //
S  _SYSVIEW_Globals.DownChannel = _SYSVIEW_Globals.UpChannel;
S  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
N#endif
N  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
X  _SYSVIEW_Globals.RAMBaseAddress   = 0x10000000;
N  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
X  _SYSVIEW_Globals.LastTxTimeStamp  = (*(unsigned long *)(0xE0001004));
N  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
N  _SYSVIEW_Globals.SysFreq          = SysFreq;
N  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
N  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
N  _SYSVIEW_Globals.EnableState      = 0;
N#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_SetRAMBase()
N*
N*  Function description
N*    Sets the RAM base address, which is subtracted from IDs in order
N*     to save bandwidth.
N*
N*  Parameters
N*    RAMBaseAddress - Lowest RAM Address. (i.e. 0x20000000 on most Cortex-M)
N*/
Nvoid SEGGER_SYSVIEW_SetRAMBase(U32 RAMBaseAddress) {
Xvoid SEGGER_SYSVIEW_SetRAMBase(unsigned long RAMBaseAddress) {
N  _SYSVIEW_Globals.RAMBaseAddress = RAMBaseAddress;
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordVoid()
N*
N*  Function description
N*    Formats and sends a SystemView packet with an empty payload.
N*
N*  Parameters
N*    EventID - SystemView event ID.
N*/
Nvoid SEGGER_SYSVIEW_RecordVoid(unsigned EventID) {
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  _SendPacket(pPayloadStart, pPayloadStart, EventID);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordU32()
N*
N*  Function description
N*    Formats and sends a SystemView packet containing a single U32
N*    parameter payload.
N*
N*  Parameters
N*    EventID - SystemView event ID.
N*    Value   - The 32-bit parameter encoded to SystemView packet payload.
N*/
Nvoid SEGGER_SYSVIEW_RecordU32(unsigned EventID, U32 Value) {
Xvoid SEGGER_SYSVIEW_RecordU32(unsigned EventID, unsigned long Value) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, Value);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Value; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, EventID);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordU32x2()
N*
N*  Function description
N*    Formats and sends a SystemView packet containing 2 U32 parameter payload.
N*
N*  Parameters
N*    EventID - SystemView event ID.
N*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
N*/
Nvoid SEGGER_SYSVIEW_RecordU32x2(unsigned EventID, U32 Para0, U32 Para1) {
Xvoid SEGGER_SYSVIEW_RecordU32x2(unsigned EventID, unsigned long Para0, unsigned long Para1) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, Para0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para1);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para1; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, EventID);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordU32x3()
N*
N*  Function description
N*    Formats and sends a SystemView packet containing 3 U32 parameter payload.
N*
N*  Parameters
N*    EventID - SystemView event ID.
N*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
N*/
Nvoid SEGGER_SYSVIEW_RecordU32x3(unsigned EventID, U32 Para0, U32 Para1, U32 Para2) {
Xvoid SEGGER_SYSVIEW_RecordU32x3(unsigned EventID, unsigned long Para0, unsigned long Para1, unsigned long Para2) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 3 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, Para0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para1);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para1; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para2);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para2; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, EventID);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordU32x4()
N*
N*  Function description
N*    Formats and sends a SystemView packet containing 4 U32 parameter payload.
N*
N*  Parameters
N*    EventID - SystemView event ID.
N*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
N*/
Nvoid SEGGER_SYSVIEW_RecordU32x4(unsigned EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3) {
Xvoid SEGGER_SYSVIEW_RecordU32x4(unsigned EventID, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, Para0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para1);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para1; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para2);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para2; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para3);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para3; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, EventID);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordU32x5()
N*
N*  Function description
N*    Formats and sends a SystemView packet containing 5 U32 parameter payload.
N*
N*  Parameters
N*    EventID - SystemView event ID.
N*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
N*/
Nvoid SEGGER_SYSVIEW_RecordU32x5(unsigned EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4) {
Xvoid SEGGER_SYSVIEW_RecordU32x5(unsigned EventID, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3, unsigned long Para4) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 5 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, Para0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para1);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para1; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para2);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para2; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para3);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para3; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para4);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para4; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, EventID);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordU32x6()
N*
N*  Function description
N*    Formats and sends a SystemView packet containing 6 U32 parameter payload.
N*
N*  Parameters
N*    EventID - SystemView event ID.
N*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
N*/
Nvoid SEGGER_SYSVIEW_RecordU32x6(unsigned EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5) {
Xvoid SEGGER_SYSVIEW_RecordU32x6(unsigned EventID, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3, unsigned long Para4, unsigned long Para5) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 6 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, Para0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para1);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para1; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para2);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para2; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para3);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para3; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para4);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para4; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para5);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para5; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, EventID);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordU32x7()
N*
N*  Function description
N*    Formats and sends a SystemView packet containing 7 U32 parameter payload.
N*
N*  Parameters
N*    EventID - SystemView event ID.
N*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
N*/
Nvoid SEGGER_SYSVIEW_RecordU32x7(unsigned EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6) {
Xvoid SEGGER_SYSVIEW_RecordU32x7(unsigned EventID, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3, unsigned long Para4, unsigned long Para5, unsigned long Para6) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 7 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, Para0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para1);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para1; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para2);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para2; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para3);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para3; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para4);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para4; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para5);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para5; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para6);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para6; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, EventID);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordU32x8()
N*
N*  Function description
N*    Formats and sends a SystemView packet containing 8 U32 parameter payload.
N*
N*  Parameters
N*    EventID - SystemView event ID.
N*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para7   - The 32-bit parameter encoded to SystemView packet payload.
N*/
Nvoid SEGGER_SYSVIEW_RecordU32x8(unsigned EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7) {
Xvoid SEGGER_SYSVIEW_RecordU32x8(unsigned EventID, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3, unsigned long Para4, unsigned long Para5, unsigned long Para6, unsigned long Para7) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 8 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, Para0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para1);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para1; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para2);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para2; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para3);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para3; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para4);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para4; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para5);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para5; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para6);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para6; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para7);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para7; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, EventID);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordU32x9()
N*
N*  Function description
N*    Formats and sends a SystemView packet containing 9 U32 parameter payload.
N*
N*  Parameters
N*    EventID - SystemView event ID.
N*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para7   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para8   - The 32-bit parameter encoded to SystemView packet payload.
N*/
Nvoid SEGGER_SYSVIEW_RecordU32x9(unsigned EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8) {
Xvoid SEGGER_SYSVIEW_RecordU32x9(unsigned EventID, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3, unsigned long Para4, unsigned long Para5, unsigned long Para6, unsigned long Para7, unsigned long Para8) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 9 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, Para0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para1);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para1; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para2);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para2; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para3);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para3; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para4);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para4; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para5);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para5; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para6);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para6; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para7);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para7; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para8);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para8; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, EventID);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordU32x10()
N*
N*  Function description
N*    Formats and sends a SystemView packet containing 10 U32 parameter payload.
N*
N*  Parameters
N*    EventID - SystemView event ID.
N*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para3   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para4   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para5   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para6   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para7   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para8   - The 32-bit parameter encoded to SystemView packet payload.
N*    Para9   - The 32-bit parameter encoded to SystemView packet payload.
N*/
Nvoid SEGGER_SYSVIEW_RecordU32x10(unsigned EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8, U32 Para9) {
Xvoid SEGGER_SYSVIEW_RecordU32x10(unsigned EventID, unsigned long Para0, unsigned long Para1, unsigned long Para2, unsigned long Para3, unsigned long Para4, unsigned long Para5, unsigned long Para6, unsigned long Para7, unsigned long Para8, unsigned long Para9) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 10 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, Para0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para1);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para1; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para2);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para2; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para3);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para3; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para4);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para4; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para5);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para5; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para6);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para6; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para7);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para7; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para8);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para8; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para9);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para9; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, EventID);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordString()
N*
N*  Function description
N*    Formats and sends a SystemView packet containing a string.
N*
N*  Parameters
N*    EventID - SystemView event ID.
N*    pString - The string to be sent in the SystemView packet payload.
N*
N*  Additional information
N*    The string is encoded as a count byte followed by the contents
N*    of the string.
N*    No more than SEGGER_SYSVIEW_MAX_STRING_LEN bytes will be encoded to the payload.
N*/
Nvoid SEGGER_SYSVIEW_RecordString(unsigned EventID, const char* pString) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = _EncodeStr(pPayloadStart, pString, SEGGER_SYSVIEW_MAX_STRING_LEN);
X  pPayload = _EncodeStr(pPayloadStart, pString, 128);
N  _SendPacket(pPayloadStart, pPayload, EventID);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_Start()
N*
N*  Function description
N*    Start recording SystemView events.
N*    This function is triggered by the host application.
N*
N*  Additional information
N*    This function enables transmission of SystemView packets recorded
N*    by subsequent trace calls and records a SystemView Start event.
N*
N*    As part of start, a SystemView Init packet is sent, containing the system
N*    frequency. The list of current tasks, the current system time and the
N*    system description string is sent, too.
N*
N*  Notes
N*    SEGGER_SYSVIEW_Start and SEGGER_SYSVIEW_Stop do not nest.
N*/
Nvoid SEGGER_SYSVIEW_Start(void) {
N  if (_SYSVIEW_Globals.EnableState == 0) {
N    _SYSVIEW_Globals.EnableState = 1;
N#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
X#if (0 == 1)
S    _SendSyncInfo();
N#else
N    SEGGER_SYSVIEW_LOCK();
X    { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();;
N    SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, _abSync, 10);
X    SEGGER_RTT_WriteSkipNoLock(1, _abSync, 10);
N    SEGGER_SYSVIEW_UNLOCK();
X    BASEPRI = LockState; __schedule_barrier(); };
N    SEGGER_SYSVIEW_RecordVoid(SYSVIEW_EVTID_TRACE_START);
X    SEGGER_SYSVIEW_RecordVoid(10);
N    {
N      U8* pPayload;
X      unsigned char* pPayload;
N      U8* pPayloadStart;
X      unsigned char* pPayloadStart;
N      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
X      { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N      //
N      pPayload = pPayloadStart;
N      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
X      { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = _SYSVIEW_Globals . SysFreq; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
X      { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = _SYSVIEW_Globals . CPUFreq; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
X      { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = _SYSVIEW_Globals . RAMBaseAddress; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
X      { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = 2; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
X      _SendPacket(pPayloadStart, pPayload, 24);
N      RECORD_END();
X      BASEPRI = LockState; __schedule_barrier(); };
N    }
N    if (_SYSVIEW_Globals.pfSendSysDesc) {
N      _SYSVIEW_Globals.pfSendSysDesc();
N    }
N    SEGGER_SYSVIEW_RecordSystime();
N    SEGGER_SYSVIEW_SendTaskList();
N    SEGGER_SYSVIEW_SendNumModules();
N#endif
N  }
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_Stop()
N*
N*  Function description
N*    Stop recording SystemView events.
N*
N*  Additional information
N*    This function disables transmission of SystemView packets recorded
N*    by subsequent trace calls.  If transmission is enabled when
N*    this function is called, a single SystemView Stop event is recorded
N*    to the trace, send, and then trace transmission is halted.
N*/
Nvoid SEGGER_SYSVIEW_Stop(void) {
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  if (_SYSVIEW_Globals.EnableState) {
N    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TRACE_STOP);
X    _SendPacket(pPayloadStart, pPayloadStart, 11);
N    _SYSVIEW_Globals.EnableState = 0;
N  }
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_GetSysDesc()
N*
N*  Function description
N*    Triggers a send of the system information and description.
N*
N*/
Nvoid SEGGER_SYSVIEW_GetSysDesc(void) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = _SYSVIEW_Globals . SysFreq; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = _SYSVIEW_Globals . CPUFreq; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = _SYSVIEW_Globals . RAMBaseAddress; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = 2; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
X  _SendPacket(pPayloadStart, pPayload, 24);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N  if (_SYSVIEW_Globals.pfSendSysDesc) {
N    _SYSVIEW_Globals.pfSendSysDesc();
N  }
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_SendTaskInfo()
N*
N*  Function description
N*    Send a Task Info Packet, containing TaskId for identification,
N*    task priority and task name.
N*
N*  Parameters
N*    pInfo - Pointer to task information to send.
N*/
Nvoid SEGGER_SYSVIEW_SendTaskInfo(const SEGGER_SYSVIEW_TASKINFO *pInfo) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + 32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = (((pInfo->TaskID) - _SYSVIEW_Globals . RAMBaseAddress) >> 2); while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, pInfo->Prio);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = pInfo->Prio; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  pPayload = _EncodeStr(pPayload, pInfo->sName, 32);
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_INFO);
X  _SendPacket(pPayloadStart, pPayload, 9);
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = (((pInfo->TaskID) - _SYSVIEW_Globals . RAMBaseAddress) >> 2); while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, pInfo->StackBase);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = pInfo->StackBase; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, pInfo->StackSize);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = pInfo->StackSize; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, 0); // Stack End, future use
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = 0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };; 
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
X  _SendPacket(pPayloadStart, pPayload, 21);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_SendTaskList()
N*
N*  Function description
N*    Send all tasks descriptors to the host.
N*/
Nvoid SEGGER_SYSVIEW_SendTaskList(void) {
N  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
N    _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
N  }
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_SendSysDesc()
N*
N*  Function description
N*    Send the system description string to the host.
N*    The system description is used by SystemViewer to identify the
N*    current application and handle events accordingly.
N*
N*  Parameters
N*    sSysDesc - Pointer to the 0-terminated system description string.
N*
N*  Additional information
N*    One system description string may not exceed SEGGER_SYSVIEW_MAX_STRING_LEN characters.
N*
N*    The Following items can be described in a system description string.
N*    Each item is identified by its identifier, followed by '=' and the value.
N*    Items are separated by ','.
N*/
Nvoid SEGGER_SYSVIEW_SendSysDesc(const char *sSysDesc) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = _EncodeStr(pPayloadStart, sSysDesc, SEGGER_SYSVIEW_MAX_STRING_LEN);
X  pPayload = _EncodeStr(pPayloadStart, sSysDesc, 128);
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_SYSDESC);
X  _SendPacket(pPayloadStart, pPayload, 14);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordSystime()
N*
N*  Function description
N*    Formats and sends a SystemView Systime containing a single U64 or U32
N*    parameter payload.
N*/
Nvoid SEGGER_SYSVIEW_RecordSystime(void) {
N  U64 Systime;
X  unsigned long long Systime;
N
N  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
N    Systime = _SYSVIEW_Globals.pOSAPI->pfGetTime();
N    SEGGER_SYSVIEW_RecordU32x2(SYSVIEW_EVTID_SYSTIME_US,
X    SEGGER_SYSVIEW_RecordU32x2(13,
N                               (U32)(Systime),
X                               (unsigned long)(Systime),
N                               (U32)(Systime >> 32));
X                               (unsigned long)(Systime >> 32));
N  } else {
N    SEGGER_SYSVIEW_RecordU32(SYSVIEW_EVTID_SYSTIME_CYCLES, SEGGER_SYSVIEW_GET_TIMESTAMP());
X    SEGGER_SYSVIEW_RecordU32(12, (*(unsigned long *)(0xE0001004)));
N  }
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordEnterISR()
N*
N*  Function description
N*    Format and send an ISR entry event.
N*
N*  Additional information
N*    Example packets sent
N*      02 0F 50              // ISR(15) Enter. Timestamp is 80 (0x50)
N*/
Nvoid SEGGER_SYSVIEW_RecordEnterISR(void) {
N  unsigned v;
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  v = SEGGER_SYSVIEW_GET_INTERRUPT_ID();
X  v = ((*(unsigned long *)(0xE000ED04)) & 0x1FF);
N  ENCODE_U32(pPayload, v);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = v; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_ISR_ENTER);
X  _SendPacket(pPayloadStart, pPayload, 2);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordExitISR()
N*
N*  Function description
N*    Format and send an ISR exit event.
N*
N*  Additional information
N*    Format as follows:
N*      03 <TimeStamp>        // Max. packet len is 6
N*
N*    Example packets sent
N*      03 20                // ISR Exit. Timestamp is 32 (0x20)
N*/
Nvoid SEGGER_SYSVIEW_RecordExitISR(void) {
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_EXIT);
X  _SendPacket(pPayloadStart, pPayloadStart, 3);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordExitISRToScheduler()
N*
N*  Function description
N*    Format and send an ISR exit into scheduler event.
N*
N*  Additional information
N*    Format as follows:
N*      18 <TimeStamp>        // Max. packet len is 6
N*
N*    Example packets sent
N*      18 20                // ISR Exit to Scheduler. Timestamp is 32 (0x20)
N*/
Nvoid SEGGER_SYSVIEW_RecordExitISRToScheduler(void) {
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_TO_SCHEDULER);
X  _SendPacket(pPayloadStart, pPayloadStart, 18);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordEnterTimer()
N*
N*  Function description
N*    Format and send a Timer entry event.
N*  
N*  Parameters
N*    TimerId - Id of the timer which starts.
N*/
Nvoid SEGGER_SYSVIEW_RecordEnterTimer(U32 TimerId) {
Xvoid SEGGER_SYSVIEW_RecordEnterTimer(unsigned long TimerId) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, SHRINK_ID(TimerId));
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = (((TimerId) - _SYSVIEW_Globals . RAMBaseAddress) >> 2); while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TIMER_ENTER);
X  _SendPacket(pPayloadStart, pPayload, 19);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordExitTimer()
N*
N*  Function description
N*    Format and send a Timer exit event.
N*/
Nvoid SEGGER_SYSVIEW_RecordExitTimer(void) {
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TIMER_EXIT);
X  _SendPacket(pPayloadStart, pPayloadStart, 20);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordEndCall()
N*
N*  Function description
N*    Format and send an End API Call event without return value.
N*  
N*  Parameters
N*    EventID - Id of API function which ends.
N*/
Nvoid SEGGER_SYSVIEW_RecordEndCall(unsigned EventID) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, EventID);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = EventID; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_END_CALL);
X  _SendPacket(pPayloadStart, pPayload, 28);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordEndCallU32()
N*
N*  Function description
N*    Format and send an End API Call event with return value.
N*  
N*  Parameters
N*    EventID      - Id of API function which ends.
N*    Para0        - Return value which will be returned by the API function.
N*/
Nvoid SEGGER_SYSVIEW_RecordEndCallU32(unsigned EventID, U32 Para0) {
Xvoid SEGGER_SYSVIEW_RecordEndCallU32(unsigned EventID, unsigned long Para0) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, EventID);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = EventID; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Para0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Para0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_END_CALL);
X  _SendPacket(pPayloadStart, pPayload, 28);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_OnIdle()
N*
N*  Function description
N*    Record an Idle event.
N*/
Nvoid SEGGER_SYSVIEW_OnIdle(void) {
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_IDLE);
X  _SendPacket(pPayloadStart, pPayloadStart, 17);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_OnTaskCreate()
N*
N*  Function description
N*    Record a Task Create event.  The Task Create event corresponds
N*    to creating a task in the OS.
N*
N*  Parameters
N*    TaskId        - Task ID of created task.
N*/
Nvoid SEGGER_SYSVIEW_OnTaskCreate(unsigned TaskId) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  TaskId = SHRINK_ID(TaskId);
X  TaskId = (((TaskId) - _SYSVIEW_Globals . RAMBaseAddress) >> 2);
N  ENCODE_U32(pPayload, TaskId);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = TaskId; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_CREATE);
X  _SendPacket(pPayloadStart, pPayload, 8);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_OnTaskTerminate()
N*
N*  Function description
N*    Record a Task termination event.  
N*    The Task termination event corresponds to terminating a task in 
N*    the OS. If the TaskId is the currently active task, 
N*    SEGGER_SYSVIEW_OnTaskStopExec may be used, either.
N*
N*  Parameters
N*    TaskId        - Task ID of terminated task.
N*/
Nvoid SEGGER_SYSVIEW_OnTaskTerminate(unsigned TaskId) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  TaskId = SHRINK_ID(TaskId);
X  TaskId = (((TaskId) - _SYSVIEW_Globals . RAMBaseAddress) >> 2);
N  ENCODE_U32(pPayload, TaskId);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = TaskId; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_TERMINATE);
X  _SendPacket(pPayloadStart, pPayload, 29);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_OnTaskStartExec()
N*
N*  Function description
N*    Record a Task Start Execution event.  The Task Start event
N*    corresponds to when a task has started to execute rather than
N*    when it is ready to execute.
N*
N*  Parameters
N*    TaskId - Task ID of task that started to execute.
N*/
Nvoid SEGGER_SYSVIEW_OnTaskStartExec(unsigned TaskId) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  TaskId = SHRINK_ID(TaskId);
X  TaskId = (((TaskId) - _SYSVIEW_Globals . RAMBaseAddress) >> 2);
N  ENCODE_U32(pPayload, TaskId);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = TaskId; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_EXEC);
X  _SendPacket(pPayloadStart, pPayload, 4);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_OnTaskStopExec()
N*
N*  Function description
N*    Record a Task Stop Execution event.  The Task Stop event
N*    corresponds to when a task stops executing and terminates.
N*/
Nvoid SEGGER_SYSVIEW_OnTaskStopExec(void) {
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TASK_STOP_EXEC);
X  _SendPacket(pPayloadStart, pPayloadStart, 5);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_OnTaskStartReady()
N*
N*  Function description
N*    Record a Task Start Ready event.
N*
N*  Parameters
N*    TaskId - Task ID of task that started to execute.
N*/
Nvoid SEGGER_SYSVIEW_OnTaskStartReady(unsigned TaskId) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  TaskId = SHRINK_ID(TaskId);
X  TaskId = (((TaskId) - _SYSVIEW_Globals . RAMBaseAddress) >> 2);
N  ENCODE_U32(pPayload, TaskId);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = TaskId; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_READY);
X  _SendPacket(pPayloadStart, pPayload, 6);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_OnTaskStopReady()
N*
N*  Function description
N*    Record a Task Stop Ready event.
N*
N*  Parameters
N*    TaskId - Task ID of task that completed execution.
N*    Cause  - Reason for task to stop (i.e. Idle/Sleep)
N*/
Nvoid SEGGER_SYSVIEW_OnTaskStopReady(unsigned TaskId, unsigned Cause) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  TaskId = SHRINK_ID(TaskId);
X  TaskId = (((TaskId) - _SYSVIEW_Globals . RAMBaseAddress) >> 2);
N  ENCODE_U32(pPayload, TaskId);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = TaskId; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, Cause);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Cause; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_STOP_READY);
X  _SendPacket(pPayloadStart, pPayload, 7);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_OnUserStart()
N*
N*  Function description
N*    Send a user event start, such as start of a subroutine for profiling.
N*
N*  Parameters
N*    UserId  - User defined ID for the event.
N*/
Nvoid SEGGER_SYSVIEW_OnUserStart(unsigned UserId) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, UserId);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = UserId; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_USER_START);
X  _SendPacket(pPayloadStart, pPayload, 15);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_OnUserStop()
N*
N*  Function description
N*    Send a user event stop, such as return of a subroutine for profiling.
N*
N*  Parameters
N*    UserId  - User defined ID for the event.
N*/
Nvoid SEGGER_SYSVIEW_OnUserStop(unsigned UserId) {
N  U8 * pPayload;
X  unsigned char * pPayload;
N  U8 * pPayloadStart;
X  unsigned char * pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, UserId);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = UserId; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_USER_STOP);
X  _SendPacket(pPayloadStart, pPayload, 16);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_NameResource()
N*
N*  Function description
N*    Send the name of a resource to be displayed in SystemViewer.
N*
N*  Parameters
N*    ResourceId - Id of the resource to be named. i.e. its address.
N*    sName      - Pointer to the resource name. (Max. SEGGER_SYSVIEW_MAX_STRING_LEN Bytes)
N*/
Nvoid SEGGER_SYSVIEW_NameResource(U32 ResourceId, const char* sName) {
Xvoid SEGGER_SYSVIEW_NameResource(unsigned long ResourceId, const char* sName) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, SHRINK_ID(ResourceId));
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = (((ResourceId) - _SYSVIEW_Globals . RAMBaseAddress) >> 2); while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  pPayload = _EncodeStr(pPayload, sName, SEGGER_SYSVIEW_MAX_STRING_LEN);
X  pPayload = _EncodeStr(pPayload, sName, 128);
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NAME_RESOURCE);
X  _SendPacket(pPayloadStart, pPayload, 25);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_SendPacket()
N*
N*  Function description
N*    Send an event packet.
N*
N*  Parameters
N*    pPacket      - Pointer to the start of the packet.
N*    pPayloadEnd  - Pointer to the end of the payload.
N*                   Make sure there are at least 5 bytes free after the payload.
N*    EventId      - Id of the event packet.
N*
N*  Return value
N*    !=0:  Success, Message sent.
N*    ==0:  Buffer full, Message *NOT* sent.
N*/
Nint SEGGER_SYSVIEW_SendPacket(U8* pPacket, U8* pPayloadEnd, unsigned EventId) {
Xint SEGGER_SYSVIEW_SendPacket(unsigned char* pPacket, unsigned char* pPayloadEnd, unsigned EventId) {
N#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
X#if (1 == 1)
N  SEGGER_SYSVIEW_LOCK();
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();;
N#endif
N  _SendPacket(pPacket + 4, pPayloadEnd, EventId);
N#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
X#if (1 == 1)
N  SEGGER_SYSVIEW_UNLOCK();
X  BASEPRI = LockState; __schedule_barrier(); };
N#endif
N  return 0;
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_EncodeU32()
N*
N*  Function description
N*    Encode a U32 in variable-length format.
N*
N*  Parameters
N*    pPayload - Pointer to where U32 will be encoded.
N*    Value    - The 32-bit value to be encoded.
N*
N*  Return value
N*    Pointer to the byte following the value, i.e. the first free
N*    byte in the payload and the next position to store payload
N*    content.
N*/
NU8* SEGGER_SYSVIEW_EncodeU32(U8* pPayload, unsigned Value) {
Xunsigned char* SEGGER_SYSVIEW_EncodeU32(unsigned char* pPayload, unsigned Value) {
N  ENCODE_U32(pPayload, Value);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Value; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  return pPayload;
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_EncodeString()
N*
N*  Function description
N*    Encode a string in variable-length format.
N*
N*  Parameters
N*    pPayload - Pointer to where string will be encoded.
N*    s        - String to encode.
N*    MaxLen   - Maximum number of characters to encode from string.
N*
N*  Return value
N*    Pointer to the byte following the value, i.e. the first free
N*    byte in the payload and the next position to store payload
N*    content.
N*
N*  Additional information
N*    The string is encoded as a count byte followed by the contents
N*    of the string.
N*    No more than 1 + MaxLen bytes will be encoded to the payload.
N*/
NU8* SEGGER_SYSVIEW_EncodeString(U8* pPayload, const char* s, unsigned MaxLen) {
Xunsigned char* SEGGER_SYSVIEW_EncodeString(unsigned char* pPayload, const char* s, unsigned MaxLen) {
N  return _EncodeStr(pPayload, s, MaxLen);
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_EncodeData()
N*
N*  Function description
N*    Encode a byte buffer in variable-length format.
N*
N*  Parameters
N*    pPayload - Pointer to where string will be encoded.
N*    pSrc     - Pointer to data buffer to be encoded.
N*    NumBytes - Number of bytes in the buffer to be encoded.
N*
N*  Return value
N*    Pointer to the byte following the value, i.e. the first free
N*    byte in the payload and the next position to store payload
N*    content.
N*
N*  Additional information
N*    The data is encoded as a count byte followed by the contents
N*    of the data buffer.
N*    Make sure NumBytes + 1 bytes are free for the payload.
N*/
NU8* SEGGER_SYSVIEW_EncodeData(U8 *pPayload, const char* pSrc, unsigned NumBytes) {
Xunsigned char* SEGGER_SYSVIEW_EncodeData(unsigned char *pPayload, const char* pSrc, unsigned NumBytes) {
N  return _EncodeData(pPayload, pSrc, NumBytes);
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_EncodeId()
N*
N*  Function description
N*    Encode a 32-bit Id in shrunken variable-length format.
N*
N*  Parameters
N*    pPayload - Pointer to where the Id will be encoded.
N*    Id       - The 32-bit value to be encoded.
N*
N*  Return value
N*    Pointer to the byte following the value, i.e. the first free
N*    byte in the payload and the next position to store payload
N*    content.
N*
N*  Additional information
N*    The parameters to shrink an Id can be configured in
N*    SEGGER_SYSVIEW_Conf.h and via SEGGER_SYSVIEW_SetRAMBase().
N*     SEGGER_SYSVIEW_ID_BASE: Lowest Id reported by the application.
N*       (i.e. 0x20000000 when all Ids are an address in this RAM)
N*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
N*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
N*/
NU8* SEGGER_SYSVIEW_EncodeId(U8* pPayload, unsigned Id) {
Xunsigned char* SEGGER_SYSVIEW_EncodeId(unsigned char* pPayload, unsigned Id) {
N  Id = SHRINK_ID(Id);
X  Id = (((Id) - _SYSVIEW_Globals . RAMBaseAddress) >> 2);
N  ENCODE_U32(pPayload, Id);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = Id; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  return pPayload;
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_ShrinkId()
N*
N*  Function description
N*    Get the shrunken value of an Id for further processing like in
N*    SEGGER_SYSVIEW_NameResource().
N*
N*  Parameters
N*    Id       - The 32-bit value to be shrunken.
N*
N*  Return value
N*    Shrunken Id.
N*
N*  Additional information
N*    The parameters to shrink an Id can be configured in
N*    SEGGER_SYSVIEW_Conf.h and via SEGGER_SYSVIEW_SetRAMBase().
N*     SEGGER_SYSVIEW_ID_BASE: Lowest Id reported by the application.
N*       (i.e. 0x20000000 when all Ids are an address in this RAM)
N*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
N*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
N*/
NU32 SEGGER_SYSVIEW_ShrinkId(U32 Id) {
Xunsigned long SEGGER_SYSVIEW_ShrinkId(unsigned long Id) {
N  return SHRINK_ID(Id);
X  return (((Id) - _SYSVIEW_Globals . RAMBaseAddress) >> 2);
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RegisterModule()
N*
N*  Function description
N*    Register a middleware module for recording its events.
N*
N*  Parameters
N*    pModule  - The middleware module information.
N*
N*  Additional information
N*    SEGGER_SYSVIEW_MODULE elements:
N*      sDescription      - Pointer to a string containing the module name and optionally the module event description.
N*      NumEvents         - Number of events the module wants to register.
N*      EventOffset       - Offset to be added to the event Ids. Out parameter, set by this function. Do not modify after calling this function.
N*      pfSendModuleDesc  - Callback function pointer to send more detailed module description to SystemViewer.
N*      pNext             - Pointer to next registered module. Out parameter, set by this function. Do not modify after calling this function.
N*/
Nvoid SEGGER_SYSVIEW_RegisterModule(SEGGER_SYSVIEW_MODULE* pModule) {
N  SEGGER_SYSVIEW_LOCK();
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();;
N  if (_pFirstModule == 0) {
N    //
N    // No module registered, yet.
N    // Start list with new module.
N    // EventOffset is the base offset for modules
N    //
N    pModule->EventOffset = MODULE_EVENT_OFFSET;
X    pModule->EventOffset = (512);
N    pModule->pNext = 0;
N    _pFirstModule = pModule;
N    _NumModules = 1;
N  } else {
N    //
N    // Registreded module(s) present.
N    // Prepend new module in list.
N    // EventOffset set from number of events and offset of previous module.
N    //
N    pModule->EventOffset = _pFirstModule->EventOffset + _pFirstModule->NumEvents;
N    pModule->pNext = _pFirstModule;
N    _pFirstModule = pModule;
N    _NumModules++;
N  }
N  SEGGER_SYSVIEW_SendModule(0);
N  if (pModule->pfSendModuleDesc) {
N    pModule->pfSendModuleDesc();
N  }
N  SEGGER_SYSVIEW_UNLOCK();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_RecordModuleDescription()
N*
N*  Function description
N*    Sends detailed information of a registered module to the host.
N*
N*  Parameters
N*    pModule      - Pointer to the described module.
N*    sDescription - Pointer to a description string.
N*/
Nvoid SEGGER_SYSVIEW_RecordModuleDescription(const SEGGER_SYSVIEW_MODULE* pModule, const char* sDescription) {
N  U8  ModuleId;
X  unsigned char  ModuleId;
N  SEGGER_SYSVIEW_MODULE* p;
N
N  p = _pFirstModule;
N  ModuleId = 0;
N  do {
N    if (p == pModule) {
N      break;
N    }
N    ModuleId++;
N    p = p->pNext;
N  } while (p);
N  {
N    U8* pPayload;
X    unsigned char* pPayload;
N    U8* pPayloadStart;
X    unsigned char* pPayloadStart;
N    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
X    { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N    //
N    pPayload = pPayloadStart;
N    //
N    // Send module description
N    // Send event offset and number of events
N    //
N    ENCODE_U32(pPayload, ModuleId);
X    { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = ModuleId; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N    ENCODE_U32(pPayload, (pModule->EventOffset));
X    { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = (pModule ->EventOffset); while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N    pPayload = _EncodeStr(pPayload, sDescription, SEGGER_SYSVIEW_MAX_STRING_LEN);
X    pPayload = _EncodeStr(pPayload, sDescription, 128);
N    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
X    _SendPacket(pPayloadStart, pPayload, 22);
N    RECORD_END();
X    BASEPRI = LockState; __schedule_barrier(); };
N  }
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_SendModule()
N*
N*  Function description
N*    Sends the information of a registered module to the host.
N*
N*  Parameters
N*    ModuleId   - Id of the requested module.
N*/
Nvoid SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
Xvoid SEGGER_SYSVIEW_SendModule(unsigned char ModuleId) {
N  SEGGER_SYSVIEW_MODULE* pModule;
N  U32 n;
X  unsigned long n;
N
N  if (_pFirstModule != 0) {
N    pModule = _pFirstModule;
N    for (n = 0; n < ModuleId; n++) {
N      pModule = pModule->pNext;
N      if (pModule == 0) {
N        break;
N      }
N    }
N    if (pModule != 0) {
N      U8* pPayload;
X      unsigned char* pPayload;
N      U8* pPayloadStart;
X      unsigned char* pPayloadStart;
N      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
X      { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N      //
N      pPayload = pPayloadStart;
N      //
N      // Send module description
N      // Send event offset and number of events
N      //
N      ENCODE_U32(pPayload, ModuleId);
X      { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = ModuleId; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N      ENCODE_U32(pPayload, (pModule->EventOffset));
X      { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = (pModule ->EventOffset); while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N      pPayload = _EncodeStr(pPayload, pModule->sModule, SEGGER_SYSVIEW_MAX_STRING_LEN);
X      pPayload = _EncodeStr(pPayload, pModule->sModule, 128);
N      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
X      _SendPacket(pPayloadStart, pPayload, 22);
N      RECORD_END();
X      BASEPRI = LockState; __schedule_barrier(); };
N    }
N  }
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_SendModuleDescription()
N*
N*  Function description
N*    Triggers a send of the registered module descriptions.
N*
N*/
Nvoid SEGGER_SYSVIEW_SendModuleDescription(void) {
N  SEGGER_SYSVIEW_MODULE* pModule;
N
N  if (_pFirstModule != 0) {
N    pModule = _pFirstModule;
N    do {
N      if (pModule->pfSendModuleDesc) {
N        pModule->pfSendModuleDesc();
N      }
N      pModule = pModule->pNext;
N    } while (pModule);
N  }
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_SendNumModules()
N*
N*  Function description
N*    Send the number of registered modules to the host.
N*/
Nvoid SEGGER_SYSVIEW_SendNumModules(void) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  pPayload = pPayloadStart;
N  ENCODE_U32(pPayload, _NumModules);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = _NumModules; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
X  _SendPacket(pPayloadStart, pPayload, 27);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N#ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF // Define in project to avoid warnings about variable parameter list
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_PrintfHostEx()
N*
N*  Function description
N*    Print a string which is formatted on the host by SystemViewer
N*    with Additional information.
N*
N*  Parameters
N*    s        - String to be formatted.
N*    Options  - Options for the string. i.e. Log level.
N*
N*  Additional information
N*    All format arguments are treated as 32-bit scalar values.
N*/
Nvoid SEGGER_SYSVIEW_PrintfHostEx(const char* s, U32 Options, ...) {
Xvoid SEGGER_SYSVIEW_PrintfHostEx(const char* s, unsigned long Options, ...) {
N  va_list ParamList;
N
N  va_start(ParamList, Options);
X  __va_start(ParamList, Options);
N  _VPrintHost(s, Options, &ParamList);
N  va_end(ParamList);
X  __va_end(ParamList);
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_PrintfHost()
N*
N*  Function description
N*    Print a string which is formatted on the host by SystemViewer.
N*
N*  Parameters
N*    s        - String to be formatted.
N*
N*  Additional information
N*    All format arguments are treated as 32-bit scalar values.
N*/
Nvoid SEGGER_SYSVIEW_PrintfHost(const char* s, ...) {
N  va_list ParamList;
N
N  va_start(ParamList, s);
X  __va_start(ParamList, s);
N  _VPrintHost(s, SEGGER_SYSVIEW_LOG, &ParamList);
X  _VPrintHost(s, (0u), &ParamList);
N  va_end(ParamList);
X  __va_end(ParamList);
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_WarnfHost()
N*
N*  Function description
N*    Print a warnin string which is formatted on the host by 
N*    SystemViewer.
N*
N*  Parameters
N*    s        - String to be formatted.
N*
N*  Additional information
N*    All format arguments are treated as 32-bit scalar values.
N*/
Nvoid SEGGER_SYSVIEW_WarnfHost(const char* s, ...) {
N  va_list ParamList;
N
N  va_start(ParamList, s);
X  __va_start(ParamList, s);
N  _VPrintHost(s, SEGGER_SYSVIEW_WARNING, &ParamList);
X  _VPrintHost(s, (1u), &ParamList);
N  va_end(ParamList);
X  __va_end(ParamList);
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_ErrorfHost()
N*
N*  Function description
N*    Print an error string which is formatted on the host by 
N*    SystemViewer.
N*
N*  Parameters
N*    s        - String to be formatted.
N*
N*  Additional information
N*    All format arguments are treated as 32-bit scalar values.
N*/
Nvoid SEGGER_SYSVIEW_ErrorfHost(const char* s, ...) {
N  va_list ParamList;
N
N  va_start(ParamList, s);
X  __va_start(ParamList, s);
N  _VPrintHost(s, SEGGER_SYSVIEW_ERROR, &ParamList);
X  _VPrintHost(s, (2u), &ParamList);
N  va_end(ParamList);
X  __va_end(ParamList);
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_PrintfTargetEx()
N*
N*  Function description
N*    Print a string which is formatted on the target before sent to 
N*    the host with Additional information.
N*
N*  Parameters
N*    s        - String to be formatted.
N*    Options  - Options for the string. i.e. Log level.
N*/
Nvoid SEGGER_SYSVIEW_PrintfTargetEx(const char* s, U32 Options, ...) {
Xvoid SEGGER_SYSVIEW_PrintfTargetEx(const char* s, unsigned long Options, ...) {
N  va_list ParamList;
N
N  va_start(ParamList, Options);
X  __va_start(ParamList, Options);
N  _VPrintTarget(s, Options, &ParamList);
N  va_end(ParamList);
X  __va_end(ParamList);
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_PrintfTarget()
N*
N*  Function description
N*    Print a string which is formatted on the target before sent to 
N*    the host.
N*
N*  Parameters
N*    s        - String to be formatted.
N*/
Nvoid SEGGER_SYSVIEW_PrintfTarget(const char* s, ...) {
N  va_list ParamList;
N
N  va_start(ParamList, s);
X  __va_start(ParamList, s);
N  _VPrintTarget(s, SEGGER_SYSVIEW_LOG, &ParamList);
X  _VPrintTarget(s, (0u), &ParamList);
N  va_end(ParamList);
X  __va_end(ParamList);
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_WarnfTarget()
N*
N*  Function description
N*    Print a warning string which is formatted on the target before
N*    sent to the host.
N*
N*  Parameters
N*    s        - String to be formatted.
N*/
Nvoid SEGGER_SYSVIEW_WarnfTarget(const char* s, ...) {
N  va_list ParamList;
N
N  va_start(ParamList, s);
X  __va_start(ParamList, s);
N  _VPrintTarget(s, SEGGER_SYSVIEW_WARNING, &ParamList);
X  _VPrintTarget(s, (1u), &ParamList);
N  va_end(ParamList);
X  __va_end(ParamList);
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_ErrorfTarget()
N*
N*  Function description
N*    Print an error string which is formatted on the target before
N*    sent to the host.
N*
N*  Parameters
N*    s        - String to be formatted.
N*/
Nvoid SEGGER_SYSVIEW_ErrorfTarget(const char* s, ...) {
N  va_list ParamList;
N
N  va_start(ParamList, s);
X  __va_start(ParamList, s);
N  _VPrintTarget(s, SEGGER_SYSVIEW_ERROR, &ParamList);
X  _VPrintTarget(s, (2u), &ParamList);
N  va_end(ParamList);
X  __va_end(ParamList);
N}
N#endif // SEGGER_SYSVIEW_EXCLUDE_PRINTF
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_Print()
N*
N*  Function description
N*    Print a string to the host.
N*
N*  Parameters
N*    s        - String to sent.
N*/
Nvoid SEGGER_SYSVIEW_Print(const char* s) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
X  pPayload = _EncodeStr(pPayloadStart, s, 128);
N  ENCODE_U32(pPayload, SEGGER_SYSVIEW_LOG);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = (0u); while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, 0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = 0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
X  _SendPacket(pPayloadStart, pPayload, 26);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_Warn()
N*
N*  Function description
N*    Print a warning string to the host.
N*
N*  Parameters
N*    s        - String to sent.
N*/
Nvoid SEGGER_SYSVIEW_Warn(const char* s) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
X  pPayload = _EncodeStr(pPayloadStart, s, 128);
N  ENCODE_U32(pPayload, SEGGER_SYSVIEW_WARNING);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = (1u); while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, 0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = 0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
X  _SendPacket(pPayloadStart, pPayload, 26);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_Error()
N*
N*  Function description
N*    Print an error string to the host.
N*
N*  Parameters
N*    s        - String to sent.
N*/
Nvoid SEGGER_SYSVIEW_Error(const char* s) {
N  U8* pPayload;
X  unsigned char* pPayload;
N  U8* pPayloadStart;
X  unsigned char* pPayloadStart;
N  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
X  { unsigned int LockState; register unsigned char BASEPRI __asm( "basepri"); LockState = BASEPRI; BASEPRI = (0x20); __schedule_barrier();; pPayloadStart = _PreparePacket(_aPacket);;
N  //
N  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
X  pPayload = _EncodeStr(pPayloadStart, s, 128);
N  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ERROR);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = (2u); while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  ENCODE_U32(pPayload, 0);
X  { unsigned char* pSysviewPointer; unsigned long SysViewData; pSysviewPointer = pPayload; SysViewData = 0; while(SysViewData > 0x7F) { *pSysviewPointer++ = (unsigned char)(SysViewData | 0x80); SysViewData >>= 7; }; *pSysviewPointer++ = (unsigned char)SysViewData; pPayload = pSysviewPointer; };;
N  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
X  _SendPacket(pPayloadStart, pPayload, 26);
N  RECORD_END();
X  BASEPRI = LockState; __schedule_barrier(); };
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_EnableEvents()
N*
N*  Function description
N*    Enable standard SystemView events to be generated.
N*
N*  Parameters
N*    EnableMask   - Events to be enabled.
N*/
Nvoid SEGGER_SYSVIEW_EnableEvents(U32 EnableMask) {
Xvoid SEGGER_SYSVIEW_EnableEvents(unsigned long EnableMask) {
N  _SYSVIEW_Globals.DisabledEvents &= ~EnableMask;
N}
N
N/*********************************************************************
N*
N*       SEGGER_SYSVIEW_DisableEvents()
N*
N*  Function description
N*    Disable standard SystemView events to not be generated.
N*
N*  Parameters
N*    DisableMask  - Events to be disabled.
N*/
Nvoid SEGGER_SYSVIEW_DisableEvents(U32 DisableMask) {
Xvoid SEGGER_SYSVIEW_DisableEvents(unsigned long DisableMask) {
N  _SYSVIEW_Globals.DisabledEvents |= DisableMask;
N}
N
N
N/*************************** End of file ****************************/
