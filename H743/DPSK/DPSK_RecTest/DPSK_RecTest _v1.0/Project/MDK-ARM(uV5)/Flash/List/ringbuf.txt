; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\ringbuf.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\ringbuf.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\MiddleWareDrv -I..\..\User\RTT -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 --omf_browse=.\flash\obj\ringbuf.crf ..\..\User\ringbuf.c]
                          THUMB

                          AREA ||i.RingBufAdvanceRead||, CODE, READONLY, ALIGN=1

                  RingBufAdvanceRead PROC
;;;489    void
;;;490    RingBufAdvanceRead(tRingBufObject *ptRingBuf,
000000  b570              PUSH     {r4-r6,lr}
;;;491                          unsigned long ulNumBytes)
;;;492    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;493        unsigned long ulCount;
;;;494    
;;;495        //
;;;496        // Check the arguments.
;;;497        //
;;;498    //     ASSERT(ptRingBuf != NULL);
;;;499    
;;;500        //
;;;501        // Make sure that we are not being asked to remove more data than is
;;;502        // there to be removed.
;;;503        //
;;;504        ulCount = RingBufUsed(ptRingBuf);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RingBufUsed
00000c  4606              MOV      r6,r0
;;;505        ulCount =  (ulCount < ulNumBytes) ? ulCount : ulNumBytes;
00000e  42ae              CMP      r6,r5
000010  d201              BCS      |L1.22|
000012  4630              MOV      r0,r6
000014  e000              B        |L1.24|
                  |L1.22|
000016  4628              MOV      r0,r5
                  |L1.24|
000018  4606              MOV      r6,r0
;;;506    
;;;507        //
;;;508        // Advance the buffer read index by the required number of bytes.
;;;509        //
;;;510        UpdateIndexAtomic(&ptRingBuf->ulReadIndex, ulCount,
00001a  4631              MOV      r1,r6
00001c  f1040008          ADD      r0,r4,#8
000020  6822              LDR      r2,[r4,#0]
000022  f7fffffe          BL       UpdateIndexAtomic
;;;511                          ptRingBuf->ulSize);
;;;512    }
000026  bd70              POP      {r4-r6,pc}
;;;513    
                          ENDP


                          AREA ||i.RingBufAdvanceWrite||, CODE, READONLY, ALIGN=1

                  RingBufAdvanceWrite PROC
;;;531    void
;;;532    RingBufAdvanceWrite(tRingBufObject *ptRingBuf,
000000  b570              PUSH     {r4-r6,lr}
;;;533                           unsigned long ulNumBytes)
;;;534    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;535        unsigned long ulCount;
;;;536        tBoolean bIntsOff;
;;;537    
;;;538        //
;;;539        // Check the arguments.
;;;540        //
;;;541    //     ASSERT(ptRingBuf != NULL);
;;;542    
;;;543        //
;;;544        // Make sure we were not asked to add a silly number of bytes.
;;;545        //
;;;546    //     ASSERT(ulNumBytes <= ptRingBuf->ulSize);
;;;547    
;;;548        //
;;;549        // Determine how much free space we currently think the buffer has.
;;;550        //
;;;551        ulCount = RingBufFree(ptRingBuf);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RingBufFree
00000c  4606              MOV      r6,r0
;;;552    
;;;553        //
;;;554        // Advance the buffer write index by the required number of bytes and
;;;555        // check that we have not run past the read index. Note that we must do
;;;556        // this within a critical section (interrupts disabled) to prevent
;;;557        // race conditions that could corrupt one or other of the indices.
;;;558        //
;;;559    //     bIntsOff = IntMasterDisable();
;;;560    
;;;561        //
;;;562        // Update the write pointer.
;;;563        //
;;;564        ptRingBuf->ulWriteIndex += ulNumBytes;
00000e  6860              LDR      r0,[r4,#4]
000010  4428              ADD      r0,r0,r5
000012  6060              STR      r0,[r4,#4]
;;;565    
;;;566        //
;;;567        // Check and correct for wrap.
;;;568        //
;;;569        if(ptRingBuf->ulWriteIndex >= ptRingBuf->ulSize)
000014  6860              LDR      r0,[r4,#4]
000016  6821              LDR      r1,[r4,#0]
000018  4288              CMP      r0,r1
00001a  d303              BCC      |L2.36|
;;;570        {
;;;571            ptRingBuf->ulWriteIndex -= ptRingBuf->ulSize;
00001c  6860              LDR      r0,[r4,#4]
00001e  6821              LDR      r1,[r4,#0]
000020  1a40              SUBS     r0,r0,r1
000022  6060              STR      r0,[r4,#4]
                  |L2.36|
;;;572        }
;;;573    
;;;574        //
;;;575        // Did the client add more bytes than the buffer had free space for?
;;;576        //
;;;577        if(ulCount < ulNumBytes)
000024  42ae              CMP      r6,r5
000026  d20a              BCS      |L2.62|
;;;578        {
;;;579            //
;;;580            // Yes - we need to advance the read pointer to ahead of the write
;;;581            // pointer to discard some of the oldest data.
;;;582            //
;;;583            ptRingBuf->ulReadIndex = ptRingBuf->ulWriteIndex + 1;
000028  6860              LDR      r0,[r4,#4]
00002a  1c40              ADDS     r0,r0,#1
00002c  60a0              STR      r0,[r4,#8]
;;;584    
;;;585            //
;;;586            // Correct for buffer wrap if necessary.
;;;587            //
;;;588            if(ptRingBuf->ulReadIndex >= ptRingBuf->ulSize)
00002e  68a0              LDR      r0,[r4,#8]
000030  6821              LDR      r1,[r4,#0]
000032  4288              CMP      r0,r1
000034  d303              BCC      |L2.62|
;;;589            {
;;;590                ptRingBuf->ulReadIndex -= ptRingBuf->ulSize;
000036  68a0              LDR      r0,[r4,#8]
000038  6821              LDR      r1,[r4,#0]
00003a  1a40              SUBS     r0,r0,r1
00003c  60a0              STR      r0,[r4,#8]
                  |L2.62|
;;;591            }
;;;592        }
;;;593    
;;;594        //
;;;595        // Restore interrupts if we turned them off earlier.
;;;596        //
;;;597        if(!bIntsOff)
;;;598        {
;;;599    //         IntMasterEnable();
;;;600        }
;;;601    }
00003e  bd70              POP      {r4-r6,pc}
;;;602    
                          ENDP


                          AREA ||i.RingBufContigFree||, CODE, READONLY, ALIGN=1

                  RingBufContigFree PROC
;;;294    unsigned long
;;;295    RingBufContigFree(tRingBufObject *ptRingBuf)
000000  b510              PUSH     {r4,lr}
;;;296    {
000002  4601              MOV      r1,r0
;;;297        unsigned long ulWrite;
;;;298        unsigned long ulRead;
;;;299    
;;;300        //
;;;301        // Check the arguments.
;;;302        //
;;;303    //    ASSERT(ptRingBuf != NULL);
;;;304    
;;;305        //
;;;306        // Copy the Read/Write indices for calculation.
;;;307        //
;;;308        ulWrite = ptRingBuf->ulWriteIndex;
000004  684a              LDR      r2,[r1,#4]
;;;309        ulRead = ptRingBuf->ulReadIndex;
000006  688b              LDR      r3,[r1,#8]
;;;310    
;;;311        //
;;;312        // Return the number of contiguous bytes available.
;;;313        //
;;;314        if(ulRead > ulWrite)
000008  4293              CMP      r3,r2
00000a  d902              BLS      |L3.18|
;;;315        {
;;;316            //
;;;317            // The read pointer is above the write pointer so the amount of free
;;;318            // space is the difference between the two indices minus 1 to account
;;;319            // for the buffer full condition (write index one behind read index).
;;;320            //
;;;321            return((ulRead - ulWrite) - 1);
00000c  1a98              SUBS     r0,r3,r2
00000e  1e40              SUBS     r0,r0,#1
                  |L3.16|
;;;322        }
;;;323        else
;;;324        {
;;;325            //
;;;326            // If the write pointer is above the read pointer, the amount of free
;;;327            // space is the size of the buffer minus the write index. We need to
;;;328            // add a special-case adjustment if the read index is 0 since we need
;;;329            // to leave 1 byte empty to ensure we can tell the difference between
;;;330            // the buffer being full and empty.
;;;331            //
;;;332            return(ptRingBuf->ulSize - ulWrite - ((ulRead == 0) ? 1 : 0));
;;;333        }
;;;334    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  6808              LDR      r0,[r1,#0]            ;332
000014  1a80              SUBS     r0,r0,r2              ;332
000016  b90b              CBNZ     r3,|L3.28|
000018  2401              MOVS     r4,#1                 ;332
00001a  e000              B        |L3.30|
                  |L3.28|
00001c  2400              MOVS     r4,#0                 ;332
                  |L3.30|
00001e  1b00              SUBS     r0,r0,r4              ;332
000020  e7f6              B        |L3.16|
;;;335    
                          ENDP


                          AREA ||i.RingBufContigUsed||, CODE, READONLY, ALIGN=1

                  RingBufContigUsed PROC
;;;257    unsigned long
;;;258    RingBufContigUsed(tRingBufObject *ptRingBuf)
000000  4601              MOV      r1,r0
;;;259    {
;;;260        unsigned long ulWrite;
;;;261        unsigned long ulRead;
;;;262    
;;;263        //
;;;264        // Check the arguments.
;;;265        //
;;;266    //    ASSERT(ptRingBuf != NULL);
;;;267    
;;;268        //
;;;269        // Copy the Read/Write indices for calculation.
;;;270        //
;;;271        ulWrite = ptRingBuf->ulWriteIndex;
000002  684b              LDR      r3,[r1,#4]
;;;272        ulRead = ptRingBuf->ulReadIndex;
000004  688a              LDR      r2,[r1,#8]
;;;273    
;;;274        //
;;;275        // Return the number of contiguous bytes available.
;;;276        //
;;;277        return((ulWrite >= ulRead) ? (ulWrite - ulRead) :
000006  4293              CMP      r3,r2
000008  d301              BCC      |L4.14|
00000a  1a98              SUBS     r0,r3,r2
                  |L4.12|
;;;278               (ptRingBuf->ulSize - ulRead));
;;;279    }
00000c  4770              BX       lr
                  |L4.14|
00000e  6808              LDR      r0,[r1,#0]            ;278
000010  1a80              SUBS     r0,r0,r2              ;278
000012  e7fb              B        |L4.12|
;;;280    
                          ENDP


                          AREA ||i.RingBufEmpty||, CODE, READONLY, ALIGN=1

                  RingBufEmpty PROC
;;;127    tBoolean
;;;128    RingBufEmpty(tRingBufObject *ptRingBuf)
000000  4601              MOV      r1,r0
;;;129    {
;;;130        unsigned long ulWrite;
;;;131        unsigned long ulRead;
;;;132    
;;;133        //
;;;134        // Check the arguments.
;;;135        //
;;;136    //    ASSERT(ptRingBuf != NULL);
;;;137    
;;;138        //
;;;139        // Copy the Read/Write indices for calculation.
;;;140        //
;;;141        ulWrite = ptRingBuf->ulWriteIndex;
000002  684a              LDR      r2,[r1,#4]
;;;142        ulRead = ptRingBuf->ulReadIndex;
000004  688b              LDR      r3,[r1,#8]
;;;143    
;;;144        //
;;;145        // Return the empty status of the buffer.
;;;146        //
;;;147        return((ulWrite == ulRead) ? 1 : 0);
000006  429a              CMP      r2,r3
000008  d101              BNE      |L5.14|
00000a  2001              MOVS     r0,#1
                  |L5.12|
;;;148    }
00000c  4770              BX       lr
                  |L5.14|
00000e  2000              MOVS     r0,#0                 ;147
000010  e7fc              B        |L5.12|
;;;149    
                          ENDP


                          AREA ||i.RingBufFlush||, CODE, READONLY, ALIGN=1

                  RingBufFlush PROC
;;;161    void
;;;162    RingBufFlush(tRingBufObject *ptRingBuf)
000000  6841              LDR      r1,[r0,#4]
;;;163    {
;;;164        tBoolean bIntsOff;
;;;165    
;;;166        //
;;;167        // Check the arguments.
;;;168        //
;;;169    //    ASSERT(ptRingBuf != NULL);
;;;170    
;;;171        //
;;;172        // Set the Read/Write pointers to be the same. Do this with interrupts
;;;173        // disabled to prevent the possibility of corruption of the read index.
;;;174        //
;;;175    //    bIntsOff = IntMasterDisable();
;;;176        ptRingBuf->ulReadIndex = ptRingBuf->ulWriteIndex;
000002  6081              STR      r1,[r0,#8]
;;;177        if(!bIntsOff)
;;;178        {
;;;179    //        IntMasterEnable();
;;;180        }
;;;181    }
000004  4770              BX       lr
;;;182    
                          ENDP


                          AREA ||i.RingBufFree||, CODE, READONLY, ALIGN=1

                  RingBufFree PROC
;;;229    unsigned long
;;;230    RingBufFree(tRingBufObject *ptRingBuf)
000000  b510              PUSH     {r4,lr}
;;;231    {
000002  4604              MOV      r4,r0
;;;232        //
;;;233        // Check the arguments.
;;;234        //
;;;235    //    ASSERT(ptRingBuf != NULL);
;;;236    
;;;237        //
;;;238        // Return the number of bytes available in the ring buffer.
;;;239        //
;;;240        return((ptRingBuf->ulSize - 1) - RingBufUsed(ptRingBuf));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       RingBufUsed
00000a  6821              LDR      r1,[r4,#0]
00000c  1e49              SUBS     r1,r1,#1
00000e  1a08              SUBS     r0,r1,r0
;;;241    }
000010  bd10              POP      {r4,pc}
;;;242    
                          ENDP


                          AREA ||i.RingBufFull||, CODE, READONLY, ALIGN=1

                  RingBufFull PROC
;;;89     tBoolean
;;;90     RingBufFull(tRingBufObject *ptRingBuf)
000000  b530              PUSH     {r4,r5,lr}
;;;91     {
000002  4601              MOV      r1,r0
;;;92         unsigned long ulWrite;
;;;93         unsigned long ulRead;
;;;94     
;;;95         //
;;;96         // Check the arguments.
;;;97         //
;;;98     //    ASSERT(ptRingBuf != NULL);
;;;99     
;;;100        //
;;;101        // Copy the Read/Write indices for calculation.
;;;102        //
;;;103        ulWrite = ptRingBuf->ulWriteIndex;
000004  684b              LDR      r3,[r1,#4]
;;;104        ulRead = ptRingBuf->ulReadIndex;
000006  688a              LDR      r2,[r1,#8]
;;;105    
;;;106        //
;;;107        // Return the full status of the buffer.
;;;108        //
;;;109        return((((ulWrite + 1) % ptRingBuf->ulSize) == ulRead) ? 1 : 0);
000008  1c58              ADDS     r0,r3,#1
00000a  680c              LDR      r4,[r1,#0]
00000c  fbb0f5f4          UDIV     r5,r0,r4
000010  fb040015          MLS      r0,r4,r5,r0
000014  4290              CMP      r0,r2
000016  d101              BNE      |L8.28|
000018  2001              MOVS     r0,#1
                  |L8.26|
;;;110    }
00001a  bd30              POP      {r4,r5,pc}
                  |L8.28|
00001c  2000              MOVS     r0,#0                 ;109
00001e  e7fc              B        |L8.26|
;;;111    
                          ENDP


                          AREA ||i.RingBufInit||, CODE, READONLY, ALIGN=1

                  RingBufInit PROC
;;;718    void
;;;719    RingBufInit(tRingBufObject *ptRingBuf, unsigned char *pucBuf,
000000  6002              STR      r2,[r0,#0]
;;;720                   unsigned long ulSize)
;;;721    {
;;;722        //
;;;723        // Check the arguments.
;;;724        //
;;;725    //     ASSERT(ptRingBuf != NULL);
;;;726    //     ASSERT(pucBuf != NULL);
;;;727    //     ASSERT(ulSize != 0);
;;;728    
;;;729        //
;;;730        // Initialize the ring buffer object.
;;;731        //
;;;732        ptRingBuf->ulSize = ulSize;
;;;733        ptRingBuf->pucBuf = pucBuf;
000002  60c1              STR      r1,[r0,#0xc]
;;;734        ptRingBuf->ulWriteIndex = ptRingBuf->ulReadIndex = 0;
000004  2300              MOVS     r3,#0
000006  6083              STR      r3,[r0,#8]
000008  6043              STR      r3,[r0,#4]
;;;735    }
00000a  4770              BX       lr
;;;736    
                          ENDP


                          AREA ||i.RingBufProbe||, CODE, READONLY, ALIGN=1

                  RingBufProbe PROC
;;;737    unsigned char
;;;738    RingBufProbe(tRingBufObject *ptRingBuf, unsigned long ulSpan)
000000  b510              PUSH     {r4,lr}
;;;739    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;740        unsigned char ucTemp;
;;;741    		unsigned long ulIndex;
;;;742    
;;;743        ulIndex = ptRingBuf->ulReadIndex + ulSpan;
000006  6894              LDR      r4,[r2,#8]
000008  18e1              ADDS     r1,r4,r3
;;;744    		//
;;;745        // Correct for wrap. We use a loop here since we don't want to use a
;;;746        // modulus operation with interrupts off but we don't want to fail in
;;;747        // case ulDelta is greater than ulSize (which is extremely unlikely but...)
;;;748        //
;;;749        while(ulIndex >= ptRingBuf->ulSize)
00000a  e001              B        |L10.16|
                  |L10.12|
;;;750        {
;;;751            ulIndex -= ptRingBuf->ulSize;
00000c  6814              LDR      r4,[r2,#0]
00000e  1b09              SUBS     r1,r1,r4
                  |L10.16|
000010  6814              LDR      r4,[r2,#0]            ;749
000012  428c              CMP      r4,r1                 ;749
000014  d9fa              BLS      |L10.12|
;;;752        }
;;;753    
;;;754        //
;;;755        // read the data byte.
;;;756        //
;;;757        ucTemp = ptRingBuf->pucBuf[ulIndex];
000016  68d4              LDR      r4,[r2,#0xc]
000018  5c60              LDRB     r0,[r4,r1]
;;;758    
;;;759        //
;;;760        // Return the character read.
;;;761        //
;;;762        return(ucTemp);
;;;763    }
00001a  bd10              POP      {r4,pc}
;;;764    //*****************************************************************************
                          ENDP


                          AREA ||i.RingBufRead||, CODE, READONLY, ALIGN=1

                  RingBufRead PROC
;;;446    void
;;;447    RingBufRead(tRingBufObject *ptRingBuf, unsigned char *pucData,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;448                   unsigned long ulLength)
;;;449    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;450        unsigned long ulTemp;
;;;451    
;;;452        //
;;;453        // Check the arguments.
;;;454        //
;;;455    //     ASSERT(ptRingBuf != NULL);
;;;456    //     ASSERT(pucData != NULL);
;;;457    //     ASSERT(ulLength != 0);
;;;458    
;;;459        //
;;;460        // Verify that data is available in the buffer.
;;;461        //
;;;462    //     ASSERT(ulLength <= RingBufUsed(ptRingBuf));
;;;463    
;;;464        //
;;;465        // Read the data from the ring buffer.
;;;466        //
;;;467        for(ulTemp = 0; ulTemp < ulLength; ulTemp++)
00000a  2400              MOVS     r4,#0
00000c  e004              B        |L11.24|
                  |L11.14|
;;;468        {
;;;469            pucData[ulTemp] = RingBufReadOne(ptRingBuf);
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       RingBufReadOne
000014  5528              STRB     r0,[r5,r4]
000016  1c64              ADDS     r4,r4,#1              ;467
                  |L11.24|
000018  42b4              CMP      r4,r6                 ;467
00001a  d3f8              BCC      |L11.14|
;;;470        }
;;;471    }
00001c  e8bd81f0          POP      {r4-r8,pc}
;;;472    
                          ENDP


                          AREA ||i.RingBufReadOne||, CODE, READONLY, ALIGN=1

                  RingBufReadOne PROC
;;;372    unsigned char
;;;373    RingBufReadOne(tRingBufObject *ptRingBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;374    {
000002  4604              MOV      r4,r0
;;;375        unsigned char ucTemp;
;;;376    
;;;377        //
;;;378        // Check the arguments.
;;;379        //
;;;380    //    ASSERT(ptRingBuf != NULL);
;;;381    
;;;382        //
;;;383        // Verify that space is available in the buffer.
;;;384        //
;;;385    //    ASSERT(RingBufUsed(ptRingBuf) != 0);
;;;386    
;;;387        //
;;;388        // Write the data byte.
;;;389        //
;;;390        ucTemp = ptRingBuf->pucBuf[ptRingBuf->ulReadIndex];
000004  e9d41002          LDRD     r1,r0,[r4,#8]
000008  5c45              LDRB     r5,[r0,r1]
;;;391    
;;;392        //
;;;393        // Increment the read index.
;;;394        //
;;;395        UpdateIndexAtomic(&ptRingBuf->ulReadIndex, 1, ptRingBuf->ulSize);
00000a  2101              MOVS     r1,#1
00000c  f1040008          ADD      r0,r4,#8
000010  6822              LDR      r2,[r4,#0]
000012  f7fffffe          BL       UpdateIndexAtomic
;;;396    
;;;397        //
;;;398        // Return the character read.
;;;399        //
;;;400        return(ucTemp);
000016  4628              MOV      r0,r5
;;;401    }
000018  bd70              POP      {r4-r6,pc}
;;;402    unsigned short
                          ENDP


                          AREA ||i.RingBufSize||, CODE, READONLY, ALIGN=1

                  RingBufSize PROC
;;;347    unsigned long
;;;348    RingBufSize(tRingBufObject *ptRingBuf)
000000  4601              MOV      r1,r0
;;;349    {
;;;350        //
;;;351        // Check the arguments.
;;;352        //
;;;353    //    ASSERT(ptRingBuf != NULL);
;;;354    
;;;355        //
;;;356        // Return the number of bytes available in the ring buffer.
;;;357        //
;;;358        return(ptRingBuf->ulSize);
000002  6808              LDR      r0,[r1,#0]
;;;359    }
000004  4770              BX       lr
;;;360    
                          ENDP


                          AREA ||i.RingBufU16ReadOne||, CODE, READONLY, ALIGN=1

                  RingBufU16ReadOne PROC
;;;402    unsigned short
;;;403    RingBufU16ReadOne(tRingBufU16Object *ptRingBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;404    {
000002  4604              MOV      r4,r0
;;;405        unsigned short usTemp;
;;;406    
;;;407        //
;;;408        // Check the arguments.
;;;409        //
;;;410    //    ASSERT(ptRingBuf != NULL);
;;;411    
;;;412        //
;;;413        // Verify that space is available in the buffer.
;;;414        //
;;;415    //    ASSERT(RingBufUsed(ptRingBuf) != 0);
;;;416    
;;;417        //
;;;418        // Write the data byte.
;;;419        //
;;;420        usTemp = ptRingBuf->pucBuf[ptRingBuf->ulReadIndex];
000004  e9d41002          LDRD     r1,r0,[r4,#8]
000008  f8305011          LDRH     r5,[r0,r1,LSL #1]
;;;421    
;;;422        //
;;;423        // Increment the read index.
;;;424        //
;;;425        UpdateIndexAtomic(&ptRingBuf->ulReadIndex, 1, ptRingBuf->ulSize);
00000c  2101              MOVS     r1,#1
00000e  f1040008          ADD      r0,r4,#8
000012  6822              LDR      r2,[r4,#0]
000014  f7fffffe          BL       UpdateIndexAtomic
;;;426    
;;;427        //
;;;428        // Return the character read.
;;;429        //
;;;430        return(usTemp);
000018  4628              MOV      r0,r5
;;;431    }
00001a  bd70              POP      {r4-r6,pc}
;;;432    
                          ENDP


                          AREA ||i.RingBufU16WriteOne||, CODE, READONLY, ALIGN=1

                  RingBufU16WriteOne PROC
;;;639    void
;;;640    RingBufU16WriteOne(tRingBufU16Object *ptRingBuf, unsigned short ucData)
000000  b570              PUSH     {r4-r6,lr}
;;;641    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;642        //
;;;643        // Check the arguments.
;;;644        //
;;;645    //     ASSERT(ptRingBuf != NULL);
;;;646    
;;;647        //
;;;648        // Verify that space is available in the buffer.
;;;649        //
;;;650    //     ASSERT(RingBufFree(ptRingBuf) != 0);
;;;651    
;;;652        //
;;;653        // Write the data byte.
;;;654        //
;;;655        ptRingBuf->pucBuf[ptRingBuf->ulWriteIndex] = ucData;
000006  6861              LDR      r1,[r4,#4]
000008  68e0              LDR      r0,[r4,#0xc]
00000a  f8205011          STRH     r5,[r0,r1,LSL #1]
;;;656    
;;;657        //
;;;658        // Increment the write index.
;;;659        //
;;;660        UpdateIndexAtomic(&ptRingBuf->ulWriteIndex, 1, ptRingBuf->ulSize);
00000e  2101              MOVS     r1,#1
000010  1d20              ADDS     r0,r4,#4
000012  6822              LDR      r2,[r4,#0]
000014  f7fffffe          BL       UpdateIndexAtomic
;;;661    }
000018  bd70              POP      {r4-r6,pc}
;;;662    
                          ENDP


                          AREA ||i.RingBufUsed||, CODE, READONLY, ALIGN=1

                  RingBufUsed PROC
;;;194    unsigned long
;;;195    RingBufUsed(tRingBufObject *ptRingBuf)
000000  b510              PUSH     {r4,lr}
;;;196    {
000002  4601              MOV      r1,r0
;;;197        unsigned long ulWrite;
;;;198        unsigned long ulRead;
;;;199    
;;;200        //
;;;201        // Check the arguments.
;;;202        //
;;;203    //    ASSERT(ptRingBuf != NULL);
;;;204    
;;;205        //
;;;206        // Copy the Read/Write indices for calculation.
;;;207        //
;;;208        ulWrite = ptRingBuf->ulWriteIndex;
000004  684a              LDR      r2,[r1,#4]
;;;209        ulRead = ptRingBuf->ulReadIndex;
000006  688b              LDR      r3,[r1,#8]
;;;210    
;;;211        //
;;;212        // Return the number of bytes contained in the ring buffer.
;;;213        //
;;;214        return((ulWrite >= ulRead) ? (ulWrite - ulRead) :
000008  429a              CMP      r2,r3
00000a  d301              BCC      |L16.16|
00000c  1ad0              SUBS     r0,r2,r3
                  |L16.14|
;;;215               (ptRingBuf->ulSize - (ulRead - ulWrite)));
;;;216    }
00000e  bd10              POP      {r4,pc}
                  |L16.16|
000010  1a9c              SUBS     r4,r3,r2              ;215
000012  6808              LDR      r0,[r1,#0]            ;215
000014  1b00              SUBS     r0,r0,r4              ;215
000016  e7fa              B        |L16.14|
;;;217    
                          ENDP


                          AREA ||i.RingBufWrite||, CODE, READONLY, ALIGN=1

                  RingBufWrite PROC
;;;678    void
;;;679    RingBufWrite(tRingBufObject *ptRingBuf, unsigned char *pucData,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;680                    unsigned long ulLength)
;;;681    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;682        unsigned long ulTemp;
;;;683    
;;;684        //
;;;685        // Check the arguments.
;;;686        //
;;;687    //     ASSERT(ptRingBuf != NULL);
;;;688    //     ASSERT(pucData != NULL);
;;;689    //     ASSERT(ulLength != 0);
;;;690    
;;;691        //
;;;692        // Verify that space is available in the buffer.
;;;693        //
;;;694    //     ASSERT(ulLength <= RingBufFree(ptRingBuf));
;;;695    
;;;696        //
;;;697        // Write the data into the ring buffer.
;;;698        //
;;;699        for(ulTemp = 0; ulTemp < ulLength; ulTemp++)
00000a  2400              MOVS     r4,#0
00000c  e004              B        |L17.24|
                  |L17.14|
;;;700        {
;;;701            RingBufWriteOne(ptRingBuf, pucData[ulTemp]);
00000e  5d29              LDRB     r1,[r5,r4]
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       RingBufWriteOne
000016  1c64              ADDS     r4,r4,#1              ;699
                  |L17.24|
000018  42b4              CMP      r4,r6                 ;699
00001a  d3f8              BCC      |L17.14|
;;;702        }
;;;703    }
00001c  e8bd81f0          POP      {r4-r8,pc}
;;;704    
                          ENDP


                          AREA ||i.RingBufWriteOne||, CODE, READONLY, ALIGN=1

                  RingBufWriteOne PROC
;;;615    void
;;;616    RingBufWriteOne(tRingBufObject *ptRingBuf, unsigned char ucData)
000000  b570              PUSH     {r4-r6,lr}
;;;617    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;618        //
;;;619        // Check the arguments.
;;;620        //
;;;621    //     ASSERT(ptRingBuf != NULL);
;;;622    
;;;623        //
;;;624        // Verify that space is available in the buffer.
;;;625        //
;;;626    //     ASSERT(RingBufFree(ptRingBuf) != 0);
;;;627    
;;;628        //
;;;629        // Write the data byte.
;;;630        //
;;;631        ptRingBuf->pucBuf[ptRingBuf->ulWriteIndex] = ucData;
000006  6861              LDR      r1,[r4,#4]
000008  68e0              LDR      r0,[r4,#0xc]
00000a  5445              STRB     r5,[r0,r1]
;;;632    
;;;633        //
;;;634        // Increment the write index.
;;;635        //
;;;636        UpdateIndexAtomic(&ptRingBuf->ulWriteIndex, 1, ptRingBuf->ulSize);
00000c  2101              MOVS     r1,#1
00000e  1d20              ADDS     r0,r4,#4
000010  6822              LDR      r2,[r4,#0]
000012  f7fffffe          BL       UpdateIndexAtomic
;;;637    }
000016  bd70              POP      {r4-r6,pc}
;;;638    
                          ENDP


                          AREA ||i.UpdateIndexAtomic||, CODE, READONLY, ALIGN=1

                  UpdateIndexAtomic PROC
;;;39     static void
;;;40     UpdateIndexAtomic(volatile unsigned long *pulVal, unsigned long ulDelta,
000000  6803              LDR      r3,[r0,#0]
;;;41                       unsigned long ulSize)
;;;42     {
;;;43         tBoolean bIntsOff;
;;;44     
;;;45         //
;;;46         // Turn interrupts off temporarily.
;;;47         //
;;;48     //    bIntsOff = IntMasterDisable();
;;;49     
;;;50         //
;;;51         // Update the variable value.
;;;52         //
;;;53         *pulVal += ulDelta;
000002  440b              ADD      r3,r3,r1
000004  6003              STR      r3,[r0,#0]
;;;54     
;;;55         //
;;;56         // Correct for wrap. We use a loop here since we don't want to use a
;;;57         // modulus operation with interrupts off but we don't want to fail in
;;;58         // case ulDelta is greater than ulSize (which is extremely unlikely but...)
;;;59         //
;;;60         while(*pulVal >= ulSize)
000006  e002              B        |L19.14|
                  |L19.8|
;;;61         {
;;;62             *pulVal -= ulSize;
000008  6803              LDR      r3,[r0,#0]
00000a  1a9b              SUBS     r3,r3,r2
00000c  6003              STR      r3,[r0,#0]
                  |L19.14|
00000e  6803              LDR      r3,[r0,#0]            ;60
000010  4293              CMP      r3,r2                 ;60
000012  d2f9              BCS      |L19.8|
;;;63         }
;;;64     
;;;65         //
;;;66         // Restore the interrupt state
;;;67         //
;;;68         if(!bIntsOff)
;;;69         {
;;;70     //        IntMasterEnable();
;;;71         }
;;;72     }
000014  4770              BX       lr
;;;73     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\ringbuf.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_ringbuf_c_d728d76a____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_ringbuf_c_d728d76a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_ringbuf_c_d728d76a____REVSH|
#line 144
|__asm___9_ringbuf_c_d728d76a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_ringbuf_c_d728d76a____RRX|
#line 300
|__asm___9_ringbuf_c_d728d76a____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
