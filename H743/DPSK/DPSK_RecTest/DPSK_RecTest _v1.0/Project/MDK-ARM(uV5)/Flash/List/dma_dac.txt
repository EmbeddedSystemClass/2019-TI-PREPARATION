; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\dma_dac.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\dma_dac.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\MiddleWareDrv -I..\..\User\RTT -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 --omf_browse=.\flash\obj\dma_dac.crf ..\..\User\MiddleWareDrv\DMA_DAC.c]
                          THUMB

                          AREA ||i.DAC_Ch1_SineWaveConfig||, CODE, READONLY, ALIGN=2

                  DAC_Ch1_SineWaveConfig PROC
;;;216    
;;;217    void DAC_Ch1_SineWaveConfig(uint16_t u16DAC_Buffer[], uint32_t u32DMA_Len)
000000  b530              PUSH     {r4,r5,lr}
;;;218    {
000002  b097              SUB      sp,sp,#0x5c
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;219      DMA_InitTypeDef DMA_InitStructure;
;;;220    	
;;;221    	NVIC_InitTypeDef NVIC_InitStructure;
;;;222    	
;;;223    	DAC_InitTypeDef  DAC_InitStructure;
;;;224    	
;;;225    /* Preconfiguration before using DAC----------------------------------------*/
;;;226      GPIO_InitTypeDef GPIO_InitStructure;
;;;227    
;;;228    	
;;;229    	/* DMA1 clock enable */
;;;230      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  0548              LSLS     r0,r1,#21
00000c  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;231      /* GPIOA clock enable (to be used with DAC) */
;;;232      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);                         
000010  2101              MOVS     r1,#1
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;233      /* DAC Periph clock enable */
;;;234      RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);	
000018  2101              MOVS     r1,#1
00001a  0748              LSLS     r0,r1,#29
00001c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;235    	
;;;236    	
;;;237    /* DAC channel 1 (DAC_OUT1 = PA.4) configuration */
;;;238      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
000020  2010              MOVS     r0,#0x10
000022  9001              STR      r0,[sp,#4]
;;;239      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
000024  2003              MOVS     r0,#3
000026  f88d0008          STRB     r0,[sp,#8]
;;;240      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
00002a  2000              MOVS     r0,#0
00002c  f88d000b          STRB     r0,[sp,#0xb]
;;;241      GPIO_Init(GPIOA, &GPIO_InitStructure);
000030  a901              ADD      r1,sp,#4
000032  4829              LDR      r0,|L1.216|
000034  f7fffffe          BL       GPIO_Init
;;;242    
;;;243    	
;;;244    	/* TIM6 Configuration ------------------------------------------------------*/
;;;245      TIM6_Config();  
000038  f7fffffe          BL       TIM6_Config
;;;246    	
;;;247    	
;;;248      /* DAC channel1 Configuration */
;;;249      DAC_InitStructure.DAC_Trigger = DAC_Trigger_T6_TRGO;
00003c  2004              MOVS     r0,#4
00003e  9003              STR      r0,[sp,#0xc]
;;;250      DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;
000040  2000              MOVS     r0,#0
000042  9004              STR      r0,[sp,#0x10]
;;;251      DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
000044  9006              STR      r0,[sp,#0x18]
;;;252      DAC_Init(DAC_Channel_1, &DAC_InitStructure);
000046  a903              ADD      r1,sp,#0xc
000048  f7fffffe          BL       DAC_Init
;;;253    	
;;;254    	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Stream5_IRQn;					// ADC DMA stream0 ch0
00004c  2010              MOVS     r0,#0x10
00004e  f88d001c          STRB     r0,[sp,#0x1c]
;;;255      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000052  2000              MOVS     r0,#0
000054  f88d001d          STRB     r0,[sp,#0x1d]
;;;256      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000058  2001              MOVS     r0,#1
00005a  f88d001e          STRB     r0,[sp,#0x1e]
;;;257      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00005e  f88d001f          STRB     r0,[sp,#0x1f]
;;;258      NVIC_Init(&NVIC_InitStructure);
000062  a807              ADD      r0,sp,#0x1c
000064  f7fffffe          BL       NVIC_Init
;;;259    
;;;260      /* DMA1_Stream5 channel7 configuration **************************************/  
;;;261      DMA_DeInit(DMA1_Stream5);
000068  481c              LDR      r0,|L1.220|
00006a  f7fffffe          BL       DMA_DeInit
;;;262      DMA_InitStructure.DMA_Channel = DMA_Channel_7;  
00006e  f04f6060          MOV      r0,#0xe000000
000072  9008              STR      r0,[sp,#0x20]
;;;263      DMA_InitStructure.DMA_PeripheralBaseAddr = DAC_DHR12R1_ADDRESS;
000074  481a              LDR      r0,|L1.224|
000076  9009              STR      r0,[sp,#0x24]
;;;264      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)u16DAC_Buffer;
000078  950a              STR      r5,[sp,#0x28]
;;;265      DMA_InitStructure.DMA_BufferSize = u32DMA_Len;
00007a  940c              STR      r4,[sp,#0x30]
;;;266      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
00007c  14c0              ASRS     r0,r0,#19
00007e  900f              STR      r0,[sp,#0x3c]
;;;267      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000080  0080              LSLS     r0,r0,#2
000082  9010              STR      r0,[sp,#0x40]
;;;268      DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
000084  2040              MOVS     r0,#0x40
000086  900b              STR      r0,[sp,#0x2c]
;;;269      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
000088  2000              MOVS     r0,#0
00008a  900d              STR      r0,[sp,#0x34]
;;;270      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
00008c  f44f6080          MOV      r0,#0x400
000090  900e              STR      r0,[sp,#0x38]
;;;271      DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
000092  1080              ASRS     r0,r0,#2
000094  9011              STR      r0,[sp,#0x44]
;;;272      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000096  0240              LSLS     r0,r0,#9
000098  9012              STR      r0,[sp,#0x48]
;;;273      DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
00009a  2000              MOVS     r0,#0
00009c  9013              STR      r0,[sp,#0x4c]
;;;274      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
00009e  2001              MOVS     r0,#1
0000a0  9014              STR      r0,[sp,#0x50]
;;;275      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
0000a2  2000              MOVS     r0,#0
0000a4  9015              STR      r0,[sp,#0x54]
;;;276      DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
0000a6  9016              STR      r0,[sp,#0x58]
;;;277      DMA_Init(DMA1_Stream5, &DMA_InitStructure);    
0000a8  a908              ADD      r1,sp,#0x20
0000aa  480c              LDR      r0,|L1.220|
0000ac  f7fffffe          BL       DMA_Init
;;;278    
;;;279      /* Enable DMA1_Stream5 */
;;;280      DMA_Cmd(DMA1_Stream5, ENABLE);
0000b0  2101              MOVS     r1,#1
0000b2  480a              LDR      r0,|L1.220|
0000b4  f7fffffe          BL       DMA_Cmd
;;;281    	
;;;282    	DMA_ITConfig(DMA1_Stream5, DMA_IT_TC | DMA_IT_HT,ENABLE);  //配置DMA接收完成和半满后产生中断
0000b8  2201              MOVS     r2,#1
0000ba  2118              MOVS     r1,#0x18
0000bc  4807              LDR      r0,|L1.220|
0000be  f7fffffe          BL       DMA_ITConfig
;;;283      
;;;284      /* Enable DAC Channel1 */
;;;285      DAC_Cmd(DAC_Channel_1, ENABLE);
0000c2  2101              MOVS     r1,#1
0000c4  2000              MOVS     r0,#0
0000c6  f7fffffe          BL       DAC_Cmd
;;;286    
;;;287      /* Enable DMA for DAC Channel1 */
;;;288      DAC_DMACmd(DAC_Channel_1, ENABLE);
0000ca  2101              MOVS     r1,#1
0000cc  2000              MOVS     r0,#0
0000ce  f7fffffe          BL       DAC_DMACmd
;;;289    }
0000d2  b017              ADD      sp,sp,#0x5c
0000d4  bd30              POP      {r4,r5,pc}
                          ENDP

0000d6  0000              DCW      0x0000
                  |L1.216|
                          DCD      0x40020000
                  |L1.220|
                          DCD      0x40026088
                  |L1.224|
                          DCD      0x40007408

                          AREA ||i.DAC_Ch2_SineWaveConfig||, CODE, READONLY, ALIGN=2

                  DAC_Ch2_SineWaveConfig PROC
;;;139    
;;;140    void DAC_Ch2_SineWaveConfig(uint16_t u16DAC_Buffer[], uint32_t u32DMA_Len)
000000  b530              PUSH     {r4,r5,lr}
;;;141    {
000002  b097              SUB      sp,sp,#0x5c
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;142      DMA_InitTypeDef DMA_InitStructure;
;;;143    	
;;;144    	NVIC_InitTypeDef NVIC_InitStructure;
;;;145    	
;;;146    	DAC_InitTypeDef  DAC_InitStructure;
;;;147    	
;;;148    /* Preconfiguration before using DAC----------------------------------------*/
;;;149      GPIO_InitTypeDef GPIO_InitStructure;
;;;150    
;;;151    	
;;;152    	
;;;153    	/* DMA1 clock enable */
;;;154      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  0548              LSLS     r0,r1,#21
00000c  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;155      /* GPIOA clock enable (to be used with DAC) */
;;;156      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);                         
000010  2101              MOVS     r1,#1
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;157      /* DAC Periph clock enable */
;;;158      RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);	
000018  2101              MOVS     r1,#1
00001a  0748              LSLS     r0,r1,#29
00001c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;159    
;;;160    	
;;;161    	/* TIM6 Configuration ------------------------------------------------------*/
;;;162      TIM6_Config();  
000020  f7fffffe          BL       TIM6_Config
;;;163    	
;;;164    	
;;;165      /* DAC channel 2 (DAC_OUT2 = PA.5) configuration */
;;;166      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
000024  2020              MOVS     r0,#0x20
000026  9001              STR      r0,[sp,#4]
;;;167      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
000028  2003              MOVS     r0,#3
00002a  f88d0008          STRB     r0,[sp,#8]
;;;168      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
00002e  2000              MOVS     r0,#0
000030  f88d000b          STRB     r0,[sp,#0xb]
;;;169      GPIO_Init(GPIOA, &GPIO_InitStructure);
000034  a901              ADD      r1,sp,#4
000036  4828              LDR      r0,|L2.216|
000038  f7fffffe          BL       GPIO_Init
;;;170      
;;;171      /* DAC channel2 Configuration */
;;;172      DAC_InitStructure.DAC_Trigger = DAC_Trigger_T6_TRGO;
00003c  2004              MOVS     r0,#4
00003e  9003              STR      r0,[sp,#0xc]
;;;173      DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;
000040  2000              MOVS     r0,#0
000042  9004              STR      r0,[sp,#0x10]
;;;174      DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
000044  9006              STR      r0,[sp,#0x18]
;;;175      DAC_Init(DAC_Channel_2, &DAC_InitStructure);
000046  a903              ADD      r1,sp,#0xc
000048  2010              MOVS     r0,#0x10
00004a  f7fffffe          BL       DAC_Init
;;;176    
;;;177    	
;;;178    	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Stream6_IRQn;					// ADC DMA stream0 ch0
00004e  2011              MOVS     r0,#0x11
000050  f88d001c          STRB     r0,[sp,#0x1c]
;;;179      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000054  2000              MOVS     r0,#0
000056  f88d001d          STRB     r0,[sp,#0x1d]
;;;180      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
00005a  2001              MOVS     r0,#1
00005c  f88d001e          STRB     r0,[sp,#0x1e]
;;;181      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000060  f88d001f          STRB     r0,[sp,#0x1f]
;;;182      NVIC_Init(&NVIC_InitStructure);
000064  a807              ADD      r0,sp,#0x1c
000066  f7fffffe          BL       NVIC_Init
;;;183    	
;;;184      /* DMA1_Stream6 channel7 configuration **************************************/
;;;185      DMA_DeInit(DMA1_Stream6);
00006a  481c              LDR      r0,|L2.220|
00006c  f7fffffe          BL       DMA_DeInit
;;;186      DMA_InitStructure.DMA_Channel = DMA_Channel_7;  
000070  f04f6060          MOV      r0,#0xe000000
000074  9008              STR      r0,[sp,#0x20]
;;;187      DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)DAC_DHR12R2_ADDRESS;
000076  481a              LDR      r0,|L2.224|
000078  9009              STR      r0,[sp,#0x24]
;;;188      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)u16DAC_Buffer;
00007a  950a              STR      r5,[sp,#0x28]
;;;189      DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
00007c  2040              MOVS     r0,#0x40
00007e  900b              STR      r0,[sp,#0x2c]
;;;190      DMA_InitStructure.DMA_BufferSize = u32DMA_Len;
000080  940c              STR      r4,[sp,#0x30]
;;;191      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
000082  2000              MOVS     r0,#0
000084  900d              STR      r0,[sp,#0x34]
;;;192      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
000086  f44f6080          MOV      r0,#0x400
00008a  900e              STR      r0,[sp,#0x38]
;;;193      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
00008c  0040              LSLS     r0,r0,#1
00008e  900f              STR      r0,[sp,#0x3c]
;;;194      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000090  0080              LSLS     r0,r0,#2
000092  9010              STR      r0,[sp,#0x40]
;;;195      DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
000094  1140              ASRS     r0,r0,#5
000096  9011              STR      r0,[sp,#0x44]
;;;196      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000098  0240              LSLS     r0,r0,#9
00009a  9012              STR      r0,[sp,#0x48]
;;;197      DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
00009c  2000              MOVS     r0,#0
00009e  9013              STR      r0,[sp,#0x4c]
;;;198      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
0000a0  2001              MOVS     r0,#1
0000a2  9014              STR      r0,[sp,#0x50]
;;;199      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
0000a4  2000              MOVS     r0,#0
0000a6  9015              STR      r0,[sp,#0x54]
;;;200      DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
0000a8  9016              STR      r0,[sp,#0x58]
;;;201      DMA_Init(DMA1_Stream6, &DMA_InitStructure);
0000aa  a908              ADD      r1,sp,#0x20
0000ac  480b              LDR      r0,|L2.220|
0000ae  f7fffffe          BL       DMA_Init
;;;202    
;;;203      /* Enable DMA1_Stream6 */
;;;204      DMA_Cmd(DMA1_Stream6, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  4809              LDR      r0,|L2.220|
0000b6  f7fffffe          BL       DMA_Cmd
;;;205    
;;;206    	DMA_ITConfig(DMA1_Stream6, DMA_IT_TC | DMA_IT_HT,ENABLE);  //配置DMA接收完成和半满后产生中断
0000ba  2201              MOVS     r2,#1
0000bc  2118              MOVS     r1,#0x18
0000be  4807              LDR      r0,|L2.220|
0000c0  f7fffffe          BL       DMA_ITConfig
;;;207    
;;;208    
;;;209      /* Enable DAC Channel2 */
;;;210      DAC_Cmd(DAC_Channel_2, ENABLE);
0000c4  2101              MOVS     r1,#1
0000c6  2010              MOVS     r0,#0x10
0000c8  f7fffffe          BL       DAC_Cmd
;;;211    
;;;212      /* Enable DMA for DAC Channel2 */
;;;213      DAC_DMACmd(DAC_Channel_2, ENABLE);
0000cc  2101              MOVS     r1,#1
0000ce  2010              MOVS     r0,#0x10
0000d0  f7fffffe          BL       DAC_DMACmd
;;;214    }
0000d4  b017              ADD      sp,sp,#0x5c
0000d6  bd30              POP      {r4,r5,pc}
;;;215    
                          ENDP

                  |L2.216|
                          DCD      0x40020000
                  |L2.220|
                          DCD      0x400260a0
                  |L2.224|
                          DCD      0x40007414

                          AREA ||i.DMA1_Stream5_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA1_Stream5_IRQHandler PROC
;;;54     
;;;55     void DMA1_Stream5_IRQHandler(void)
000000  480b              LDR      r0,|L3.48|
;;;56     {
;;;57      		int i;
;;;58     	
;;;59     		if (DMA1->HISR & DMA_IT_HTIF5)										// Stream0半传输事件完成
000002  6840              LDR      r0,[r0,#4]
000004  490b              LDR      r1,|L3.52|
000006  4008              ANDS     r0,r0,r1
000008  b130              CBZ      r0,|L3.24|
;;;60      		{ 
;;;61     
;;;62     // 			 DMA1->LIFCR |= DMA_FLAG_HTIF1;									// 清除通道3半传输完成标志
;;;63     			 DMA1->HIFCR = (DMA_FLAG_HTIF5 & 0x0fff0fff);									// 清除通道3半传输完成标志
00000a  14c8              ASRS     r0,r1,#19
00000c  4908              LDR      r1,|L3.48|
00000e  60c8              STR      r0,[r1,#0xc]
;;;64     
;;;65     			 u8DAC1_Halffull = 1;												// 前半个缓冲区满
000010  2001              MOVS     r0,#1
000012  4909              LDR      r1,|L3.56|
000014  7008              STRB     r0,[r1,#0]
000016  e00a              B        |L3.46|
                  |L3.24|
;;;66     			 
;;;67     //			 for (i = 0; i < (4000); i++)
;;;68     //			 {
;;;69     //					 // 一旦半满中断产生，则把充满缓冲区一半的数据立即读出来
;;;70     //					 RingBufU16WriteOne(&sADC_RingBuf, uhADCxConvertedValue[i]);
;;;71     //				 
;;;72     //			 }
;;;73     
;;;74     		}// End if (DMA1->HISR & DMA_IT_HTIF6)
;;;75     		else 
;;;76     		if (DMA1->HISR & DMA_IT_TCIF5)															// 通道3传输事件完成
000018  4805              LDR      r0,|L3.48|
00001a  6840              LDR      r0,[r0,#4]
00001c  4907              LDR      r1,|L3.60|
00001e  4008              ANDS     r0,r0,r1
000020  b128              CBZ      r0,|L3.46|
;;;77      		{ 
;;;78     						u8DAC1_Halffull = 2;																			// 后半个缓冲区满
000022  2002              MOVS     r0,#2
000024  4904              LDR      r1,|L3.56|
000026  7008              STRB     r0,[r1,#0]
;;;79      						DMA1->HIFCR = (DMA_FLAG_TCIF5 & 0x0fff0fff);						// 清除Stream0传输完成标志
000028  0280              LSLS     r0,r0,#10
00002a  4901              LDR      r1,|L3.48|
00002c  60c8              STR      r0,[r1,#0xc]
                  |L3.46|
;;;80     							
;;;81     //						for (i = 0; i < (4000); i++)
;;;82     //						{
;;;83     //								RingBufU16WriteOne(&sADC_RingBuf, uhADCxConvertedValue[4000 + i]);
;;;84     //								
;;;85     //						}
;;;86     						
;;;87     		}// End else if (DMA1->HISR & DMA_IT_TCIF6)	
;;;88     	
;;;89     }
00002e  4770              BX       lr
;;;90     
                          ENDP

                  |L3.48|
                          DCD      0x40026000
                  |L3.52|
                          DCD      0x20004400
                  |L3.56|
                          DCD      u8DAC1_Halffull
                  |L3.60|
                          DCD      0x20008800

                          AREA ||i.DMA1_Stream6_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA1_Stream6_IRQHandler PROC
;;;17     
;;;18     void DMA1_Stream6_IRQHandler(void)
000000  480c              LDR      r0,|L4.52|
;;;19     {
;;;20      		int i;
;;;21     	
;;;22     		if (DMA1->HISR & DMA_IT_HTIF6)										// Stream0半传输事件完成
000002  6840              LDR      r0,[r0,#4]
000004  490c              LDR      r1,|L4.56|
000006  4008              ANDS     r0,r0,r1
000008  b138              CBZ      r0,|L4.26|
;;;23      		{ 
;;;24     
;;;25     // 			 DMA1->LIFCR |= DMA_FLAG_HTIF1;									// 清除通道3半传输完成标志
;;;26     			 DMA1->HIFCR = (DMA_FLAG_HTIF6 & 0x0fff0fff);									// 清除通道3半传输完成标志
00000a  f44f1080          MOV      r0,#0x100000
00000e  4909              LDR      r1,|L4.52|
000010  60c8              STR      r0,[r1,#0xc]
;;;27     
;;;28     			 u8DAC2_Halffull = 1;												// 前半个缓冲区满
000012  2001              MOVS     r0,#1
000014  4909              LDR      r1,|L4.60|
000016  7008              STRB     r0,[r1,#0]
000018  e00a              B        |L4.48|
                  |L4.26|
;;;29     			 
;;;30     //			 for (i = 0; i < (4000); i++)
;;;31     //			 {
;;;32     //					 // 一旦半满中断产生，则把充满缓冲区一半的数据立即读出来
;;;33     //					 RingBufU16WriteOne(&sADC_RingBuf, uhADCxConvertedValue[i]);
;;;34     //				 
;;;35     //			 }
;;;36     
;;;37     		}// End if (DMA1->HISR & DMA_IT_HTIF6)
;;;38     		else 
;;;39     		if (DMA1->HISR & DMA_IT_TCIF6)															// 通道3传输事件完成
00001a  4806              LDR      r0,|L4.52|
00001c  6840              LDR      r0,[r0,#4]
00001e  4908              LDR      r1,|L4.64|
000020  4008              ANDS     r0,r0,r1
000022  b128              CBZ      r0,|L4.48|
;;;40      		{ 
;;;41     						u8DAC2_Halffull = 2;																			// 后半个缓冲区满
000024  2002              MOVS     r0,#2
000026  4905              LDR      r1,|L4.60|
000028  7008              STRB     r0,[r1,#0]
;;;42      						DMA1->HIFCR = (DMA_FLAG_TCIF6 & 0x0fff0fff);						// 清除Stream0传输完成标志
00002a  0500              LSLS     r0,r0,#20
00002c  4901              LDR      r1,|L4.52|
00002e  60c8              STR      r0,[r1,#0xc]
                  |L4.48|
;;;43     							
;;;44     //						for (i = 0; i < (4000); i++)
;;;45     //						{
;;;46     //								RingBufU16WriteOne(&sADC_RingBuf, uhADCxConvertedValue[4000 + i]);
;;;47     //								
;;;48     //						}
;;;49     						
;;;50     		}// End else if (DMA1->HISR & DMA_IT_TCIF6)	
;;;51     	
;;;52     }
000030  4770              BX       lr
;;;53     
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      0x40026000
                  |L4.56|
                          DCD      0x20104000
                  |L4.60|
                          DCD      u8DAC2_Halffull
                  |L4.64|
                          DCD      0x20208000

                          AREA ||i.TIM6_Config||, CODE, READONLY, ALIGN=2

                  TIM6_Config PROC
;;;100      */
;;;101    static void TIM6_Config(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;102    {
;;;103      TIM_TimeBaseInitTypeDef    TIM_TimeBaseStructure;
;;;104    	
;;;105    	
;;;106      /* TIM6 Periph clock enable */
;;;107      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;108      
;;;109      /* --------------------------------------------------------
;;;110      TIM3 input clock (TIM6CLK) is set to 2 * APB1 clock (PCLK1), 
;;;111      since APB1 prescaler is different from 1.   
;;;112        TIM6CLK = 2 * PCLK1  
;;;113        TIM6CLK = HCLK / 2 = SystemCoreClock /2 
;;;114              
;;;115      TIM6 Update event occurs each TIM6CLK/256 
;;;116    
;;;117      Note: 
;;;118       SystemCoreClock variable holds HCLK frequency and is defined in system_stm32f4xx.c file.
;;;119       Each time the core clock (HCLK) changes, user had to call SystemCoreClockUpdate()
;;;120       function to update SystemCoreClock variable value. Otherwise, any configuration
;;;121       based on this variable will be incorrect.    
;;;122    
;;;123      ----------------------------------------------------------- */
;;;124      /* Time base configuration */
;;;125      TIM_TimeBaseStructInit(&TIM_TimeBaseStructure); 
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       TIM_TimeBaseStructInit
;;;126      TIM_TimeBaseStructure.TIM_Period = 420- 1;          
000010  f24010a3          MOV      r0,#0x1a3
000014  9001              STR      r0,[sp,#4]
;;;127      TIM_TimeBaseStructure.TIM_Prescaler = 0;       
000016  2000              MOVS     r0,#0
000018  f8ad0000          STRH     r0,[sp,#0]
;;;128      TIM_TimeBaseStructure.TIM_ClockDivision = 0;    
00001c  f8ad0008          STRH     r0,[sp,#8]
;;;129      TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  
000020  f8ad0002          STRH     r0,[sp,#2]
;;;130      TIM_TimeBaseInit(TIM6, &TIM_TimeBaseStructure);
000024  4669              MOV      r1,sp
000026  4806              LDR      r0,|L5.64|
000028  f7fffffe          BL       TIM_TimeBaseInit
;;;131    
;;;132      /* TIM6 TRGO selection */
;;;133      TIM_SelectOutputTrigger(TIM6, TIM_TRGOSource_Update);
00002c  2120              MOVS     r1,#0x20
00002e  4804              LDR      r0,|L5.64|
000030  f7fffffe          BL       TIM_SelectOutputTrigger
;;;134      
;;;135      /* TIM6 enable counter */
;;;136      TIM_Cmd(TIM6, ENABLE);
000034  2101              MOVS     r1,#1
000036  4802              LDR      r0,|L5.64|
000038  f7fffffe          BL       TIM_Cmd
;;;137    }
00003c  bd0e              POP      {r1-r3,pc}
;;;138    
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      0x40001000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  aSRC_0
                          %        320
                  aSRC_Pi
                          %        320
                  aSRC_Buffer
                          %        8192
                  u16CacheInput
                          %        320

                          AREA ||.data||, DATA, ALIGN=0

                  u8DAC2_Halffull
000000  00                DCB      0x00
                  u8DAC1_Halffull
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\MiddleWareDrv\\DMA_DAC.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_DMA_DAC_c_5df446d5____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_DMA_DAC_c_5df446d5____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_DMA_DAC_c_5df446d5____REVSH|
#line 144
|__asm___9_DMA_DAC_c_5df446d5____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_DMA_DAC_c_5df446d5____RRX|
#line 300
|__asm___9_DMA_DAC_c_5df446d5____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
