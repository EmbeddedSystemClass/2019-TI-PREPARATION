; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\dualtimermasterslave_md.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\dualtimermasterslave_md.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\MiddleWareDrv -I..\..\User\RTT -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 --omf_browse=.\flash\obj\dualtimermasterslave_md.crf ..\..\User\MiddleWareDrv\DualTimerMasterSlave_MD.c]
                          THUMB

                          AREA ||i.DualTimer_Init||, CODE, READONLY, ALIGN=2

                  DualTimer_Init PROC
;;;5      
;;;6      void DualTimer_Init(void)
000000  b500              PUSH     {lr}
;;;7      {
000002  b08b              SUB      sp,sp,#0x2c
;;;8        NVIC_InitTypeDef NVIC_InitStructure;
;;;9        TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
;;;10     	TIM_OCInitTypeDef         TIM_OCInitStructure;	
;;;11       GPIO_InitTypeDef GPIO_InitStructure;
;;;12     	
;;;13     //   RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);//使能GPIOC和AFIO端口功能
;;;14     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;15     	
;;;16     	// 如果是Stm32f103
;;;17     	// 定时器2 PWM频率为72000000/72/10=100Khz
;;;18     	// 定时器1 PWM频率为72000000/72/(10*ADCNUM*2)
;;;19     	// 如果是Stm32f407，APB1最高频率168Mhz/4=42Mhz
;;;20     	// CMSIS默认配置
;;;21     	/* PCLK2 = HCLK / 2*/
;;;22       /* PCLK1 = HCLK / 4*/
;;;23     	// 因此APB1的频率是42M，由于分频系数是4不等于1，则
;;;24     	// 定时器2 使用APB1，因此PWM频率为HCLK/4 * 2 /TIM_Prescaler/10 = 100Khz
;;;25     	// 定时器1 使用APB2，TIMCLK = 2 * HCLK / 2 = 168000000
;;;26     	// PWM频率为168000000/TIM_Prescaler/(10*ADCNUM*2) = 100Khz/(ADCNUM*2)
;;;27     	
;;;28     	//初始化定时器 TIM1
;;;29     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;30     
;;;31     	//初始化定时器 TIM2
;;;32     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
000014  2101              MOVS     r1,#1
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;33     
;;;34     	/* TIM1 configuration ------------------------------------------------------*/ 
;;;35       /* Time Base configuration */
;;;36       TIM_TimeBaseStructInit(&TIM_TimeBaseStructure); 
00001c  a808              ADD      r0,sp,#0x20
00001e  f7fffffe          BL       TIM_TimeBaseStructInit
;;;37       TIM_TimeBaseStructure.TIM_Period = 1000000/500 - 1;		// 10*(ADCNUM)*2 - 1;       			// 采样频率   
000022  f24070cf          MOV      r0,#0x7cf
000026  9009              STR      r0,[sp,#0x24]
;;;38       TIM_TimeBaseStructure.TIM_Prescaler = 168/1 - 1;       
000028  20a7              MOVS     r0,#0xa7
00002a  f8ad0020          STRH     r0,[sp,#0x20]
;;;39       TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;    
00002e  2000              MOVS     r0,#0
000030  f8ad0028          STRH     r0,[sp,#0x28]
;;;40       TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  
000034  f8ad0022          STRH     r0,[sp,#0x22]
;;;41       TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
000038  a908              ADD      r1,sp,#0x20
00003a  483c              LDR      r0,|L1.300|
00003c  f7fffffe          BL       TIM_TimeBaseInit
;;;42       /* TIM1 channel2 configuration in PWM mode */
;;;43       TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; 
000040  2060              MOVS     r0,#0x60
000042  f8ad000c          STRH     r0,[sp,#0xc]
;;;44       TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;                
000046  2001              MOVS     r0,#1
000048  f8ad000e          STRH     r0,[sp,#0xe]
;;;45       TIM_OCInitStructure.TIM_Pulse = 10*(ADCNUM)/4;							//10*1*(ADCNUM);
00004c  f44f7020          MOV      r0,#0x280
000050  9005              STR      r0,[sp,#0x14]
;;;46       TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;         
000052  2000              MOVS     r0,#0
000054  f8ad0018          STRH     r0,[sp,#0x18]
;;;47       TIM_OC2Init(TIM1, &TIM_OCInitStructure);
000058  a903              ADD      r1,sp,#0xc
00005a  4834              LDR      r0,|L1.300|
00005c  f7fffffe          BL       TIM_OC2Init
;;;48     
;;;49     	/* Master Mode selection */
;;;50       TIM_SelectOutputTrigger(TIM1, TIM_TRGOSource_OC2Ref);
000060  2150              MOVS     r1,#0x50
000062  4832              LDR      r0,|L1.300|
000064  f7fffffe          BL       TIM_SelectOutputTrigger
;;;51     
;;;52       /* Select the Master Slave Mode */
;;;53       TIM_SelectMasterSlaveMode(TIM1, TIM_MasterSlaveMode_Enable);
000068  2180              MOVS     r1,#0x80
00006a  4830              LDR      r0,|L1.300|
00006c  f7fffffe          BL       TIM_SelectMasterSlaveMode
;;;54     	
;;;55     	
;;;56       /* TIM2 configuration ------------------------------------------------------*/ 
;;;57       /* Time Base configuration */
;;;58       TIM_TimeBaseStructInit(&TIM_TimeBaseStructure); 
000070  a808              ADD      r0,sp,#0x20
000072  f7fffffe          BL       TIM_TimeBaseStructInit
;;;59       TIM_TimeBaseStructure.TIM_Period = 10 - 1;          // 400khz 
000076  2009              MOVS     r0,#9
000078  9009              STR      r0,[sp,#0x24]
;;;60       TIM_TimeBaseStructure.TIM_Prescaler = 84/4 - 1;     // 4000khz  
00007a  2014              MOVS     r0,#0x14
00007c  f8ad0020          STRH     r0,[sp,#0x20]
;;;61       TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;    
000080  2000              MOVS     r0,#0
000082  f8ad0028          STRH     r0,[sp,#0x28]
;;;62       TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  
000086  f8ad0022          STRH     r0,[sp,#0x22]
;;;63       TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
00008a  a908              ADD      r1,sp,#0x20
00008c  f04f4080          MOV      r0,#0x40000000
000090  f7fffffe          BL       TIM_TimeBaseInit
;;;64       /* TIM2 channel2 configuration in PWM mode */
;;;65       TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; 
000094  2060              MOVS     r0,#0x60
000096  f8ad000c          STRH     r0,[sp,#0xc]
;;;66       TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;                
00009a  2001              MOVS     r0,#1
00009c  f8ad000e          STRH     r0,[sp,#0xe]
;;;67       TIM_OCInitStructure.TIM_Pulse = 10/2 ;
0000a0  2005              MOVS     r0,#5
0000a2  9005              STR      r0,[sp,#0x14]
;;;68       TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;         
0000a4  2002              MOVS     r0,#2
0000a6  f8ad0018          STRH     r0,[sp,#0x18]
;;;69       TIM_OC2Init(TIM2, &TIM_OCInitStructure);
0000aa  a903              ADD      r1,sp,#0xc
0000ac  0740              LSLS     r0,r0,#29
0000ae  f7fffffe          BL       TIM_OC2Init
;;;70     
;;;71     	TIM_SelectInputTrigger(TIM2,TIM_TS_ITR0);
0000b2  2100              MOVS     r1,#0
0000b4  f04f4080          MOV      r0,#0x40000000
0000b8  f7fffffe          BL       TIM_SelectInputTrigger
;;;72     	
;;;73     	TIM_SelectSlaveMode(TIM2, TIM_SlaveMode_Gated);
0000bc  2105              MOVS     r1,#5
0000be  0788              LSLS     r0,r1,#30
0000c0  f7fffffe          BL       TIM_SelectSlaveMode
;;;74     
;;;75     //	/* TIM1 counter enable */
;;;76     //  TIM_Cmd(TIM1, ENABLE);
;;;77     	/* TIM1 main Output Enable */
;;;78       TIM_CtrlPWMOutputs(TIM1, ENABLE);  
0000c4  2101              MOVS     r1,#1
0000c6  4819              LDR      r0,|L1.300|
0000c8  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;79     
;;;80     //	/* TIM2 counter enable */
;;;81     //  TIM_Cmd(TIM2, ENABLE);
;;;82     	/* TIM1 main Output Enable */
;;;83       TIM_CtrlPWMOutputs(TIM2, ENABLE);  
0000cc  2101              MOVS     r1,#1
0000ce  0788              LSLS     r0,r1,#30
0000d0  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;84     
;;;85     //   RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//使能GPIOC和AFIO端口功能
;;;86     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
0000d4  2101              MOVS     r1,#1
0000d6  4608              MOV      r0,r1
0000d8  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;87     	
;;;88     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_9;
0000dc  f2402002          MOV      r0,#0x202
0000e0  9001              STR      r0,[sp,#4]
;;;89       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
0000e2  2002              MOVS     r0,#2
0000e4  f88d0008          STRB     r0,[sp,#8]
;;;90       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
0000e8  2003              MOVS     r0,#3
0000ea  f88d0009          STRB     r0,[sp,#9]
;;;91       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
0000ee  2000              MOVS     r0,#0
0000f0  f88d000a          STRB     r0,[sp,#0xa]
;;;92       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
0000f4  2001              MOVS     r0,#1
0000f6  f88d000b          STRB     r0,[sp,#0xb]
;;;93     	GPIO_Init(GPIOA, &GPIO_InitStructure);								//初始化GPIOA端口
0000fa  a901              ADD      r1,sp,#4
0000fc  480c              LDR      r0,|L1.304|
0000fe  f7fffffe          BL       GPIO_Init
;;;94     
;;;95     	/* Connect TIM1 pins to AF2 */  
;;;96       GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_TIM2);
000102  2201              MOVS     r2,#1
000104  4611              MOV      r1,r2
000106  480a              LDR      r0,|L1.304|
000108  f7fffffe          BL       GPIO_PinAFConfig
;;;97       GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_TIM1); 
00010c  2201              MOVS     r2,#1
00010e  2109              MOVS     r1,#9
000110  4807              LDR      r0,|L1.304|
000112  f7fffffe          BL       GPIO_PinAFConfig
;;;98     	
;;;99     	// 必须先使能从定时器Timer2，否则会有同步问题
;;;100      TIM_Cmd(TIM2, ENABLE);
000116  2101              MOVS     r1,#1
000118  0788              LSLS     r0,r1,#30
00011a  f7fffffe          BL       TIM_Cmd
;;;101    	
;;;102    	/* TIM1 counter enable */
;;;103      TIM_Cmd(TIM1, ENABLE);
00011e  2101              MOVS     r1,#1
000120  4802              LDR      r0,|L1.300|
000122  f7fffffe          BL       TIM_Cmd
;;;104    
;;;105    }
000126  b00b              ADD      sp,sp,#0x2c
000128  bd00              POP      {pc}
;;;106    
                          ENDP

00012a  0000              DCW      0x0000
                  |L1.300|
                          DCD      0x40010000
                  |L1.304|
                          DCD      0x40020000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\MiddleWareDrv\\DualTimerMasterSlave_MD.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___25_DualTimerMasterSlave_MD_c_aeb84d41____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___25_DualTimerMasterSlave_MD_c_aeb84d41____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___25_DualTimerMasterSlave_MD_c_aeb84d41____REVSH|
#line 144
|__asm___25_DualTimerMasterSlave_MD_c_aeb84d41____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___25_DualTimerMasterSlave_MD_c_aeb84d41____RRX|
#line 300
|__asm___25_DualTimerMasterSlave_MD_c_aeb84d41____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
